
=== Aplicação: br ===

```java
package br.com.plataforma.conexaodigital;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

/**
 * Classe principal da aplicação ConexãoAuth BMAD.
 * Microserviço de Identidade e Autorização (Authorization Server).
 */
@SpringBootApplication
@EnableScheduling
public class ConexaoAuthBmadApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConexaoAuthBmadApplication.class, args);
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.controller;

import br.com.plataforma.conexaodigital.admin.api.dto.DashboardResponse;
import br.com.plataforma.conexaodigital.admin.domain.service.DashboardService;
import br.com.plataforma.conexaodigital.role.api.responses.RoleResponse;
import br.com.plataforma.conexaodigital.role.domain.service.RoleService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.UUID;

/**
 * Controller API para suporte ao dashboard administrativo.
 * Fornece endpoints AJAX para carregamento dinâmico de dados.
 */
@RestController
@RequestMapping("/admin/api")
@RequiredArgsConstructor
@Slf4j
public class AdminApiController {

    private final DashboardService dashboardService;
    private final RoleService roleService;

    /**
     * Lista roles por realm para uso em formulários dinâmicos.
     */
    @GetMapping("/roles")
    public ResponseEntity<List<RoleResponse>> listarRolesPorRealm(
            @RequestParam(required = true) UUID realmId) {
        
        log.debug("Listando roles para realm: {}", realmId);
        
        List<RoleResponse> roles = roleService.listarPorRealm(realmId);
        
        return ResponseEntity.ok(roles);
    }

    /**
     * Obtém métricas atualizadas do dashboard para auto-refresh AJAX.
     */
    @GetMapping("/dashboard/metrics")
    public ResponseEntity<Map<String, Object>> getDashboardMetrics() {
        log.debug("Obtendo métricas do dashboard para auto-refresh");

        DashboardResponse dashboard = dashboardService.obterDashboard();

        return ResponseEntity.ok(Map.of(
            "totalUsuarios", dashboard.totalUsuarios(),
            "usuariosNovaSemana", dashboard.totalUsuarios() / 10, // Simplificado
            "totalRealms", dashboard.totalRealms(),
            "realmsAtivos", dashboard.totalRealms() - 1,
            "totalRoles", dashboard.totalRoles(),
            "chavesAtivas", dashboard.totalChavesAtivas(),
            "diasProximaRotacao", 7L,
            "eventosUltimas24h", 156L,
            "eventosCriticos", 3L,
            "ultimoRefresh", LocalDateTime.now()
        ));
    }

    /**
     * Obtém dados para o gráfico de evolução de usuários.
     */
    @GetMapping("/dashboard/user-evolution")
    public ResponseEntity<Map<String, Object>> getUserEvolution(
            @RequestParam(defaultValue = "7") int periodDays) {
        
        log.debug("Obtendo evolução de usuários para últimos {} dias", periodDays);
        
        // Dados simulados - substituir por implementação real
        List<String> periodos = List.of("Seg", "Ter", "Qua", "Qui", "Sex", "Sáb", "Dom");
        List<Long> valores = List.of(12L, 18L, 15L, 22L, 19L, 25L, 20L);
        
        return ResponseEntity.ok(Map.of(
            "label", "Novos Usuários",
            "valores", valores,
            "periodos", periodos
        ));
    }

    /**
     * Obtém distribuição de usuários por realm.
     */
    @GetMapping("/dashboard/realm-distribution")
    public ResponseEntity<List<Map<String, Object>>> getRealmDistribution() {
        log.debug("Obtendo distribuição por realm");
        
        DashboardResponse dashboard = dashboardService.obterDashboard();
        
        List<Map<String, Object>> distribution = new java.util.ArrayList<>();
        String[] cores = {
            "rgb(59, 130, 246)",   // blue-500
            "rgb(16, 185, 129)",   // green-500
            "rgb(245, 158, 11)",    // amber-500
            "rgb(239, 68, 68)",     // red-500
            "rgb(139, 92, 246)",    // violet-500
            "rgb(236, 72, 153)",    // pink-500
            "rgb(6, 182, 212)",     // cyan-500
            "rgb(249, 115, 22)"     // orange-500
        };
        
        for (int i = 0; i < dashboard.labelsUsuariosPorRealm().size() && i < cores.length; i++) {
            String realmNome = dashboard.labelsUsuariosPorRealm().get(i);
            Long totalPorRealm = dashboard.dadosUsuariosPorRealm().get(i);
            Double porcentagem = (dashboard.totalUsuarios() > 0 && totalPorRealm != null)
                ? (totalPorRealm.doubleValue() / dashboard.totalUsuarios()) * 100
                : 0.0;
            
            distribution.add(Map.of(
                "realmNome", realmNome,
                "totalUsuarios", totalPorRealm != null ? totalPorRealm : 0L,
                "porcentagem", porcentagem,
                "cor", cores[i]
            ));
        }
        
        return ResponseEntity.ok(distribution);
    }

    /**
     * Obtém eventos de auditoria por tipo para o gráfico.
     */
    @GetMapping("/dashboard/events-by-type")
    public ResponseEntity<List<Map<String, Object>>> getEventsByType() {
        log.debug("Obtendo eventos por tipo");
        
        // Dados simulados - substituir por implementação real do Epic 7
        String[] tipos = {"LOGIN", "CRIACAO", "EDICAO", "BLOQUEIO", "DESBLOQUEIO", "RESET_SENHA"};
        Long[] quantidades = {65L, 12L, 8L, 3L, 2L, 5L};
        String[] cores = {
            "rgb(59, 130, 246)",   // blue - LOGIN
            "rgb(16, 185, 129)",   // green - CRIACAO
            "rgb(245, 158, 11)",    // amber - EDICAO
            "rgb(239, 68, 68)",     // red - BLOQUEIO
            "rgb(139, 92, 246)",    // violet - DESBLOQUEIO
            "rgb(6, 182, 212)"     // cyan - RESET_SENHA
        };
        
        List<Map<String, Object>> eventosPorTipo = new java.util.ArrayList<>();
        Long totalEventos = 0L;
        for (Long q : quantidades) {
            totalEventos += q;
        }
        
        for (int i = 0; i < tipos.length; i++) {
            Long quantidade = quantidades[i];
            Double porcentagem = (totalEventos > 0)
                ? (quantidade.doubleValue() / totalEventos) * 100
                : 0.0;
            
            eventosPorTipo.add(Map.of(
                "tipo", tipos[i],
                "quantidade", quantidade,
                "porcentagem", porcentagem,
                "cor", cores[i]
            ));
        }
        
        return ResponseEntity.ok(eventosPorTipo);
    }

    /**
     * Obtém informações sobre a próxima rotação de chaves.
     */
    @GetMapping("/dashboard/key-rotation")
    public ResponseEntity<Map<String, Object>> getKeyRotationInfo() {
        log.debug("Obtendo informações de rotação de chaves");
        
        // Calcular próxima rotação (dia 1 do próximo mês às 00:00)
        LocalDateTime proximaRotacao = LocalDateTime.now()
            .plusMonths(1)
            .withDayOfMonth(1)
            .withHour(0)
            .withMinute(0)
            .withSecond(0)
            .withNano(0);
        
        LocalDateTime agora = LocalDateTime.now();
        
        // Calcular tempo restante
        long diasRestantes = java.time.temporal.ChronoUnit.DAYS.between(agora, proximaRotacao);
        long horasRestantes = java.time.temporal.ChronoUnit.HOURS.between(agora, proximaRotacao) % 24;
        long minutosRestantes = java.time.temporal.ChronoUnit.MINUTES.between(agora, proximaRotacao) % 60;
        long segundosRestantes = java.time.temporal.ChronoUnit.SECONDS.between(agora, proximaRotacao) % 60;
        
        // Calcular status
        String status;
        if (diasRestantes <= 0 && horasRestantes < 1) {
            status = "DANGER";
        } else if (diasRestantes < 7) {
            status = "WARNING";
        } else {
            status = "NORMAL";
        }
        
        // Calcular progresso (baseado em 30 dias como período total)
        long periodoTotal = 30;
        long diasPassados = periodoTotal - diasRestantes;
        double progresso = (diasPassados * 100.0) / periodoTotal;
        progresso = Math.max(0, Math.min(100, progresso));
        
        return ResponseEntity.ok(Map.of(
            "proximaRotacao", proximaRotacao,
            "diasRestantes", diasRestantes,
            "horasRestantes", horasRestantes,
            "minutosRestantes", minutosRestantes,
            "segundosRestantes", segundosRestantes,
            "status", status,
            "progresso", progresso
        ));
    }
}
```
```java
package br.com.plataforma.conexaodigital.admin.api.controller;

import br.com.plataforma.conexaodigital.auditoria.api.responses.EventoAuditoriaResponse;
import br.com.plataforma.conexaodigital.auditoria.domain.model.enums.TipoEventoAuditoria;
import br.com.plataforma.conexaodigital.auditoria.domain.service.AuditoriaService;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.UUID;

/**
 * Admin controller for audit event viewing in dashboard.
 */
@Controller
@RequestMapping("/admin")
@RequiredArgsConstructor
@PreAuthorize("hasRole('ADMIN')")
public class AdminAuditoriaController {

    private final AuditoriaService auditoriaService;
    private final RealmRepository realmRepository;

    /**
     * Displays the audit events list page.
     */
    @GetMapping("/auditoria")
    public String listaAuditoria(
            @RequestParam(required = false) UUID realmId,
            @RequestParam(required = false) TipoEventoAuditoria tipo,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime dataInicio,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime dataFim,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            Model model) {

        try {
            Pageable pageable = PageRequest.of(page, size, Sort.by("dataCriacao").descending());
            Page<EventoAuditoriaResponse> eventos = auditoriaService.listar(
                realmId, tipo, null, dataInicio, dataFim, pageable
            );

            // Calcular métricas para os cards da página de auditoria
            long totalEventos = eventos.getTotalElements();
            long loginsSucesso = 0;
            long loginFalhas = 0;
            long eventosHoje = 0;

            LocalDateTime hojeInicio = LocalDateTime.now().withHour(0).withMinute(0).withSecond(0).withNano(0);

            for (EventoAuditoriaResponse evento : eventos.getContent()) {
                if (evento.tipo() == TipoEventoAuditoria.LOGIN) {
                    loginsSucesso++;
                }

                if (evento.dataCriacao() != null && !evento.dataCriacao().isBefore(hojeInicio)) {
                    eventosHoje++;
                }
            }

            // Add realms for filtering
            model.addAttribute("eventos", eventos);
            model.addAttribute("realmsList", realmRepository.findAll());
            model.addAttribute("tiposEvento", TipoEventoAuditoria.values());
            model.addAttribute("realmId", realmId);
            model.addAttribute("tipo", tipo);
            model.addAttribute("dataInicio", dataInicio);
            model.addAttribute("dataFim", dataFim);

            // Métricas para os cards
            model.addAttribute("totalEventos", totalEventos);
            model.addAttribute("loginsSucesso", loginsSucesso);
            model.addAttribute("loginFalhas", loginFalhas);
            model.addAttribute("eventosHoje", eventosHoje);
            
        } catch (Exception e) {
            model.addAttribute("error", "Erro ao carregar eventos de auditoria: " + e.getMessage());
            model.addAttribute("eventos", Page.empty());
            model.addAttribute("totalEventos", 0L);
            model.addAttribute("loginsSucesso", 0L);
            model.addAttribute("loginFalhas", 0L);
            model.addAttribute("eventosHoje", 0L);
        }

        return "admin/auditoria/lista";
    }

    /**
     * API endpoint for listing audit events with filters.
     */
    @GetMapping("/auditoria/api/eventos")
    @ResponseBody
    public Page<EventoAuditoriaResponse> listarEventos(
            @RequestParam(required = false) UUID realmId,
            @RequestParam(required = false) TipoEventoAuditoria tipo,
            @RequestParam(required = false) String usuarioEmail,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime dataInicio,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime dataFim,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "dataCriacao,desc") String sort
    ) {
        // Validate maximum page size
        if (size > 100) {
            size = 100;
        }

        // Configure pagination with default sort
        Pageable pageable = PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "dataCriacao"));

        return auditoriaService.listar(realmId, tipo, usuarioEmail, dataInicio, dataFim, pageable);
    }

    /**
     * API endpoint for finding specific audit event by ID.
     */
    @GetMapping("/auditoria/api/eventos/{id}")
    @ResponseBody
    public ResponseEntity<EventoAuditoriaResponse> buscarEvento(@PathVariable UUID id) {
        EventoAuditoriaResponse response = auditoriaService.buscarPorId(id);
        return ResponseEntity.ok(response);
    }

    /**
     * API endpoint for exporting audit events to CSV.
     */
    @GetMapping("/auditoria/api/eventos/export")
    public void exportarEventos(
            @RequestParam(required = false) UUID realmId,
            @RequestParam(required = false) TipoEventoAuditoria tipo,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime dataInicio,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime dataFim,
            HttpServletResponse response
    ) throws IOException {
        Pageable pageable = PageRequest.of(0, 10000, Sort.by(Sort.Direction.DESC, "dataCriacao"));
        Page<EventoAuditoriaResponse> eventos = auditoriaService.listar(realmId, tipo, null, dataInicio, dataFim, pageable);

        String filename = "auditoria_" + LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss")) + ".csv";
        
        response.setContentType("text/csv");
        response.setHeader(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + filename + "\"");

        StringBuilder csv = new StringBuilder();
        csv.append("ID,Tipo,Usuario Email,Realm,Descricao,IP Address,User Agent,Data Criacao\n");

        for (EventoAuditoriaResponse evento : eventos.getContent()) {
            csv.append(evento.id()).append(",");
            csv.append(evento.tipo()).append(",");
            csv.append(evento.usuarioEmail() != null ? evento.usuarioEmail() : "").append(",");
            csv.append(evento.realmNome() != null ? evento.realmNome() : "").append(",");
            csv.append("\"").append(evento.descricao().replace("\"", "\"\"")).append("\",");
            csv.append(evento.ipAddress() != null ? evento.ipAddress() : "").append(",");
            csv.append("\"").append(evento.userAgent() != null ? evento.userAgent().replace("\"", "\"\"") : "").append("\",");
            csv.append(evento.dataCriacao().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))).append("\n");
        }

        response.getWriter().write(csv.toString());
    }
}
```
```java
package br.com.plataforma.conexaodigital.admin.api.controller;

import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

/**
 * Controller para autenticação administrativa.
 * Gerencia páginas de login, logout e redirecionamentos.
 */
@Controller
public class AdminAuthController {

    /**
     * Página de Login (GET).
     *
     * @param error    Parâmetro indicando erro de autenticação
     * @param message  Código de erro para exibição de mensagem personalizada
     * @param logout   Parâmetro indicando logout bem-sucedido
     * @param username Username preenchido (para manutenção após erro)
     * @param model    Model do Thymeleaf
     * @return Nome do template da página de login
     */
    @GetMapping("/admin/login")
    public String loginPage(
            @RequestParam(required = false) String error,
            @RequestParam(required = false) String message,
            @RequestParam(required = false) String logout,
            @RequestParam(required = false) String username,
            Model model) {
        // Mapear código de erro para mensagem
        String errorMessage = getErrorMessage(message);
        if (errorMessage != null) {
            model.addAttribute("errorMessage", errorMessage);
        }

        if (logout != null) {
            model.addAttribute("logout", true);
        }

        if (username != null) {
            model.addAttribute("username", username);
        }

        // Se houver erro de validação do BindingResult (flash attribute)
        if (model.containsAttribute("validationError")) {
            model.addAttribute("validationError", true);
        }

        return "admin/login";
    }

    /**
     * Página inicial após login (redirecionamento padrão).
     * OBSERVAÇÃO: Este endpoint é gerenciado pelo AdminController
     * (/admin/dashboard).
     * Este método é apenas um redirecionamento para manter compatibilidade.
     *
     * @param model          Model do Thymeleaf
     * @param authentication Autenticação do usuário atual
     * @return Redirect para /admin/dashboard
     */
    @GetMapping("/admin/home")
    public String defaultLoginSuccess(
            Model model,
            Authentication authentication) {
        return "redirect:/admin/dashboard";
    }

    /**
     * Página de acesso negado.
     *
     * @param redirectAttributes Atributos para redirect
     * @param authentication     Autenticação do usuário atual
     * @return Redirect para página de login
     */
    @GetMapping("/admin/access-denied")
    public String accessDeniedPage(
            RedirectAttributes redirectAttributes,
            Authentication authentication) {
        // TODO: Registrar evento de acesso negado na auditoria
        // if (authentication != null) {
        // String username = authentication.getName();
        // auditoriaService.registrarEvento(
        // TipoEventoAuditoria.ACESSO_NEGADO,
        // username,
        // null,
        // "Tentativa de acesso a recurso não autorizado",
        // null,
        // "FORBIDDEN"
        // );
        // }

        redirectAttributes.addFlashAttribute("error", true);
        return "redirect:/admin/login";
    }

    /**
     * Página de Recuperação de Senha (Placeholder).
     * Será implementada em Epic futuro (Epic 2 - Reset de Senha).
     *
     * @param model Model do Thymeleaf
     * @return Nome do template de recuperação de senha
     */
    @GetMapping("/admin/recuperar-senha")
    public String recuperacaoSenhaPage(Model model) {
        // Placeholder para funcionalidade futura
        return "admin/recuperar-senha";
    }

    /**
     * Mapear código de erro para mensagem em português.
     *
     * @param errorCode Código do erro
     * @return Mensagem de erro ou null
     */
    private String getErrorMessage(String errorCode) {
        if (errorCode == null) {
            return null;
        }

        switch (errorCode) {
            case "USER_NOT_FOUND":
                return "Usuário não encontrado no sistema.";
            case "INVALID_CREDENTIALS":
                return "Credenciais inválidas. Verifique email/CPF e senha.";
            case "ACCOUNT_DISABLED":
                return "Sua conta está desativada. Entre em contato com o administrador.";
            case "ACCOUNT_LOCKED":
                return "Sua conta está bloqueada devido a múltiplas tentativas falhas.";
            case "ACCOUNT_EXPIRED":
                return "Sua conta expirou. Entre em contato com o administrador.";
            case "CREDENTIALS_EXPIRED":
                return "Suas credenciais expiraram. Por favor, redefina sua senha.";
            case "AUTHENTICATION_FAILED":
                return "Falha na autenticação. Tente novamente.";
            default:
                return null;
        }
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.controller;

import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import br.com.plataforma.conexaodigital.chave.api.responses.ChaveResponse;
import br.com.plataforma.conexaodigital.chave.api.responses.RotacaoChaveResponse;
import br.com.plataforma.conexaodigital.chave.domain.model.TipoRotacao;
import br.com.plataforma.conexaodigital.chave.domain.service.ChaveService;
import br.com.plataforma.conexaodigital.chave.domain.service.RotacaoChaveService;
import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;

/**
 * Controller for cryptographic key management in admin dashboard.
 */
@Controller
@RequestMapping("/admin")
@RequiredArgsConstructor
public class AdminChaveController {

    private static final Logger log = LoggerFactory.getLogger(AdminChaveController.class);

    private final ChaveService chaveService;
    private final RotacaoChaveService rotacaoService;
    private final RealmRepository realmRepository;
    private final HttpServletRequest request;

    /**
     * Displays list of cryptographic keys with filtering options.
     *
     * @param realmId Optional realm ID filter
     * @param page    Page number (default: 0)
     * @param size    Page size (default: 10)
     * @param model   The model to add attributes to
     * @return The view name
     */
    @GetMapping("/chaves")
    @PreAuthorize("hasRole('ADMIN')")
    public String listarChaves(@RequestParam(required = false) UUID realmId,
                             @RequestParam(defaultValue = "0") int page,
                             @RequestParam(defaultValue = "10") int size,
                             Model model) {
        try {
            model.addAttribute("page", page);
            model.addAttribute("size", size);
            model.addAttribute("sizeHistorico", size);
            model.addAttribute("previousPage", page > 0 ? page - 1 : 0);
            model.addAttribute("nextPage", page + 1);
            model.addAttribute("totalPages", 1);
            model.addAttribute("totalElements", 0);
            model.addAttribute("hasPrevious", page > 0);
            model.addAttribute("hasNext", false);

            if (realmId != null) {
                List<ChaveResponse> chaves = chaveService.listar(realmId, null);
                List<RotacaoChaveResponse> historico = rotacaoService.historico(realmId, null, null, null);

                model.addAttribute("chaves", chaves);
                model.addAttribute("historico", historico);
                model.addAttribute("totalElements", chaves.size() + historico.size());
            } else {
                // Mostrar todas as chaves de todos os realms
                List<ChaveResponse> todasChaves = List.of();
                List<RotacaoChaveResponse> todoHistorico = List.of();

                try {
                    List<Realm> realms = realmRepository.findAll();
                    for (Realm realm : realms) {
                        try {
                            List<ChaveResponse> chavesRealm = chaveService.listarChavesPorRealm(realm.getId());
                            List<RotacaoChaveResponse> historicoRealm = rotacaoService.listarRotacoesPorRealm(realm.getId());
                            todasChaves.addAll(chavesRealm);
                            todoHistorico.addAll(historicoRealm);
                        } catch (Exception ex) {
                            log.warn("Erro ao carregar chaves do realm {}: {}", realm.getNome(), ex.getMessage());
                        }
                    }

                    model.addAttribute("chaves", todasChaves);
                    model.addAttribute("historico", todoHistorico);
                    model.addAttribute("totalElements", todasChaves.size() + todoHistorico.size());
                } catch (Exception ex) {
                    log.error("Erro ao carregar todas as chaves", ex);
                    model.addAttribute("error", "Erro ao carregar chaves: " + ex.getMessage());
                    model.addAttribute("chaves", List.of());
                    model.addAttribute("historico", List.of());
                    model.addAttribute("totalElements", 0);
                }
            }

            model.addAttribute("realms", realmRepository.findAll());
            model.addAttribute("filterRealmId", realmId);
            model.addAttribute("success", model.containsAttribute("success") ? model.getAttribute("success") : null);
            model.addAttribute("error", model.containsAttribute("error") ? model.getAttribute("error") : null);

        } catch (Exception e) {
            log.error("Erro ao listar chaves", e);
            model.addAttribute("error", "Erro ao carregar chaves: " + e.getMessage());
            model.addAttribute("chaves", List.of());
            model.addAttribute("historico", List.of());
        }

        return "admin/chaves/lista";
    }

    /**
     * Displays details of a specific cryptographic key.
     *
     * @param chaveId The key ID to display
     * @param model   The model to add attributes to
     * @return The view name
     */
    @GetMapping("/chaves/{chaveId}")
    @PreAuthorize("hasRole('ADMIN')")
    public String detalhesChave(@PathVariable UUID chaveId, Model model) {
        try {
            ChaveResponse chave = chaveService.buscarChave(chaveId);

            long diasRestantes = 0;
            if (chave.dataExpiracao() != null) {
                diasRestantes = ChronoUnit.DAYS.between(
                    LocalDate.now(),
                    chave.dataExpiracao()
                );
            }

            model.addAttribute("chave", chave);
            model.addAttribute("diasRestantes", diasRestantes);
            model.addAttribute("success", model.containsAttribute("success") ? model.getAttribute("success") : null);
            model.addAttribute("error", model.containsAttribute("error") ? model.getAttribute("error") : null);

        } catch (Exception e) {
            log.error("Erro ao carregar detalhes da chave", e);
            model.addAttribute("error", "Erro ao carregar detalhes da chave: " + e.getMessage());
        }

        return "admin/chaves/detail";
    }

    /**
     * Displays manual rotation page.
     *
     * @param model The model to add attributes to
     * @return The view name
     */
    @GetMapping("/chaves/rotar")
    @PreAuthorize("hasRole('ADMIN')")
    public String paginaRotacao(Model model) {
        try {
            model.addAttribute("realms", realmRepository.findAll());
            model.addAttribute("success", model.containsAttribute("success") ? model.getAttribute("success") : null);
            model.addAttribute("error", model.containsAttribute("error") ? model.getAttribute("error") : null);
        } catch (Exception e) {
            log.error("Erro ao carregar página de rotação", e);
            model.addAttribute("error", "Erro ao carregar página: " + e.getMessage());
        }

        return "admin/chaves/rotar";
    }

    /**
     * Performs manual rotation of keys for a realm.
     *
     * @param realmId            The realm ID to rotate keys for
     * @param motivo             Optional reason for rotation
     * @param redirectAttributes  Redirect attributes for flash messages
     * @return Redirect to keys list
     */
    @PostMapping("/chaves/{realmId}/rotacionar")
    @PreAuthorize("hasRole('ADMIN')")
    public String rotacionarChaves(@PathVariable UUID realmId,
                                    @RequestParam(required = false) String motivo,
                                    RedirectAttributes redirectAttributes) {
        try {
            ChaveResponse novaChave = rotacaoService.rotacionar(realmId, TipoRotacao.MANUAL);
            redirectAttributes.addFlashAttribute("success",
                "Chaves rotacionadas com sucesso. Nova chave versão " + novaChave.versao() + " criada.");
        } catch (Exception e) {
            log.error("Erro ao rotacionar chaves", e);
            redirectAttributes.addFlashAttribute("error", "Erro ao rotacionar chaves: " + e.getMessage());
        }

        return "redirect:/admin/chaves?realmId=" + realmId;
    }

    /**
     * Displays key rotation history with pagination.
     *
     * @param realmId Optional realm ID filter
     * @param page    Page number (default: 0)
     * @param size    Page size (default: 20)
     * @param model   The model to add attributes to
     * @return The view name
     */
    @GetMapping("/chaves/historico")
    @PreAuthorize("hasRole('ADMIN')")
    public String historicoRotacoes(@RequestParam(required = false) UUID realmId,
                                   @RequestParam(defaultValue = "0") int page,
                                   @RequestParam(defaultValue = "20") int size,
                                   Model model) {
        try {
            if (realmId != null) {
                List<RotacaoChaveResponse> historico = rotacaoService.historico(realmId, null, null, null);
                model.addAttribute("historico", historico);
                model.addAttribute("totalElements", historico.size());
            } else {
                model.addAttribute("historico", List.of());
                model.addAttribute("totalElements", 0);
            }

            model.addAttribute("realms", realmRepository.findAll());
            model.addAttribute("realmId", realmId);
            model.addAttribute("page", page);
            model.addAttribute("sizeHistorico", size);
            model.addAttribute("hasPrevious", page > 0);
            model.addAttribute("hasNext", false);

        } catch (Exception e) {
            log.error("Erro ao carregar histórico", e);
            model.addAttribute("error", "Erro ao carregar histórico: " + e.getMessage());
            model.addAttribute("historico", List.of());
            model.addAttribute("totalElements", 0);
        }

        return "admin/chaves/historico";
    }

    /**
     * API para listar chaves ativas (para AJAX com filtro de realm).
     */
    @GetMapping("/api/listar")
    @ResponseBody
    public Map<String, Object> listarChavesApi(@RequestParam(required = false) String realmId) {
        log.debug("API: Listar chaves - realmId: {}", realmId);

        try {
            List<ChaveResponse> chaves;
            UUID realmIdFilter = (realmId != null && !realmId.isBlank()) ? UUID.fromString(realmId) : null;

            if (realmIdFilter != null) {
                chaves = chaveService.listarChavesPorRealm(realmIdFilter);
            } else {
                chaves = List.of();
            }

            return Map.of(
                    "chavesAtivas", chaves,
                    "sucesso", true
            );
        } catch (Exception e) {
            log.error("Erro ao listar chaves", e);
            return Map.of(
                    "chavesAtivas", List.of(),
                    "sucesso", false,
                    "erro", e.getMessage()
            );
        }
    }

    /**
     * API para buscar chave ativa de um realm (para rotação).
     */
    @GetMapping("/api/chave-ativa/{realmId}")
    @ResponseBody
    public Map<String, Object> buscarChaveAtiva(@PathVariable UUID realmId) {
        log.debug("API: Buscar chave ativa - realmId: {}", realmId);

        try {
            ChaveResponse chave = chaveService.buscarChaveAtiva(realmId);

            return Map.of(
                    "chave", chave,
                    "sucesso", true
            );
        } catch (Exception e) {
            log.error("Erro ao buscar chave ativa", e);
            return Map.of(
                    "chave", null,
                    "sucesso", false,
                    "erro", e.getMessage()
            );
        }
    }

    /**
     * API para listar histórico de rotações (para AJAX).
     */
    @GetMapping("/api/rotacoes")
    @ResponseBody
    public Map<String, Object> listarRotacoes(@RequestParam(required = false) String realmId) {
        log.debug("API: Listar rotações - realmId: {}", realmId);

        try {
            UUID realmIdFilter = (realmId != null && !realmId.isBlank()) ? UUID.fromString(realmId) : null;
            List<RotacaoChaveResponse> historico;

            if (realmIdFilter != null) {
                historico = rotacaoService.listarRotacoesPorRealm(realmIdFilter);
            } else {
                historico = List.of();
            }

            return Map.of(
                    "historico", historico,
                    "sucesso", true
            );
        } catch (Exception e) {
            log.error("Erro ao listar rotações", e);
            return Map.of(
                    "historico", List.of(),
                    "sucesso", false,
                    "erro", e.getMessage()
            );
        }
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.controller;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import br.com.plataforma.conexaodigital.admin.api.dto.CadastroForm;
import br.com.plataforma.conexaodigital.admin.api.dto.DashboardResponse;
import br.com.plataforma.conexaodigital.admin.domain.service.DashboardService;
import br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmNotFoundException;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import br.com.plataforma.conexaodigital.role.domain.repository.RoleRepository;
import br.com.plataforma.conexaodigital.usuario.api.requests.CriarUsuarioRequest;
import br.com.plataforma.conexaodigital.usuario.domain.exceptions.EmailJaExisteException;
import br.com.plataforma.conexaodigital.usuario.domain.service.UsuarioService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Controller para as páginas do Dashboard Administrativo.
 * Gerencia login, cadastro e dashboard.
 */
@Controller
@RequestMapping("/admin")
@Slf4j
@RequiredArgsConstructor
public class AdminController {

    private final UsuarioService usuarioService;
    private final DashboardService dashboardService;
    private final RealmRepository realmRepository;
    private final RoleRepository roleRepository;

    // ==================== Login ====================
    // OBSERVAÇÃO: Endpoints de login são gerenciados pelo AdminAuthController

    // ==================== Cadastro ====================

    /**
     * Exibe a página de cadastro.
     */
    @GetMapping("/cadastro")
    public String cadastroPage(Model model) {
        log.debug("Acessando página de cadastro");
        model.addAttribute("cadastroForm", new CadastroForm("", "", "", ""));
        return "admin/cadastro";
    }

    /**
     * Processa o formulário de cadastro.
     */
    @PostMapping("/cadastro")
    public String processCadastro(@Valid @ModelAttribute CadastroForm form,
            BindingResult result,
            RedirectAttributes redirectAttributes) {
        log.debug("Processando cadastro para email: {}", form.email());

        if (result.hasErrors()) {
            log.warn("Erros de validação no cadastro: {}", result.getAllErrors());
            return "admin/cadastro";
        }

        try {
            // Busca o realm master
            var realm = realmRepository.findByNomeIgnoreCase("master")
                    .orElseThrow(() -> new RealmNotFoundException("Realm master não encontrado"));

            // Busca a role padrão USER
            var userRole = roleRepository.findByNomeAndRealmId("USER", realm.getId())
                    .orElseThrow(() -> new RuntimeException("Role USER não encontrada no realm master"));

            // Cria o usuário
            CriarUsuarioRequest request = new CriarUsuarioRequest(
                    form.nome(),
                    form.email(),
                    form.senha(),
                    realm.getId(),
                    List.of(userRole.getId()),
                    null,
                    null);

            usuarioService.criar(request);

            log.info("Usuário cadastrado com sucesso: {}", form.email());
            redirectAttributes.addFlashAttribute("success",
                    "Cadastro realizado com sucesso. Faça login para continuar.");
            return "redirect:/admin/login";
        } catch (EmailJaExisteException e) {
            log.warn("Email já cadastrado: {}", form.email());
            redirectAttributes.addFlashAttribute("error", "Email já cadastrado no sistema");
            return "redirect:/admin/cadastro";
        } catch (RealmNotFoundException e) {
            log.error("Realm master não encontrado durante cadastro", e);
            redirectAttributes.addFlashAttribute("error", "Erro ao processar cadastro. Contate o administrador.");
            return "redirect:/admin/cadastro";
        } catch (Exception e) {
            log.error("Erro ao cadastrar usuário", e);
            redirectAttributes.addFlashAttribute("error", "Erro ao processar cadastro");
            return "redirect:/admin/cadastro";
        }
    }

    // ==================== Dashboard ====================

    /**
     * Exibe o dashboard principal.
     */
    @GetMapping("/dashboard")
    public String dashboard(Model model, Authentication authentication) {
        if (authentication == null || !authentication.isAuthenticated()) {
            log.warn("Tentativa de acessar dashboard sem autenticação");
            return "redirect:/admin/login";
        }

        String email = authentication.getName();
        log.debug("Acessando dashboard para usuário: {}", email);

        DashboardResponse dashboard = dashboardService.obterDashboard();
        model.addAttribute("dashboard", dashboard);
        model.addAttribute("totalUsuarios", dashboard.totalUsuarios());
        model.addAttribute("totalRealms", dashboard.totalRealms());
        model.addAttribute("totalRoles", dashboard.totalRoles());
        model.addAttribute("totalChavesAtivas", dashboard.totalChavesAtivas());
        model.addAttribute("labelsUsuariosPorRealm", dashboard.labelsUsuariosPorRealm());
        model.addAttribute("dadosUsuariosPorRealm", dashboard.dadosUsuariosPorRealm());
        model.addAttribute("dadosUsuariosPorStatus", dashboard.dadosUsuariosPorStatus());
        model.addAttribute("eventosRecentes", dashboard.eventosRecentes());
        model.addAttribute("usuarioEmail", email);
        model.addAttribute("ultimaRotacao",
                LocalDateTime.now().plusDays(7).format(DateTimeFormatter.ofPattern("dd/MM/yyyy")));

        return "admin/dashboard/index";
    }

    /**
     * Processa o logout.
     */
    @PostMapping("/logout")
    public String logout(RedirectAttributes redirectAttributes) {
        log.debug("Processando logout");
        redirectAttributes.addFlashAttribute("logout", "Logout realizado com sucesso");
        return "redirect:/admin/login";
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.controller;

import org.springframework.data.domain.Page;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import br.com.plataforma.conexaodigital.admin.api.dto.forms.RealmForm;
import br.com.plataforma.conexaodigital.admin.api.dto.responses.RealmDetailResponse;
import br.com.plataforma.conexaodigital.admin.api.dto.responses.RealmListResponse;
import br.com.plataforma.conexaodigital.admin.domain.exceptions.RealmMasterNaoPodeSerEditadoException;
import br.com.plataforma.conexaodigital.admin.domain.service.AdminRealmService;
import br.com.plataforma.conexaodigital.chave.api.responses.ChaveResponse;
import br.com.plataforma.conexaodigital.chave.domain.service.ChaveService;
import br.com.plataforma.conexaodigital.chave.domain.service.RotacaoChaveService;
import br.com.plataforma.conexaodigital.realm.domain.exceptions.NomeRealmJaExisteException;
import br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmNotFoundException;
import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import br.com.plataforma.conexaodigital.role.domain.service.RoleService;
import br.com.plataforma.conexaodigital.usuario.domain.model.enums.StatusUsuario;
import br.com.plataforma.conexaodigital.usuario.domain.service.UsuarioService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Controller
@RequestMapping("/admin/realms")
@RequiredArgsConstructor
@Slf4j
public class AdminRealmController {

    private final AdminRealmService adminRealmService;
    private final br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository realmRepository;
    private final UsuarioService usuarioService;
    private final RoleService roleService;
    private final ChaveService chaveService;
    private final RotacaoChaveService rotacaoChaveService;

    @GetMapping
    public String listarRealms(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(required = false) String nome,
            @RequestParam(required = false) String status,
            Model model,
            jakarta.servlet.http.HttpServletRequest request) {
        log.info("Exibindo lista de realms: page={}, size={}, nome={}, status={}", page, size, nome, status);

        Page<RealmListResponse> realmsPage = adminRealmService.listarRealms(page, size, nome, status);

        model.addAttribute("realms", realmsPage.getContent());
        model.addAttribute("page", realmsPage.getNumber());
        model.addAttribute("size", realmsPage.getSize());
        model.addAttribute("totalPages", realmsPage.getTotalPages());
        model.addAttribute("totalElements", realmsPage.getTotalElements());
        model.addAttribute("hasPrevious", realmsPage.hasPrevious());
        model.addAttribute("hasNext", realmsPage.hasNext());
        model.addAttribute("previousPage", realmsPage.hasPrevious() ? realmsPage.getNumber() - 1 : 0);
        model.addAttribute("nextPage", realmsPage.hasNext() ? realmsPage.getNumber() + 1 : realmsPage.getNumber());

        model.addAttribute("filterNome", nome);
        model.addAttribute("filterStatus", status);

        // Verificar se é requisição AJAX
        boolean isAjax = isAjaxRequest(request);
        if (isAjax) {
            return "admin/realms/list :: tableFragment";
        }

        return "admin/realms/list";
    }

    @GetMapping("/novo")
    public String novoRealm(Model model) {
        log.info("Exibindo formulário de novo realm");

        model.addAttribute("realmForm", new RealmForm());
        model.addAttribute("editMode", false);
        model.addAttribute("pageTitle", "Novo Realm");

        return "admin/realms/create";
    }

    @GetMapping("/{id}/edit")
    public String editarRealm(
            @PathVariable String id,
            Model model) {
        log.info("Exibindo formulário de edição do realm: {}", id);

        try {
            RealmDetailResponse realm = adminRealmService.buscarPorId(id);

            RealmForm form = new RealmForm(
                    realm.id(),
                    realm.nome(),
                    realm.descricao(),
                    realm.ativo(),
                    realm.empresaId(),
                    realm.tenantId());

            boolean isMaster = realm.master() != null && realm.master();

            model.addAttribute("realmForm", form);
            model.addAttribute("editMode", true);
            model.addAttribute("pageTitle", "Editar Realm");
            model.addAttribute("isMaster", isMaster);

            return "admin/realms/edit";

        } catch (RealmNotFoundException e) {
            model.addAttribute("error", "Realm não encontrado: " + id);
            return "error/404";
        }
    }

    @PostMapping
    public String criarRealm(
            @Valid @ModelAttribute RealmForm form,
            BindingResult result,
            RedirectAttributes redirectAttributes,
            Model model) {
        log.info("Processando criação de realm: {}", form.getNome());

        if (result.hasErrors()) {
            log.warn("Erros de validação ao criar realm: {}", result.getAllErrors());
            // Adiciona atributos necessários para o template
            model.addAttribute("editMode", false);
            model.addAttribute("pageTitle", "Novo Realm");
            return "admin/realms/edit";
        }

        try {
            Realm realm = adminRealmService.criarRealm(form);
            redirectAttributes.addFlashAttribute("success",
                    "Realm \"" + form.getNome() + "\" criado com sucesso!");
            return "redirect:/admin/realms";

        } catch (NomeRealmJaExisteException e) {
            result.rejectValue("nome", null, e.getMessage());
            model.addAttribute("editMode", false);
            model.addAttribute("pageTitle", "Novo Realm");
            return "admin/realms/edit";

        } catch (Exception e) {
            log.error("Erro ao criar realm", e);
            result.reject(null, "Erro ao criar realm: " + e.getMessage());
            model.addAttribute("editMode", false);
            model.addAttribute("pageTitle", "Novo Realm");
            return "admin/realms/edit";
        }
    }

    @PutMapping("/{id}")
    public String atualizarRealm(
            @PathVariable String id,
            @Valid @ModelAttribute RealmForm form,
            BindingResult result,
            RedirectAttributes redirectAttributes,
            Model model) {
        log.info("Processando atualização do realm: {}", id);

        if (result.hasErrors()) {
            log.warn("Erros de validação ao atualizar realm: {}", result.getAllErrors());
            // Adiciona atributos necessários para o template
            model.addAttribute("editMode", true);
            model.addAttribute("pageTitle", "Editar Realm");
            return "admin/realms/edit";
        }

        try {
            adminRealmService.atualizarRealm(id, form);
            redirectAttributes.addFlashAttribute("success",
                    "Realm \"" + form.getNome() + "\" atualizado com sucesso!");
            return "redirect:/admin/realms";

        } catch (RealmNotFoundException e) {
            result.reject(null, e.getMessage());
            model.addAttribute("editMode", true);
            model.addAttribute("pageTitle", "Editar Realm");
            return "admin/realms/edit";

        } catch (NomeRealmJaExisteException e) {
            result.rejectValue("nome", null, e.getMessage());
            model.addAttribute("editMode", true);
            model.addAttribute("pageTitle", "Editar Realm");
            return "admin/realms/edit";

        } catch (RealmMasterNaoPodeSerEditadoException e) {
            result.reject(null, e.getMessage());
            model.addAttribute("editMode", true);
            model.addAttribute("pageTitle", "Editar Realm");
            return "admin/realms/edit";

        } catch (Exception e) {
            log.error("Erro ao atualizar realm", e);
            result.reject(null, "Erro ao atualizar realm: " + e.getMessage());
            model.addAttribute("editMode", true);
            model.addAttribute("pageTitle", "Editar Realm");
            return "admin/realms/edit";
        }
    }

    @PutMapping("/{id}/desativar")
    public Object desativarRealm(
            @PathVariable String id,
            RedirectAttributes redirectAttributes,
            jakarta.servlet.http.HttpServletRequest request) {
        log.info("Processando desativação do realm: {}", id);

        boolean isAjax = isAjaxRequest(request);

        try {
            Realm realm = adminRealmService.desativarRealm(id);
            log.info("Realm {} desativado com sucesso (soft delete - permanece no banco)", realm.getId());

            if (isAjax) {
                return org.springframework.http.ResponseEntity.ok(java.util.Map.of(
                        "success", true,
                        "message", "Realm desativado com sucesso! O realm permanece no banco de dados.",
                        "realmId", realm.getId().toString(),
                        "realmNome", realm.getNome()));
            }

            redirectAttributes.addFlashAttribute("success",
                    "Realm desativado com sucesso!");
            return "redirect:/admin/realms";

        } catch (RealmNotFoundException e) {
            if (isAjax) {
                return org.springframework.http.ResponseEntity.status(org.springframework.http.HttpStatus.NOT_FOUND)
                        .body(java.util.Map.of("success", false, "message", e.getMessage()));
            }
            redirectAttributes.addFlashAttribute("error", e.getMessage());
            return "redirect:/admin/realms";

        } catch (RealmMasterNaoPodeSerEditadoException e) {
            if (isAjax) {
                return org.springframework.http.ResponseEntity.status(org.springframework.http.HttpStatus.FORBIDDEN)
                        .body(java.util.Map.of("success", false, "message", e.getMessage()));
            }
            redirectAttributes.addFlashAttribute("error", e.getMessage());
            return "redirect:/admin/realms";

        } catch (Exception e) {
            log.error("Erro ao desativar realm", e);
            if (isAjax) {
                return org.springframework.http.ResponseEntity
                        .status(org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR)
                        .body(java.util.Map.of("success", false, "message",
                                "Erro ao desativar realm: " + e.getMessage()));
            }
            redirectAttributes.addFlashAttribute("error",
                    "Erro ao desativar realm: " + e.getMessage());
            return "redirect:/admin/realms";
        }
    }

    @PutMapping("/{id}/ativar")
    public Object ativarRealm(
            @PathVariable String id,
            RedirectAttributes redirectAttributes,
            jakarta.servlet.http.HttpServletRequest request) {
        log.info("Processando ativação do realm: {}", id);

        boolean isAjax = isAjaxRequest(request);

        try {
            Realm realm = adminRealmService.ativarRealm(id);
            log.info("Realm {} ativado com sucesso", realm.getId());

            if (isAjax) {
                return org.springframework.http.ResponseEntity.ok(java.util.Map.of(
                        "success", true,
                        "message", "Realm ativado com sucesso!",
                        "realmId", realm.getId().toString(),
                        "realmNome", realm.getNome()));
            }

            redirectAttributes.addFlashAttribute("success",
                    "Realm ativado com sucesso!");
            return "redirect:/admin/realms";

        } catch (RealmNotFoundException e) {
            if (isAjax) {
                return org.springframework.http.ResponseEntity.status(org.springframework.http.HttpStatus.NOT_FOUND)
                        .body(java.util.Map.of("success", false, "message", e.getMessage()));
            }
            redirectAttributes.addFlashAttribute("error", e.getMessage());
            return "redirect:/admin/realms";

        } catch (Exception e) {
            log.error("Erro ao ativar realm", e);
            if (isAjax) {
                return org.springframework.http.ResponseEntity
                        .status(org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR)
                        .body(java.util.Map.of("success", false, "message", "Erro ao ativar realm: " + e.getMessage()));
            }
            redirectAttributes.addFlashAttribute("error",
                    "Erro ao ativar realm: " + e.getMessage());
            return "redirect:/admin/realms";
        }
    }

    @GetMapping("/{id}")
    public String verRealm(
            @PathVariable String id,
            Model model) {
        log.info("Exibindo detalhes do realm: {}", id);

        try {
            RealmDetailResponse realm = adminRealmService.buscarPorId(id);
            model.addAttribute("realm", realm);
            return "admin/realms/detail";

        } catch (RealmNotFoundException e) {
            model.addAttribute("error", "Realm não encontrado: " + id);
            return "error/404";
        }
    }

    @GetMapping("/{realmId}/usuarios")
    public String listarUsuariosDoRealm(
            @PathVariable String realmId,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(required = false) String nome,
            @RequestParam(required = false) StatusUsuario status,
            Model model) {

        log.info("Listando usuários do realm: {} - page={}, size={}, nome={}, status={}",
                realmId, page, size, nome, status);

        try {
            // Buscar informações do realm
            RealmDetailResponse realm = adminRealmService.buscarPorId(realmId);
            model.addAttribute("realm", realm);

            // Buscar usuários do realm com paginação e filtros
            var pageable = org.springframework.data.domain.PageRequest.of(
                    page, size, org.springframework.data.domain.Sort.by("nome").ascending());

            var usuarios = usuarioService.listar(
                    nome, null, java.util.UUID.fromString(realmId), null, null,
                    status, null, null, null, pageable);

            model.addAttribute("usuarios", usuarios.getContent());
            model.addAttribute("page", usuarios.getNumber());
            model.addAttribute("size", usuarios.getSize());
            model.addAttribute("totalElements", usuarios.getTotalElements());
            model.addAttribute("hasPrevious", usuarios.hasPrevious());
            model.addAttribute("hasNext", usuarios.hasNext());
            model.addAttribute("previousPage", usuarios.hasPrevious() ? usuarios.getNumber() - 1 : 0);
            model.addAttribute("nextPage", usuarios.hasNext() ? usuarios.getNumber() + 1 : usuarios.getNumber());

            model.addAttribute("filterNome", nome);
            model.addAttribute("filterStatus", status);

            return "admin/realms/usuarios";

        } catch (RealmNotFoundException e) {
            model.addAttribute("error", "Realm não encontrado: " + realmId);
            return "error/404";
        }
    }

    @GetMapping("/{realmId}/roles")
    public String listarRolesDoRealm(
            @PathVariable String realmId,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(required = false) String nome,
            @RequestParam(required = false) Boolean padrao,
            Model model) {

        log.info("Listando roles do realm: {} - page={}, size={}, nome={}, padrao={}",
                realmId, page, size, nome, padrao);

        try {
            // Buscar informações do realm
            RealmDetailResponse realm = adminRealmService.buscarPorId(realmId);
            model.addAttribute("realm", realm);

            // Buscar roles do realm com paginação e filtros
            var pageable = org.springframework.data.domain.PageRequest.of(
                    page, size, org.springframework.data.domain.Sort.by("nome").ascending());

            var roles = roleService.listar(
                    java.util.UUID.fromString(realmId), nome, padrao, pageable);

            model.addAttribute("roles", roles.getContent());
            model.addAttribute("page", roles.getNumber());
            model.addAttribute("size", roles.getSize());
            model.addAttribute("totalElements", roles.getTotalElements());
            model.addAttribute("hasPrevious", roles.hasPrevious());
            model.addAttribute("hasNext", roles.hasNext());
            model.addAttribute("previousPage", roles.hasPrevious() ? roles.getNumber() - 1 : 0);
            model.addAttribute("nextPage", roles.hasNext() ? roles.getNumber() + 1 : roles.getNumber());

            model.addAttribute("filterNome", nome);
            model.addAttribute("filterPadrao", padrao);

            return "admin/realms/roles";

        } catch (RealmNotFoundException e) {
            model.addAttribute("error", "Realm não encontrado: " + realmId);
            return "error/404";
        }
    }

    @GetMapping("/{realmId}/chaves")
    public String listarChavesDoRealm(
            @PathVariable String realmId,
            Model model) {

        log.info("Listando chaves do realm: {}", realmId);

        try {
            // Buscar informações do realm
            RealmDetailResponse realm = adminRealmService.buscarPorId(realmId);
            model.addAttribute("realm", realm);

            // Buscar chaves ativas do realm
            var chavesAtivas = chaveService.listar(java.util.UUID.fromString(realmId), null)
                    .stream()
                    .filter(chave -> chave.status().name().equals("ATIVA") || chave.status().name().equals("EXPIRANDO"))
                    .toList();

            // Adicionar dias para expiração
            var chavesComDias = chavesAtivas.stream()
                    .map(chave -> {
                        long diasParaExpiracao = java.time.temporal.ChronoUnit.DAYS.between(
                                java.time.LocalDateTime.now(), chave.dataExpiracao());
                        return new ChaveComDias(chave, Math.max(0, diasParaExpiracao));
                    })
                    .toList();

            model.addAttribute("chavesAtivas", chavesComDias);

            // Buscar histórico de rotações
            var historicoRotacoes = rotacaoChaveService.listarRotacoesPorRealm(java.util.UUID.fromString(realmId));

            model.addAttribute("historicoRotacoes", historicoRotacoes);

            return "admin/realms/chaves";

        } catch (RealmNotFoundException e) {
            model.addAttribute("error", "Realm não encontrado: " + realmId);
            return "error/404";
        }
    }

    // Classe auxiliar para chaves com dias para expiração
    private static record ChaveComDias(ChaveResponse chave, long diasParaExpiracao) {
    }

    @ExceptionHandler({ NomeRealmJaExisteException.class,
            RealmNotFoundException.class,
            RealmMasterNaoPodeSerEditadoException.class })
    public String handleRealmExceptions(
            Exception exception,
            RedirectAttributes redirectAttributes) {
        log.error("Erro no controller de realms: {}", exception.getMessage());
        redirectAttributes.addFlashAttribute("error", exception.getMessage());
        return "redirect:/admin/realms";
    }

    @PostMapping("/bulk/desativar")
    @ResponseBody
    public org.springframework.http.ResponseEntity<java.util.Map<String, Object>> bulkDesativar(
            @RequestBody java.util.Map<String, java.util.List<String>> request) {
        java.util.List<String> ids = request.get("ids");
        log.info("Desativando {} realms em massa", ids.size());

        try {
            for (String id : ids) {
                br.com.plataforma.conexaodigital.realm.domain.model.Realm realm = realmRepository
                        .findById(java.util.UUID.fromString(id))
                        .orElse(null);
                if (realm != null && realm.getMaster() != null && realm.getMaster()) {
                    return org.springframework.http.ResponseEntity.ok(java.util.Map.of(
                            "success", false,
                            "message", "Realm Master não pode ser desativado"));
                }
            }

            int count = 0;
            for (String id : ids) {
                try {
                    adminRealmService.desativarRealm(id);
                    count++;
                } catch (Exception e) {
                    log.warn("Erro ao desativar realm {}: {}", id, e.getMessage());
                }
            }

            return org.springframework.http.ResponseEntity.ok(java.util.Map.of(
                    "success", true,
                    "count", count,
                    "message", count + " realm(s) desativado(s) com sucesso"));

        } catch (Exception e) {
            log.error("Erro ao desativar realms em massa", e);
            return org.springframework.http.ResponseEntity.ok(java.util.Map.of(
                    "success", false,
                    "message", "Erro ao desativar realms: " + e.getMessage()));
        }
    }

    @PostMapping("/bulk/ativar")
    @ResponseBody
    public org.springframework.http.ResponseEntity<java.util.Map<String, Object>> bulkAtivar(
            @RequestBody java.util.Map<String, java.util.List<String>> request) {
        java.util.List<String> ids = request.get("ids");
        log.info("Ativando {} realms em massa", ids.size());

        try {
            int count = 0;
            for (String id : ids) {
                try {
                    adminRealmService.ativarRealm(id);
                    count++;
                } catch (Exception e) {
                    log.warn("Erro ao ativar realm {}: {}", id, e.getMessage());
                }
            }

            return org.springframework.http.ResponseEntity.ok(java.util.Map.of(
                    "success", true,
                    "count", count,
                    "message", count + " realm(s) ativado(s) com sucesso"));

        } catch (Exception e) {
            log.error("Erro ao ativar realms em massa", e);
            return org.springframework.http.ResponseEntity.ok(java.util.Map.of(
                    "success", false,
                    "message", "Erro ao ativar realms: " + e.getMessage()));
        }
    }

    /**
     * Método auxiliar para detectar se a requisição é AJAX.
     */
    private boolean isAjaxRequest(jakarta.servlet.http.HttpServletRequest request) {
        return "XMLHttpRequest".equals(request.getHeader("X-Requested-With")) ||
                request.getHeader("Accept") != null &&
                        request.getHeader("Accept").contains("application/json");
    }



    /**
      * Endpoint AJAX para desativar um realm individual.
      * Este endpoint retorna JSON para requisições AJAX.
      *
      * IMPORTANTE: Este método NÃO EXCLUI o realm do banco de dados.
      * Apenas muda o status para INATIVO (soft delete).
      */
    @PutMapping(value = "/{id}/desativar", produces = "application/json")
    @ResponseBody
    public org.springframework.http.ResponseEntity<java.util.Map<String, Object>> desativarRealmAjax(
            @PathVariable String id) {
        log.info("Processando desativação AJAX do realm: {}", id);

        try {
            Realm realm = adminRealmService.desativarRealm(id);
            log.info("Realm {} desativado com sucesso (soft delete - permanece no banco)", realm.getId());

            return org.springframework.http.ResponseEntity.ok(java.util.Map.of(
                    "success", true,
                    "message", "Realm desativado com sucesso! O realm permanece no banco de dados.",
                    "realmId", realm.getId().toString(),
                    "realmNome", realm.getNome()));

        } catch (RealmNotFoundException e) {
            log.error("Realm não encontrado: {}", id);
            return org.springframework.http.ResponseEntity.status(org.springframework.http.HttpStatus.NOT_FOUND)
                    .body(java.util.Map.of(
                            "success", false,
                            "message", e.getMessage()));

        } catch (RealmMasterNaoPodeSerEditadoException e) {
            log.error("Tentativa de desativar realm master: {}", id);
            return org.springframework.http.ResponseEntity.status(org.springframework.http.HttpStatus.FORBIDDEN)
                    .body(java.util.Map.of(
                            "success", false,
                            "message", e.getMessage()));

        } catch (Exception e) {
            log.error("Erro ao desativar realm", e);
            return org.springframework.http.ResponseEntity
                    .status(org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(java.util.Map.of(
                            "success", false,
                            "message", "Erro ao desativar realm: " + e.getMessage()));
        }
    }

    /**
     * Endpoint AJAX para ativar um realm individual.
     * Este endpoint retorna JSON para requisições AJAX.
     */
    @PutMapping(value = "/{id}/ativar", produces = "application/json")
    @ResponseBody
    public org.springframework.http.ResponseEntity<java.util.Map<String, Object>> ativarRealmAjax(
            @PathVariable String id) {
        log.info("Processando ativação AJAX do realm: {}", id);

        try {
            Realm realm = adminRealmService.ativarRealm(id);
            log.info("Realm {} ativado com sucesso", realm.getId());

            return org.springframework.http.ResponseEntity.ok(java.util.Map.of(
                    "success", true,
                    "message", "Realm ativado com sucesso!",
                    "realmId", realm.getId().toString(),
                    "realmNome", realm.getNome()));

        } catch (RealmNotFoundException e) {
            log.error("Realm não encontrado: {}", id);
            return org.springframework.http.ResponseEntity.status(org.springframework.http.HttpStatus.NOT_FOUND)
                    .body(java.util.Map.of(
                            "success", false,
                            "message", e.getMessage()));

        } catch (Exception e) {
            log.error("Erro ao ativar realm", e);
            return org.springframework.http.ResponseEntity
                    .status(org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(java.util.Map.of(
                            "success", false,
                            "message", "Erro ao ativar realm: " + e.getMessage()));
        }
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.controller;

import org.springframework.data.domain.Page;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import br.com.plataforma.conexaodigital.admin.api.dto.forms.RoleForm;
import br.com.plataforma.conexaodigital.admin.api.dto.responses.RoleDetailResponse;
import br.com.plataforma.conexaodigital.admin.api.dto.responses.RoleListResponse;
import br.com.plataforma.conexaodigital.admin.domain.service.AdminRoleService;
import br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmNotFoundException;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import br.com.plataforma.conexaodigital.role.domain.exceptions.NomeRoleJaExisteException;
import br.com.plataforma.conexaodigital.role.domain.exceptions.RoleEmUsoException;
import br.com.plataforma.conexaodigital.role.domain.exceptions.RoleNotFoundException;
import br.com.plataforma.conexaodigital.role.domain.exceptions.RolePadraoNaoPodeSerRemovidaException;
import br.com.plataforma.conexaodigital.role.domain.model.Role;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Controller para a interface administrativa de gestão de roles.
 * Fornece endpoints para listar, criar, editar e remover roles.
 *
 * Lições Aprendidas (LECOES_E_BOLEADOS.md):
 * - Seguir convenções RESTful: PUT para atualização, não POST
 * - Verificar assinaturas exatas de DTOs/Records
 * - Logs em múltiplos níveis para debugging
 * - SweetAlert2 para feedback visual (não alert() nativo)
 */
@Controller
@RequestMapping("/admin/roles")
@RequiredArgsConstructor
@Slf4j
public class AdminRoleController {

    private final AdminRoleService adminRoleService;
    private final RealmRepository realmRepository;

    /**
     * Lista todas as roles com paginação e filtros.
     */
    @GetMapping
    public String listarRoles(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(required = false) String nome,
            @RequestParam(required = false) String realmId,
            @RequestParam(required = false) Boolean padrao,
            Model model) {
        log.info("=== INÍCIO: Listando roles ===");
        log.info("=== PARÂMETROS RECEBIDOS: page={}, size={}, nome='{}', realmId='{}', padrao={} ===",
                page, size, nome, realmId, padrao);
        log.debug("Parâmetros: page={}, size={}, nome={}, realmId={}, padrao={}",
                page, size, nome, realmId, padrao);

        Page<RoleListResponse> rolesPage = adminRoleService.listarRoles(page, size, nome, realmId, padrao);

        model.addAttribute("roles", rolesPage.getContent());
        model.addAttribute("page", rolesPage.getNumber());
        model.addAttribute("size", rolesPage.getSize());
        model.addAttribute("totalPages", rolesPage.getTotalPages());
        model.addAttribute("totalElements", rolesPage.getTotalElements());
        model.addAttribute("hasPrevious", rolesPage.hasPrevious());
        model.addAttribute("hasNext", rolesPage.hasNext());
        model.addAttribute("previousPage", rolesPage.hasPrevious() ? rolesPage.getNumber() - 1 : 0);
        model.addAttribute("nextPage", rolesPage.hasNext() ? rolesPage.getNumber() + 1 : rolesPage.getNumber());

        model.addAttribute("filterNome", nome);
        model.addAttribute("filterRealmId", realmId);
        model.addAttribute("filterPadrao", padrao);

        // Carregar realms para o filtro
        var realms = realmRepository.findAll();
        model.addAttribute("realms", realms);

        log.debug("Total de roles encontradas: {}", rolesPage.getTotalElements());

        return "admin/roles/list";
    }

    /**
     * Exibe o formulário para criar uma nova role.
     * Lição: Carregar dados iniciais para selects (realms).
     */
    @GetMapping("/novo")
    public String novaRole(Model model) {
        log.info("=== INÍCIO: Exibindo formulário de nova role ===");

        // Carregar realms disponíveis para o select
        var realms = realmRepository.findAll();

        model.addAttribute("roleForm", new RoleForm());
        model.addAttribute("editMode", false);
        model.addAttribute("pageTitle", "Nova Role");
        model.addAttribute("realms", realms);

        log.debug("Total de realms disponíveis: {}", realms.size());

        return "admin/roles/create";
    }

    /**
     * Exibe o formulário para editar uma role existente.
     * Lição: Passar todos os campos necessários ao model, inclusive realms.
     */
    @GetMapping("/{id}/edit")
    public String editarRole(
            @PathVariable String id,
            Model model) {
        log.info("=== INÍCIO: Exibindo formulário de edição da role: {} ===", id);

        try {
            RoleDetailResponse role = adminRoleService.buscarPorId(id);

            // Carregar realms disponíveis para o select
            var realms = realmRepository.findAll();

            // RoleForm espera: id, nome, descricao, realmId, padrao
            RoleForm form = new RoleForm(
                    role.id(),
                    role.nome(),
                    role.descricao(),
                    role.realmId(),
                    role.padrao());

            boolean isPadrao = role.padrao() != null && role.padrao();

            model.addAttribute("roleForm", form);
            model.addAttribute("editMode", true);
            model.addAttribute("pageTitle", "Editar Role");
            model.addAttribute("isPadrao", isPadrao);
            model.addAttribute("realms", realms);

            log.debug("Role carregada: {}, isPadrao: {}", role.nome(), isPadrao);

            return "admin/roles/edit";

        } catch (RoleNotFoundException e) {
            log.error("=== ERRO: Role não encontrada: {} ===", id);
            model.addAttribute("error", "Role não encontrada: " + id);
            return "error/404";
        }
    }

    /**
     * Exibe os detalhes de uma role.
     */
    @GetMapping("/{id}")
    public String verRole(
            @PathVariable String id,
            Model model) {
        log.info("=== INÍCIO: Exibindo detalhes da role: {} ===", id);

        try {
            RoleDetailResponse role = adminRoleService.buscarPorId(id);
            model.addAttribute("role", role);
            return "admin/roles/detail";

        } catch (RoleNotFoundException e) {
            log.error("=== ERRO: Role não encontrada: {} ===", id);
            model.addAttribute("error", "Role não encontrada: " + id);
            return "error/404";
        }
    }

    /**
     * Processa a criação de uma nova role.
     * Lição: Usar POST para criação, retornar formulário em caso de erro.
     */
    @PostMapping
    public String criarRole(
            @Valid @ModelAttribute RoleForm form,
            BindingResult result,
            RedirectAttributes redirectAttributes,
            Model model) {
        log.info("=== INÍCIO: Processando criação de role ===");
        log.debug("Dados do formulário: nome={}, descricao={}, realmId={}, padrao={}",
                form.getNome(), form.getDescricao(), form.getRealmId(), form.getPadrao());

        if (result.hasErrors()) {
            log.warn("=== AVISO: Erros de validação ao criar role ===");
            log.debug("Erros: {}", result.getAllErrors());

            // Carregar realms novamente para o select
            var realms = realmRepository.findAll();
            model.addAttribute("realms", realms);
            model.addAttribute("editMode", false);
            model.addAttribute("pageTitle", "Nova Role");
            return "admin/roles/create";
        }

        try {
            Role role = adminRoleService.criarRole(form);
            log.info("=== SUCESSO: Role criada: {} ===", role.getNome());
            redirectAttributes.addFlashAttribute("success",
                    "Role \"" + form.getNome() + "\" criada com sucesso!");
            return "redirect:/admin/roles";

        } catch (NomeRoleJaExisteException e) {
            log.error("=== ERRO: Nome de role já existe ===");
            result.rejectValue("nome", null, e.getMessage());

            var realms = realmRepository.findAll();
            model.addAttribute("realms", realms);
            model.addAttribute("editMode", false);
            model.addAttribute("pageTitle", "Nova Role");
            return "admin/roles/create";

        } catch (RealmNotFoundException e) {
            log.error("=== ERRO: Realm não encontrado ===");
            result.rejectValue("realmId", null, e.getMessage());

            var realms = realmRepository.findAll();
            model.addAttribute("realms", realms);
            model.addAttribute("editMode", false);
            model.addAttribute("pageTitle", "Nova Role");
            return "admin/roles/create";

        } catch (Exception e) {
            log.error("=== ERRO: Erro ao criar role ===", e);
            result.reject(null, "Erro ao criar role: " + e.getMessage());

            var realms = realmRepository.findAll();
            model.addAttribute("realms", realms);
            model.addAttribute("editMode", false);
            model.addAttribute("pageTitle", "Nova Role");
            return "admin/roles/create";
        }
    }

    /**
     * Processa a atualização de uma role existente.
     * Lição: Seguir convenção RESTful - PUT para atualização, não POST.
     */
    @PutMapping("/{id}")
    public String atualizarRole(
            @PathVariable String id,
            @Valid @ModelAttribute RoleForm form,
            BindingResult result,
            RedirectAttributes redirectAttributes,
            Model model) {
        log.info("=== INÍCIO: Processando atualização da role: {} ===", id);
        log.debug("Dados do formulário: nome={}, descricao={}, realmId={}, padrao={}",
                form.getNome(), form.getDescricao(), form.getRealmId(), form.getPadrao());

        if (result.hasErrors()) {
            log.warn("=== AVISO: Erros de validação ao atualizar role ===");
            log.debug("Erros: {}", result.getAllErrors());

            var realms = realmRepository.findAll();
            model.addAttribute("realms", realms);
            model.addAttribute("editMode", true);
            model.addAttribute("pageTitle", "Editar Role");
            return "admin/roles/edit";
        }

        try {
            adminRoleService.atualizarRole(id, form);
            log.info("=== SUCESSO: Role atualizada: {} ===", id);
            redirectAttributes.addFlashAttribute("success",
                    "Role \"" + form.getNome() + "\" atualizada com sucesso!");
            return "redirect:/admin/roles";

        } catch (RoleNotFoundException e) {
            log.error("=== ERRO: Role não encontrada ===");
            result.reject(null, e.getMessage());

            var realms = realmRepository.findAll();
            model.addAttribute("realms", realms);
            model.addAttribute("editMode", true);
            model.addAttribute("pageTitle", "Editar Role");
            return "admin/roles/edit";

        } catch (NomeRoleJaExisteException e) {
            log.error("=== ERRO: Nome de role já existe ===");
            result.rejectValue("nome", null, e.getMessage());

            var realms = realmRepository.findAll();
            model.addAttribute("realms", realms);
            model.addAttribute("editMode", true);
            model.addAttribute("pageTitle", "Editar Role");
            return "admin/roles/edit";

        } catch (Exception e) {
            log.error("=== ERRO: Erro ao atualizar role ===", e);
            result.reject(null, "Erro ao atualizar role: " + e.getMessage());

            var realms = realmRepository.findAll();
            model.addAttribute("realms", realms);
            model.addAttribute("editMode", true);
            model.addAttribute("pageTitle", "Editar Role");
            return "admin/roles/edit";
        }
    }

    /**
     * Remove uma role via requisição não-AJAX.
     * Lição: Usar PUT para remoção (soft delete) seguindo padrão RESTful.
     */
    @PutMapping("/{id}/remover")
    public Object removerRole(
            @PathVariable String id,
            RedirectAttributes redirectAttributes,
            jakarta.servlet.http.HttpServletRequest request) {
        log.info("=== INÍCIO: Processando remoção da role: {} ===", id);

        boolean isAjax = isAjaxRequest(request);
        log.debug("É requisição AJAX: {}", isAjax);

        try {
            adminRoleService.removerRole(id);
            log.info("=== SUCESSO: Role removida: {} ===", id);

            if (isAjax) {
                return org.springframework.http.ResponseEntity.ok(java.util.Map.of(
                        "success", true,
                        "message", "Role removida com sucesso!",
                        "roleId", id));
            }

            redirectAttributes.addFlashAttribute("success", "Role removida com sucesso!");
            return "redirect:/admin/roles";

        } catch (RoleNotFoundException e) {
            log.error("=== ERRO: Role não encontrada ===");
            if (isAjax) {
                return org.springframework.http.ResponseEntity.status(org.springframework.http.HttpStatus.NOT_FOUND)
                        .body(java.util.Map.of("success", false, "message", e.getMessage()));
            }
            redirectAttributes.addFlashAttribute("error", e.getMessage());
            return "redirect:/admin/roles";

        } catch (RoleEmUsoException e) {
            log.error("=== ERRO: Role em uso ===");
            if (isAjax) {
                return org.springframework.http.ResponseEntity.status(org.springframework.http.HttpStatus.BAD_REQUEST)
                        .body(java.util.Map.of("success", false, "message", e.getMessage()));
            }
            redirectAttributes.addFlashAttribute("error", e.getMessage());
            return "redirect:/admin/roles";

        } catch (RolePadraoNaoPodeSerRemovidaException e) {
            log.error("=== ERRO: Tentativa de remover role padrão ===");
            if (isAjax) {
                return org.springframework.http.ResponseEntity.status(org.springframework.http.HttpStatus.FORBIDDEN)
                        .body(java.util.Map.of("success", false, "message", e.getMessage()));
            }
            redirectAttributes.addFlashAttribute("error", e.getMessage());
            return "redirect:/admin/roles";

        } catch (Exception e) {
            log.error("=== ERRO: Erro ao remover role ===", e);
            if (isAjax) {
                return org.springframework.http.ResponseEntity
                        .status(org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR)
                        .body(java.util.Map.of("success", false, "message",
                                "Erro ao remover role: " + e.getMessage()));
            }
            redirectAttributes.addFlashAttribute("error", "Erro ao remover role: " + e.getMessage());
            return "redirect:/admin/roles";
        }
    }

    /**
     * Exceções genéricas do controller.
     */
    @ExceptionHandler({ NomeRoleJaExisteException.class,
            RoleNotFoundException.class,
            RoleEmUsoException.class,
            RolePadraoNaoPodeSerRemovidaException.class,
            RealmNotFoundException.class })
    public String handleRoleExceptions(
            Exception exception,
            RedirectAttributes redirectAttributes) {
        log.error("=== ERRO NO CONTROLLER: {} ===", exception.getMessage());
        redirectAttributes.addFlashAttribute("error", exception.getMessage());
        return "redirect:/admin/roles";
    }

    /**
     * Método auxiliar para detectar se a requisição é AJAX.
     */
    private boolean isAjaxRequest(jakarta.servlet.http.HttpServletRequest request) {
        return "XMLHttpRequest".equals(request.getHeader("X-Requested-With")) ||
                request.getHeader("Accept") != null &&
                        request.getHeader("Accept").contains("application/json");
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.controller;

import java.util.List;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.fasterxml.jackson.databind.ObjectMapper;

import br.com.plataforma.conexaodigital.admin.api.dto.forms.UsuarioForm;
import br.com.plataforma.conexaodigital.admin.api.dto.responses.UsuarioDetailViewResponse;
import br.com.plataforma.conexaodigital.admin.api.dto.responses.UsuarioListResponse;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import br.com.plataforma.conexaodigital.role.domain.model.Role;
import br.com.plataforma.conexaodigital.role.domain.repository.RoleRepository;
import br.com.plataforma.conexaodigital.usuario.api.requests.AtualizarUsuarioRequest;
import br.com.plataforma.conexaodigital.usuario.api.requests.CriarUsuarioRequest;
import br.com.plataforma.conexaodigital.usuario.domain.model.enums.StatusUsuario;
import br.com.plataforma.conexaodigital.usuario.domain.service.UsuarioService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.security.oauth2.jwt.JwtClaimsSet;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.JwtEncoderParameters;

import java.time.Instant;
import java.util.List;
import java.util.Map;

/**
 * Controller para gestão de usuários no dashboard administrativo.
 * Implementa CRUD completo com reset de senha e bloqueio/desbloqueio.
 */
@Controller
@RequestMapping("/admin/usuarios")
@RequiredArgsConstructor
@Slf4j
public class AdminUsuarioController {

    private final UsuarioService usuarioService;
    private final RealmRepository realmRepository;
    private final RoleRepository roleRepository;
    private final JwtEncoder jwtEncoder;

    /**
     * API endpoint para listar roles disponíveis por realm.
     * Usado pelo multi-select de roles via AJAX.
     *
     * @param realmId ID do realm
     * @return lista de roles como JSON
     */
    @GetMapping("/api/roles/{realmId}")
    @ResponseBody
    public Object listarRolesPorRealm(@PathVariable UUID realmId) {
        return roleRepository.findAllByRealmId(realmId)
                .stream()
                .map(role -> new Object() {
                    public final String id = role.getId().toString();
                    public final String nome = role.getNome();
                    public final String descricao = role.getDescricao();
                })
                .toList();
    }

    /**
     * Lista usuários com paginação e filtros.
     */
    @GetMapping
    public String listarUsuarios(
            @RequestParam(required = false) String nome,
            @RequestParam(required = false) String email,
            @RequestParam(required = false) UUID realmId,
            @RequestParam(required = false) StatusUsuario status,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "5") int size,
            Model model) {

        log.debug("Listando usuários - nome: {}, email: {}, realmId: {}, status: {}, page: {}",
                nome, email, realmId, status, page);

        Pageable pageable = PageRequest.of(page, size, Sort.by("nome").ascending());
        Page<br.com.plataforma.conexaodigital.usuario.api.responses.UsuarioResponse> apiResponse = usuarioService
                .listar(
                        nome, email, realmId, null, null, status, null, null, null, pageable);

        // Mapear de UsuarioResponse para UsuarioListResponse com iniciais e avatarColor
        Page<UsuarioListResponse> usuarios = apiResponse.map(UsuarioListResponse::fromUsuarioResponse);

        model.addAttribute("usuarios", usuarios);
        model.addAttribute("realms", realmRepository.findAll());
        model.addAttribute("nome", nome);
        model.addAttribute("email", email);
        model.addAttribute("realmId", realmId);
        model.addAttribute("status", status);

        // Adicionar variáveis de paginação como na página de roles
        model.addAttribute("page", usuarios.getNumber());
        model.addAttribute("size", usuarios.getSize());
        model.addAttribute("totalPages", usuarios.getTotalPages());
        model.addAttribute("totalElements", usuarios.getTotalElements());
        model.addAttribute("hasPrevious", usuarios.hasPrevious());
        model.addAttribute("hasNext", usuarios.hasNext());
        model.addAttribute("previousPage", usuarios.hasPrevious() ? usuarios.getNumber() - 1 : 0);
        model.addAttribute("nextPage", usuarios.hasNext() ? usuarios.getNumber() + 1 : usuarios.getNumber());

        return "admin/usuarios/lista";
    }

    /**
     * Exibe formulário para criar novo usuário.
     */
    @GetMapping("/novo")
    public String novoUsuario(Model model) {
        log.debug("Exibindo formulário de novo usuário");

        // Criar form vazio usando setters
        UsuarioForm usuarioForm = new UsuarioForm();
        usuarioForm.setAtivo(true);

        // Incluir role ADMIN por padrão na criação de usuário
        List<String> adminRole = List.of("ADMIN");
        usuarioForm.setRolesIds(adminRole);
        log.debug("Role ADMIN incluída por padrão na criação de usuário");

        model.addAttribute("usuarioForm", usuarioForm);
        model.addAttribute("realms", realmRepository.findAll());
        model.addAttribute("isEdit", false); // Manter false para criação, roles serão pré-selecionadas via form

        // Carregar roles do primeiro realm disponível (ou vazio se não houver)
        List<Role> roles = realmRepository.findAll().stream()
                .findFirst()
                .map(realm -> roleRepository.findAllByRealmId(realm.getId()))
                .orElse(List.of());
        model.addAttribute("roles", roles);

        return "admin/usuarios/form";
    }

    /**
     * Exibe detalhes de um usuário (read-only).
     */
    @GetMapping("/{id}/view")
    public String visualizarUsuario(@PathVariable UUID id, Model model) {
        log.debug("Exibindo detalhes do usuário: {}", id);

        br.com.plataforma.conexaodigital.usuario.api.responses.UsuarioResponse usuarioResponse = usuarioService
                .buscarPorId(id);

        // Buscar ID do Realm Master (primeiro realm com master = true, ou null se não
        // existir)
        String realmMasterId = realmRepository.findAll().stream()
                .filter(r -> r.getMaster() != null && r.getMaster())
                .findFirst()
                .map(r -> r.getId().toString())
                .orElse(null);

        // Mapear para DTO de view com todos os campos necessários
        UsuarioDetailViewResponse usuario = UsuarioDetailViewResponse.fromUsuarioResponse(usuarioResponse,
                realmMasterId);

        model.addAttribute("usuario", usuario);
        model.addAttribute("realms", realmRepository.findAll());

        return "admin/usuarios/detail";
    }

    /**
     * Exibe formulário para editar usuário existente.
     */
    @GetMapping("/{id}/edit")
    public String editarUsuario(@PathVariable UUID id, Model model) {
        log.debug("Exibindo formulário de edição para usuário: {}", id);

        br.com.plataforma.conexaodigital.usuario.api.responses.UsuarioResponse usuario = usuarioService.buscarPorId(id);

        // Criar form com dados do usuário na ordem correta
        UsuarioForm usuarioForm = new UsuarioForm();
        usuarioForm.setId(id.toString());
        usuarioForm.setNome(usuario.nome());
        usuarioForm.setEmail(usuario.email());
        usuarioForm.setCpfOrCnpj(usuario.cpfOrCnpj());
        usuarioForm.setRealmId(usuario.realmId() != null ? usuario.realmId().toString() : null);

        List<String> roleIds = usuario.roleIds() != null
                ? usuario.roleIds().stream().map(UUID::toString).toList()
                : List.of();
        usuarioForm.setRolesIds(roleIds);
        log.debug("Roles do usuário carregadas no form: {}", roleIds);

        usuarioForm.setTenantId(usuario.tenentId());
        usuarioForm.setEmpresaId(usuario.empresaId());
        usuarioForm.setAtivo(usuario.status() == StatusUsuario.ATIVO);

        model.addAttribute("usuarioForm", usuarioForm);
        model.addAttribute("usuarioId", id);
        model.addAttribute("realms", realmRepository.findAll());
        model.addAttribute("isEdit", true);

        // Carregar roles do realm selecionado para preencher o select
        UUID realmId = usuario.realmId();
        if (realmId != null) {
            List<Role> roles = roleRepository.findAllByRealmId(realmId);
            model.addAttribute("roles", roles);
            log.debug("Carregadas {} roles para edição de usuário no realm {}: {}", roles.size(), realmId,
                    roles.stream().map(Role::getId).toList());
        } else {
            model.addAttribute("roles", List.of());
            log.warn("Usuário {} não tem realmId definido, nenhuma role carregada", id);
        }

        return "admin/usuarios/form";
    }

    /**
     * Cria um novo usuário.
     */
    @PostMapping
    public String criarUsuario(@Valid @ModelAttribute UsuarioForm form,
            BindingResult result,
            RedirectAttributes redirectAttributes) {

        log.debug("Criando usuário: {}", form.getEmail());

        if (result.hasErrors()) {
            log.warn("Erros de validação na criação de usuário: {}", result.getAllErrors());
            return "admin/usuarios/form";
        }

        try {
            // Convert List<String> to List<UUID> for roles
            List<UUID> roleUuids = form.getRolesIds() != null
                    ? form.getRolesIds().stream().map(UUID::fromString).toList()
                    : null;

            CriarUsuarioRequest request = new CriarUsuarioRequest(
                    form.getNome(), form.getEmail(), form.getSenha(),
                    form.getRealmId() != null ? UUID.fromString(form.getRealmId()) : null,
                    roleUuids, form.getEmpresaId(), form.getTenantId());

            usuarioService.criar(request);
            log.info("Usuário criado com sucesso: {}", form.getEmail());
            redirectAttributes.addFlashAttribute("success", "Usuário criado com sucesso");
            return "redirect:/admin/usuarios";

        } catch (Exception e) {
            log.error("Erro ao criar usuário", e);
            redirectAttributes.addFlashAttribute("error", "Erro ao criar usuário: " + e.getMessage());
            return "redirect:/admin/usuarios/novo";
        }
    }

    /**
     * Atualiza um usuário existente via formulário HTML (POST).
     */
    @PostMapping("/{id}")
    public String atualizarUsuarioPost(@PathVariable UUID id,
            @Valid @ModelAttribute UsuarioForm form,
            BindingResult result,
            RedirectAttributes redirectAttributes) {

        return atualizarUsuario(id, form, result, redirectAttributes);
    }

    /**
     * Atualiza um usuário existente via REST API (PUT).
     */
    @PutMapping("/{id}")
    public String atualizarUsuarioPut(@PathVariable UUID id,
            @Valid @ModelAttribute UsuarioForm form,
            BindingResult result,
            RedirectAttributes redirectAttributes) {

        return atualizarUsuario(id, form, result, redirectAttributes);
    }

    /**
     * Lógica compartilhada de atualização de usuário.
     */
    private String atualizarUsuario(UUID id,
            UsuarioForm form,
            BindingResult result,
            RedirectAttributes redirectAttributes) {

        log.debug("Atualizando usuário {}: {}", id, form.getEmail());
        log.debug("Roles recebidas do form: {}", form.getRolesIds());

        if (result.hasErrors()) {
            log.warn("Erros de validação na atualização de usuário: {}", result.getAllErrors());
            return "admin/usuarios/form";
        }

        try {
            // Convert List<String> to List<UUID> for roles
            List<UUID> roleUuids = form.getRolesIds() != null
                    ? form.getRolesIds().stream().map(UUID::fromString).toList()
                    : null;

            log.debug("Roles convertidas para UUID: {}", roleUuids);

            AtualizarUsuarioRequest request = new AtualizarUsuarioRequest(
                    form.getNome(), form.getEmail(), roleUuids, form.getEmpresaId(), form.getTenantId(),
                    form.getCpfOrCnpj());

            usuarioService.atualizar(id, request);
            log.info("Usuário atualizado com sucesso: {}", id);
            log.info("Roles atualizadas: {}", roleUuids);
            redirectAttributes.addFlashAttribute("success", "Usuário atualizado com sucesso");
            return "redirect:/admin/usuarios";

        } catch (Exception e) {
            log.error("Erro ao atualizar usuário", e);
            redirectAttributes.addFlashAttribute("error", "Erro ao atualizar usuário: " + e.getMessage());
            return "redirect:/admin/usuarios/" + id + "/edit";
        }
    }

    /**
     * Bloqueia um usuário.
     */
    @PostMapping("/{id}/bloquear")
    public String bloquearUsuario(@PathVariable UUID id, RedirectAttributes redirectAttributes) {
        log.info("=== INÍCIO: Bloqueando usuário {} ===", id);
        log.debug("Recebida requisição para bloquear usuário: {}", id);

        try {
            log.debug("Chamando serviço de bloqueio para usuário: {}", id);
            usuarioService.bloquear(id);
            log.info("Usuário bloqueado com sucesso: {}", id);
            redirectAttributes.addFlashAttribute("success", "Usuário bloqueado com sucesso");
            log.info("=== FIM: Bloqueio do usuário {} concluído com sucesso ===", id);
        } catch (Exception e) {
            log.error("=== ERRO: Falha ao bloquear usuário {} ===", id, e);
            log.error("Mensagem de erro: {}", e.getMessage());
            log.error("Tipo do erro: {}", e.getClass().getSimpleName());
            redirectAttributes.addFlashAttribute("error", "Erro ao bloquear usuário: " + e.getMessage());
        }

        return "redirect:/admin/usuarios";
    }

    /**
     * 
     * 
     * @PostMapping("/{id}/desbloquear")
     * public String desbloquearUsuario(@PathVariable UUID id, RedirectAttributes
     * redirectAttributes) {
     * log.debug("Desbloqueando usuário: {}", id);
     * 
     * try {
     * usuarioService.desbloquear(id);
     * log.info("Usuário desbloqueado com sucesso: {}", id);
     * redirectAttributes.addFlashAttribute("success", "Usuário desbloqueado com
     * sucesso");
     * } catch (Exception e) {
     * log.error("Erro ao desbloquear usuário", e);
     * redirectAttributes.addFlashAttribute("error", "Erro ao desbloquear usuário: "
     * + e.getMessage());
     * }
     * 
     * return "redirect:/admin/usuarios";
     * }
     * 
     * /**
     * Ativa um usuário (alias para desbloquear).
     * Semanticamente equivalente a desbloquear.
     */
    @PostMapping("/{id}/ativar")
    public String ativarUsuario(@PathVariable UUID id, RedirectAttributes redirectAttributes) {
        log.debug("Ativando usuário: {}", id);

        try {
            usuarioService.desbloquear(id);
            log.info("Usuário ativado com sucesso: {}", id);
            redirectAttributes.addFlashAttribute("success", "Usuário ativado com sucesso");
        } catch (Exception e) {
            log.error("Erro ao ativar usuário", e);
            redirectAttributes.addFlashAttribute("error", "Erro ao ativar usuário: " + e.getMessage());
        }

        return "redirect:/admin/usuarios";
    }

    /**
     * Exibe formulário para reset de senha.
     */
    @GetMapping("/{id}/reset-senha")
    public String formResetSenha(@PathVariable UUID id, Model model) {
        log.debug("Exibindo formulário de reset de senha para usuário: {}", id);

        br.com.plataforma.conexaodigital.usuario.api.responses.UsuarioResponse usuario = usuarioService.buscarPorId(id);
        model.addAttribute("usuario", usuario);
        model.addAttribute("usuarioId", id);

        return "admin/usuarios/reset-senha";
    }

    /**
     * Reseta a senha de um usuário via formulário administrativo.
     * Usa @RequestParam para evitar conflito de mapeamento.
     */
    @PostMapping("/{id}/reset-senha")
    public String processarResetSenhaAdmin(
            @PathVariable UUID id,
            RedirectAttributes redirectAttributes) {
        log.debug("Processando solicitação de recuperação de senha para usuário: {}", id);

        try {
            // Buscar usuário para obter email
            var usuarioResponse = usuarioService.buscarPorId(id);
            if (usuarioResponse == null || usuarioResponse.email() == null || usuarioResponse.email().isBlank()) {
                redirectAttributes.addFlashAttribute("error",
                        "Usuário não possui email válido para recuperação de senha");
                return "redirect:/admin/usuarios/" + id + "/reset-senha";
            }

            // Chamar serviço de solicitação de recuperação de senha
            var request = new br.com.plataforma.conexaodigital.usuario.api.requests.SolicitarRecuperacaoSenhaRequest(
                    usuarioResponse.email());
            var response = usuarioService.solicitarRecuperacaoSenha(request);

            log.info("Código de recuperação enviado com sucesso para usuário: {}", id);
            redirectAttributes.addFlashAttribute("success", "Código de recuperação enviado para o email do usuário");
            return "redirect:/admin/usuarios";
        } catch (Exception e) {
            log.error("Erro ao solicitar recuperação de senha", e);
            redirectAttributes.addFlashAttribute("error", "Erro ao solicitar recuperação de senha: " + e.getMessage());
            return "redirect:/admin/usuarios/" + id + "/reset-senha";
        }
    }

    /**
     * Endpoint para gerar token de teste para um usuário.
     * Simula a geração de um token JWT para fins de teste no dashboard administrativo.
     *
     * @param id ID do usuário
     * @return JSON com tokens simulados (access_token, refresh_token, token_type, expires_in)
     */
    @GetMapping("/{id}/teste-token")
    @ResponseBody
    public Object gerarTokenTeste(@PathVariable UUID id) {
        log.debug("Gerando token de teste para usuário: {}", id);

        try {
            // Verificar se usuário existe
            br.com.plataforma.conexaodigital.usuario.api.responses.UsuarioResponse usuario = usuarioService.buscarPorId(id);
            if (usuario == null) {
                return Map.of("error", "Usuário não encontrado");
            }

            // Log dos valores do usuário para debug
            log.debug("Gerando JWT para usuário: id={}, nome={}, email={}, empresaId={}, tenantId={}, roles={}",
                usuario.id(), usuario.nome(), usuario.email(), usuario.empresaId(), usuario.tenentId(), usuario.roleIds());

            // Gerar JWT real com claims do usuário
            Instant now = Instant.now();
            JwtClaimsSet.Builder claimsBuilder = JwtClaimsSet.builder()
                .issuer("conexaoauth-bmad")
                .subject(usuario.id().toString())
                .audience(List.of("conexaoauth-api"))
                .issuedAt(now)
                .expiresAt(now.plusSeconds(3600)) // 1 hora
                .claim("realm", usuario.realmNome())
                .claim("user_id", usuario.id().toString())
                .claim("user_email", usuario.email())
                .claim("user_name", usuario.nome())
                .claim("scope", "read write");

            // Adicionar claims opcionais apenas se não forem nulos
            if (usuario.empresaId() != null && !usuario.empresaId().isEmpty()) {
                claimsBuilder.claim("empresa_id", usuario.empresaId());
            }
            if (usuario.tenentId() != null && !usuario.tenentId().isEmpty()) {
                claimsBuilder.claim("tenant_id", usuario.tenentId());
            }
            if (usuario.roleIds() != null && !usuario.roleIds().isEmpty()) {
                claimsBuilder.claim("roles", usuario.roleIds());
            }

            JwtClaimsSet claims = claimsBuilder.build();

            String accessToken = jwtEncoder.encode(JwtEncoderParameters.from(claims)).getTokenValue();

            return Map.of(
                "access_token", accessToken,
                "refresh_token", "refresh_token_simulado_" + id + "_" + System.currentTimeMillis(),
                "token_type", "Bearer",
                "expires_in", 3600,
                "scope", "read write",
                "realm", usuario.realmNome(),
                "user_id", usuario.id().toString(),
                "user_email", usuario.email()
            );

        } catch (Exception e) {
            log.error("Erro ao gerar token de teste para usuário {}", id, e);
            return Map.of("error", "Erro interno ao gerar token: " + e.getMessage());
        }
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.dto;

import jakarta.validation.constraints.AssertTrue;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

/**
 * DTO para formulário de cadastro de usuário.
 * Contém validações para nome, email, senha e confirmação de senha.
 */
public record CadastroForm(
    @NotBlank(message = "Nome é obrigatório")
    @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres")
    String nome,

    @NotBlank(message = "Email é obrigatório")
    @Email(message = "Email inválido")
    String email,

    @NotBlank(message = "Senha é obrigatória")
    @Size(min = 8, message = "Senha deve ter no mínimo 8 caracteres")
    String senha,

    @NotBlank(message = "Confirmação de senha é obrigatória")
    String confirmarSenha
) {
    @AssertTrue(message = "Senhas não conferem")
    public boolean isSenhasConferem() {
        return senha != null && senha.equals(confirmarSenha);
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.dto;

import java.util.List;

/**
 * DTO para resposta do Dashboard.
 * Contém métricas totais, dados de gráficos e eventos recentes.
 */
public record DashboardResponse(
        Long totalRealms,
        Long totalUsuarios,
        Long totalRoles,
        Long totalChavesAtivas,
        List<String> labelsUsuariosPorRealm,
        List<Long> dadosUsuariosPorRealm,
        List<Long> dadosUsuariosPorStatus,
        List<EventoAuditoriaItem> eventosRecentes) {
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.dto;

import java.time.LocalDateTime;

/**
 * DTO simplificado para item de evento de auditoria no dashboard.
 */
public record EventoAuditoriaItem(
        LocalDateTime dataCriacao,
        String tipo,
        String descricao
) {}

```
```java
package br.com.plataforma.conexaodigital.admin.api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

/**
 * DTO para formulário de login.
 * Contém email e senha para autenticação.
 */
public record LoginForm(
    @NotBlank(message = "Email é obrigatório")
    @Email(message = "Email inválido")
    String email,

    @NotBlank(message = "Senha é obrigatória")
    String senha,

    Boolean rememberMe
) {}

```
```java
package br.com.plataforma.conexaodigital.admin.api.dto.forms;

import br.com.plataforma.conexaodigital.realm.domain.model.StatusRealm;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Form DTO para criação e edição de realms.
 * Usado nos formulários Thymeleaf do dashboard administrativo.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RealmForm {

    private String id;

    @NotBlank(message = "{realm.nome.obrigatorio}")
    @Size(min = 3, max = 100, message = "{realm.nome.tamanho}")
    @Pattern(regexp = "^[a-z][a-z0-9_-]*$", message = "{realm.nome.formato}")
    private String nome;

    @Size(max = 500, message = "{realm.descricao.tamanho}")
    private String descricao;

    @NotNull(message = "{realm.status.obrigatorio}")
    private Boolean ativo;

    @Size(max = 100, message = "{realm.empresaid.tamanho}")
    private String empresaId;

    @Size(max = 100, message = "{realm.tenantid.tamanho}")
    private String tenantId;

    public boolean isEdit() {
        return id != null && !id.isBlank();
    }

    public StatusRealm getStatus() {
        return ativo != null && ativo ? StatusRealm.ATIVO : StatusRealm.INATIVO;
    }
}
```
```java
package br.com.plataforma.conexaodigital.admin.api.dto.forms;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO para formulário de validação de reset de senha.
 * Usado quando o usuário insere o código de 6 dígitos recebido por e-mail
 * e define sua nova senha.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ResetPasswordForm {

    @NotBlank(message = "{reset.usuario.id.obrigatorio}")
    private String usuarioId;

    @NotBlank(message = "{reset.codigo.obrigatorio}")
    @Pattern(regexp = "^\\d{6}$", message = "{reset.codigo.formato}")
    private String codigo;

    @NotBlank(message = "{reset.nova.senha.obrigatoria}")
    @Size(min = 6, max = 100, message = "{reset.nova.senha.tamanho}")
    private String novaSenha;

    @NotBlank(message = "{reset.confirmar.senha.obrigatoria}")
    private String confirmarSenha;

    /**
     * Valida se as senhas conferem.
     *
     * @return true se as senhas forem iguais, false caso contrário
     */
    public boolean isSenhasConferem() {
        if (novaSenha == null || confirmarSenha == null) {
            return false;
        }
        return novaSenha.equals(confirmarSenha);
    }

    /**
     * Valida se a senha atende os requisitos de complexidade mínima.
     * Requisitos:
     * - Mínimo de 6 caracteres
     * - Pelo menos 1 letra maiúscula
     * - Pelo menos 1 letra minúscula
     * - Pelo menos 1 número
     * - Pelo menos 1 caractere especial
     *
     * @return true se a senha atender os requisitos, false caso contrário
     */
    public boolean isSenhaValida() {
        if (novaSenha == null || novaSenha.length() < 6) {
            return false;
        }

        boolean temMaiuscula = false;
        boolean temMinuscula = false;
        boolean temNumero = false;
        boolean temEspecial = false;

        for (char c : novaSenha.toCharArray()) {
            if (Character.isUpperCase(c)) {
                temMaiuscula = true;
            } else if (Character.isLowerCase(c)) {
                temMinuscula = true;
            } else if (Character.isDigit(c)) {
                temNumero = true;
            } else {
                temEspecial = true;
            }
        }

        return temMaiuscula || temMinuscula || temNumero || temEspecial;
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.dto.forms;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RoleForm {

    private String id;

    @NotBlank(message = "{role.nome.obrigatorio}")
    @Size(min = 3, max = 50, message = "{role.nome.tamanho}")
    @Pattern(regexp = "^[A-Z_]+$", message = "{role.nome.formato}")
    private String nome;

    @Size(max = 500, message = "{role.descricao.tamanho}")
    private String descricao;

    @NotNull(message = "{role.realm.obrigatorio}")
    private String realmId;

    private Boolean padrao;

    public boolean isEdit() {
        return id != null && !id.isBlank();
    }

    public boolean isRolePadrao() {
        return "ADMIN".equals(nome) || "USER".equals(nome) || "SERVICE".equals(nome);
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.dto.forms;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

/**
 * DTO para formulário de criação/edição de usuário.
 * Contém validações Jakarta Bean Validation.
 * Classe mutável para permitir form binding do Thymeleaf.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UsuarioForm {

    private String id;

    @NotBlank(message = "{usuario.nome.obrigatorio}")
    @Size(min = 3, max = 100, message = "{usuario.nome.tamanho}")
    private String nome;

    @NotBlank(message = "{usuario.email.obrigatorio}")
    @Email(message = "{usuario.email.invalido}")
    @Size(max = 255, message = "{usuario.email.tamanho}")
    private String email;

    @Pattern(regexp = "^\\d{11}$|^\\d{14}$|^[0-9]*$", message = "{usuario.cpfcnpj.formato}")  // ALTERADO: CPF (11 dígitos) ou CNPJ (14 dígitos)
    private String cpfOrCnpj;  // ALTERADO: cpf → cpfOrCnpj para suportar ambos

    private String senha;

    @NotNull(message = "{usuario.realm.obrigatorio}")
    private String realmId;

    private List<String> rolesIds;

    private String tenantId;

    private String empresaId;

    private Boolean ativo = true;

    /**
     * Retorna true se este form está em modo de edição.
     */
    public boolean isEdit() {
        return id != null && !id.isBlank();
    }

    /**
     * Valida se o CPF/CNPJ está preenchido corretamente.
     * CPF: exatamente 11 dígitos numéricos
     * CNPJ: exatamente 14 dígitos numéricos
     * Campo é opcional, mas se preenchido deve ter tamanho correto.
     */
    public boolean isCpfCnpjValido() {
        if (cpfOrCnpj == null || cpfOrCnpj.isBlank()) {
            return true; // Campo opcional
        }

        // Se preenchido, deve ter 11 (CPF) ou 14 (CNPJ) dígitos numéricos
        return cpfOrCnpj.matches("^\\d{11}$") || cpfOrCnpj.matches("^\\d{14}$");
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.dto.responses;

import java.time.LocalDateTime;
import java.util.List;

/**
 * DTO para resposta detalhada de um realm.
 * Contém todos os campos da entidade mais informações relacionadas.
 */
public record RealmDetailResponse(
    String id,
    String nome,
    String descricao,
    Boolean ativo,
    Boolean master,
    String empresaId,
    String tenantId,
    Long totalUsuarios,
    Long usuariosAtivos,
    Long usuariosBloqueados,
    Long chavesAtivas,
    Long chavesInativas,
    Long totalRoles,
    List<String> roles,
    LocalDateTime dataCriacao,
    LocalDateTime dataAtualizacao,
    LocalDateTime dataDesativacao,
    LocalDateTime dataReativacao
) {
    /**
     * Método estático de fábrica para criar instância a partir da entidade.
     */
    public static RealmDetailResponse from(
        br.com.plataforma.conexaodigital.realm.domain.model.Realm realm,
        Long totalUsuarios,
        Long usuariosAtivos,
        Long usuariosBloqueados,
        Long chavesAtivas,
        Long chavesInativas,
        Long totalRoles,
        List<String> roles
    ) {
        return new RealmDetailResponse(
            realm.getId() != null ? realm.getId().toString() : null,
            realm.getNome(),
            realm.getDescricao(),
            realm.isAtivo(),
            realm.getMaster(),
            realm.getEmpresaId(),
            realm.getTenantId(),
            totalUsuarios,
            usuariosAtivos,
            usuariosBloqueados,
            chavesAtivas,
            chavesInativas,
            totalRoles,
            roles,
            realm.getDataCriacao(),
            realm.getDataAtualizacao(),
            realm.getDataDesativacao(),
            realm.getDataReativacao()
        );
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.dto.responses;

import java.time.LocalDateTime;

/**
 * DTO para resposta de listagem de realms na página administrativa.
 * Contém os campos essenciais para exibição na tabela.
 */
public record RealmListResponse(
    String id,
    String nome,
    String descricao,
    Boolean ativo,
    Boolean master,
    Long totalUsuarios,
    Long chavesAtivas,
    Long totalRoles,
    LocalDateTime dataCriacao,
    LocalDateTime dataAtualizacao
) {
    /**
     * Método estático de fábrica para criar instância a partir da entidade.
     * @param realm entidade Realm
     * @param totalUsuarios total de usuários no realm
     * @param chavesAtivas total de chaves ativas no realm
     * @param totalRoles total de roles no realm
     * @return instância de RealmListResponse
     */
    public static RealmListResponse from(
        br.com.plataforma.conexaodigital.realm.domain.model.Realm realm,
        Long totalUsuarios,
        Long chavesAtivas,
        Long totalRoles
    ) {
        return new RealmListResponse(
            realm.getId() != null ? realm.getId().toString() : null,
            realm.getNome(),
            realm.getDescricao(),
            realm.isAtivo(),
            realm.getMaster(),
            totalUsuarios,
            chavesAtivas,
            totalRoles,
            realm.getDataCriacao(),
            realm.getDataAtualizacao()
        );
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.dto.responses;

import java.time.LocalDateTime;
import java.util.List;

/**
 * DTO para resposta detalhada de uma role.
 * Contém todos os campos da entidade mais informações relacionadas.
 */
public record RoleDetailResponse(
    String id,
    String nome,
    String descricao,
    String realmNome,
    String realmId,
    Boolean padrao,
    Long totalUsuarios,
    List<String> usuariosNomes, // lista de usuários que possuem esta role
    LocalDateTime dataCriacao,
    LocalDateTime dataAtualizacao
) {
    /**
     * Método estático de fábrica para criar instância a partir da entidade.
     */
    public static RoleDetailResponse from(
        br.com.plataforma.conexaodigital.role.domain.model.Role role,
        String realmNome,
        String realmId,
        Long totalUsuarios,
        List<String> usuariosNomes
    ) {
        boolean isPadrao = role.getNome().equals("ADMIN") ||
                          role.getNome().equals("USER") ||
                          role.getNome().equals("SERVICE");
        
        return new RoleDetailResponse(
            role.getId().toString(),
            role.getNome(),
            role.getDescricao(),
            realmNome,
            realmId,
            isPadrao,
            totalUsuarios,
            usuariosNomes,
            role.getDataCriacao(),
            role.getDataAtualizacao()
        );
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.dto.responses;

import java.time.LocalDateTime;

/**
 * DTO para resposta de listagem de roles na página administrativa.
 * Contém os campos essenciais para exibição na tabela.
 */
public record RoleListResponse(
    String id,
    String nome,
    String descricao,
    String realmNome,
    String realmId,
    Boolean padrao, // se é role padrão (ADMIN, USER, SERVICE)
    Long totalUsuarios,
    LocalDateTime dataCriacao
) {
    /**
     * Método estático de fábrica para criar instância a partir da entidade.
     * @param role entidade Role
     * @param realmNome nome do realm da role
     * @param realmId ID do realm da role
     * @param totalUsuarios quantidade de usuários com esta role
     * @return instância de RoleListResponse
     */
    public static RoleListResponse from(
        br.com.plataforma.conexaodigital.role.domain.model.Role role,
        String realmNome,
        String realmId,
        Long totalUsuarios
    ) {
        boolean isPadrao = role.getNome().equals("ADMIN") ||
                          role.getNome().equals("USER") ||
                          role.getNome().equals("SERVICE");
        
        return new RoleListResponse(
            role.getId().toString(),
            role.getNome(),
            role.getDescricao(),
            realmNome,
            realmId,
            isPadrao,
            totalUsuarios,
            role.getDataCriacao()
        );
    }
    
    /**
     * Verifica se a role pode ser removida.
     * Roles padrão e roles com usuários não podem ser removidas.
     */
    public boolean podeRemover() {
        return !padrao && totalUsuarios == 0;
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.dto.responses;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

import br.com.plataforma.conexaodigital.usuario.domain.model.Usuario;

/**
 * DTO para resposta detalhada de um usuário.
 * Contém todos os campos da entidade e informações relacionadas.
 */
public record UsuarioDetailResponse(
    String id,
    String nome,
    String email,
    String realmId,
    String empresaId,
    String tenantId,
    String status,
    LocalDateTime dataCriacao,
    LocalDateTime dataUltimoLogin,
    LocalDateTime dataAtualizacao
) {
    /**
     * Método estático de fábrica para criar instância a partir da entidade.
     */
    public static UsuarioDetailResponse from(Usuario usuario) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");

        return new UsuarioDetailResponse(
            usuario.getId().toString(),
            usuario.getNome(),
            usuario.getEmail(),
            usuario.getRealmId() != null ? usuario.getRealmId().toString() : null,
            usuario.getEmpresaId(),
            usuario.getTenantId(),
            usuario.getStatus().toString(),
            usuario.getDataCriacao(),
            usuario.getDataUltimoLogin(),
            usuario.getDataAtualizacao()
        );
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.dto.responses;

import java.time.LocalDateTime;
import java.util.List;

/**
 * DTO para resposta detalhada de um usuário na página administrativa.
 * Contém todos os campos necessários para o template detail.html.
 */
public record UsuarioDetailViewResponse(
        String id,
        String nome,
        String email,
        String cpfOrCnpj, // ALTERADO: cpf → cpfOrCnpj para suportar ambos
        String realmId,
        String realmNome,
        String empresaId,
        String tenantId,
        String status,
        LocalDateTime dataCriacao,
        LocalDateTime dataUltimoLogin,
        LocalDateTime dataUltimaAtualizacao,
        LocalDateTime dataBloqueio,
        String motivoBloqueio,
        List<String> roles,
        String iniciais,
        String avatarColor,
        Boolean adminMaster) {
    /**
     * Gera as iniciais do usuário para o avatar.
     */
    private static String generateIniciais(String nome) {
        if (nome == null || nome.isBlank()) {
            return "U";
        }

        String[] partes = nome.trim().split("\\s+");
        if (partes.length >= 2) {
            return (partes[0].charAt(0) + "" + partes[1].charAt(0)).toUpperCase();
        } else if (partes.length == 1) {
            return partes[0].substring(0, Math.min(2, partes[0].length())).toUpperCase();
        }

        return "U";
    }

    /**
     * Gera uma cor baseada no nome do usuário (determinística).
     */
    private static String generateAvatarColor(String nome) {
        if (nome == null || nome.isBlank()) {
            return "bg-secondary";
        }

        // Hash simples do nome
        int hash = nome.hashCode();
        int index = Math.abs(hash) % 10;

        // Cores disponíveis (Bootstrap colors)
        String[] colors = {
                "bg-primary", "bg-success", "bg-info", "bg-warning",
                "bg-danger", "bg-secondary", "bg-dark", "bg-purple",
                "bg-pink", "bg-teal"
        };

        return colors[index];
    }

    /**
     * Método estático de fábrica para criar instância a partir de UsuarioResponse.
     * 
     * @param usuarioResponse UsuarioResponse da API
     * @param realmMasterId   ID do Realm Master (para identificar admin master)
     * @return instância de UsuarioDetailViewResponse
     */
    public static UsuarioDetailViewResponse fromUsuarioResponse(
            br.com.plataforma.conexaodigital.usuario.api.responses.UsuarioResponse usuarioResponse,
            String realmMasterId) {
        // Gerar iniciais e cor do avatar
        String iniciais = generateIniciais(usuarioResponse.nome());
        String avatarColor = generateAvatarColor(usuarioResponse.nome());

        // Verificar se é admin master (tem role ADMIN e está no realm master)
        boolean isAdminMaster = usuarioResponse.realmId() != null
                && usuarioResponse.realmId().toString().equals(realmMasterId)
                && usuarioResponse.roleNomes() != null
                && usuarioResponse.roleNomes().contains("ADMIN");

        return new UsuarioDetailViewResponse(
                usuarioResponse.id().toString(),
                usuarioResponse.nome(),
                usuarioResponse.email(),
                usuarioResponse.cpfOrCnpj(), // ALTERADO: cpfOrCnpj
                usuarioResponse.realmId() != null ? usuarioResponse.realmId().toString() : null,
                usuarioResponse.realmNome(),
                usuarioResponse.empresaId(), // ADICIONADO: empresaId
                usuarioResponse.tenantId(), // ADICIONADO: tenantId (deprecated mas usado pelo getter)
                usuarioResponse.status().name(),
                usuarioResponse.dataCriacao(),
                usuarioResponse.dataUltimoLogin(),
                usuarioResponse.dataAtualizacao(),
                null, // dataBloqueio - não disponível no UsuarioResponse
                null, // motivoBloqueio - não disponível no UsuarioResponse
                usuarioResponse.roleNomes() != null ? usuarioResponse.roleNomes() : List.of(),
                iniciais,
                avatarColor,
                isAdminMaster);
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.dto.responses;

import java.time.LocalDateTime;
import java.util.List;

/**
 * DTO para resposta de listagem de usuários na página administrativa.
 * Contém os campos essenciais para exibição na tabela.
 */
public record UsuarioListResponse(
    String id,
    String nome,
    String email,
    String realmNome,
    String realmId,
    List<String> roles,
    String status,
    String iniciais, // iniciais para avatar
    String avatarColor, // cor do avatar (gerada aleatoriamente)
    LocalDateTime dataCriacao,
    LocalDateTime dataUltimaAtualizacao
) {
    /**
     * Gera as iniciais do usuário para o avatar.
     */
    private static String generateIniciais(String nome) {
        if (nome == null || nome.isBlank()) {
            return "U";
        }

        String[] partes = nome.trim().split("\\s+");
        if (partes.length >= 2) {
            return (partes[0].charAt(0) + "" + partes[1].charAt(0)).toUpperCase();
        } else if (partes.length == 1) {
            return partes[0].substring(0, Math.min(2, partes[0].length())).toUpperCase();
        }

        return "U";
    }

    /**
     * Gera uma cor baseada no nome do usuário (determinística).
     */
    private static String generateAvatarColor(String nome) {
        if (nome == null || nome.isBlank()) {
            return "bg-secondary";
        }

        int hash = nome.hashCode();
        int index = Math.abs(hash) % 10;

        String[] colors = {
            "bg-primary", "bg-success", "bg-info", "bg-warning",
            "bg-danger", "bg-secondary", "bg-dark", "bg-purple",
            "bg-pink", "bg-teal"
        };

        return colors[index];
    }

    /**
     * Método estático de fábrica para criar instância a partir da entidade.
     */
    public static UsuarioListResponse from(
        br.com.plataforma.conexaodigital.usuario.domain.model.Usuario usuario,
        String realmNome,
        String realmId,
        List<String> roles
    ) {
        String iniciais = generateIniciais(usuario.getNome());
        String avatarColor = generateAvatarColor(usuario.getNome());

        return new UsuarioListResponse(
            usuario.getId().toString(),
            usuario.getNome(),
            usuario.getEmail(),
            realmNome,
            realmId,
            roles,
            usuario.getStatus().name(),
            iniciais,
            avatarColor,
            usuario.getDataCriacao(),
            usuario.getDataAtualizacao()
        );
    }

    /**
     * Método estático de fábrica para criar instância a partir de UsuarioResponse.
     * Usado para mapear resposta da API para a página administrativa.
     */
    public static UsuarioListResponse fromUsuarioResponse(
        br.com.plataforma.conexaodigital.usuario.api.responses.UsuarioResponse usuarioResponse
    ) {
        String iniciais = generateIniciais(usuarioResponse.nome());
        String avatarColor = generateAvatarColor(usuarioResponse.nome());

        return new UsuarioListResponse(
            usuarioResponse.id().toString(),
            usuarioResponse.nome(),
            usuarioResponse.email(),
            usuarioResponse.realmNome(),
            usuarioResponse.realmId() != null ? usuarioResponse.realmId().toString() : null,
            usuarioResponse.roleNomes(),
            usuarioResponse.status().name(),
            iniciais,
            avatarColor,
            usuarioResponse.dataCriacao(),
            usuarioResponse.dataAtualizacao()
        );
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.mapper;

import br.com.plataforma.conexaodigital.admin.api.dto.forms.RoleForm;
import br.com.plataforma.conexaodigital.role.domain.model.Role;

public class RoleMapper {

    public static Role toEntity(RoleForm form) {
        return Role.builder()
                .nome(form.getNome() != null ? form.getNome().toUpperCase() : null)
                .descricao(form.getDescricao())
                .padrao(form.getPadrao() != null && form.getPadrao())
                .build();
    }

    public static RoleForm toForm(Role role) {
        return RoleForm.builder()
                .id(role.getId() != null ? role.getId().toString() : null)
                .nome(role.getNome())
                .descricao(role.getDescricao())
                .realmId(role.getRealm() != null ? role.getRealm().getId().toString() : null)
                .padrao(role.isPadrao())
                .build();
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.requests;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

/**
 * DTO para formulário de login.
 * Contém validações Jakarta Bean Validation para autenticação.
 * TODO: Adicionar suporte a CPF quando campo for adicionado na entidade Usuario.
 */
public record LoginForm(

    /**
     * Email do usuário.
     * Deve ser um email válido.
     * TODO: Futuramente aceitará CPF também.
     */
    @NotBlank(message = "{validation.login.username.required}")
    @Size(min = 3, max = 150, message = "{validation.login.username.size}")
    @Email(message = "{validation.login.username.format}")
    String username,

    /**
     * Senha do usuário.
     * Deve ter pelo menos 6 caracteres e conter letras e números.
     */
    @NotBlank(message = "{validation.login.password.required}")
    @Size(min = 6, max = 100, message = "{validation.login.password.size}")
    @Pattern(
        regexp = "^(?=.*[a-zA-Z])(?=.*\\d).+$",
        message = "{validation.login.password.format}"
    )
    String password,

    /**
     * Checkbox "Lembrar-me" para manter a sessão ativa por 7 dias.
     */
    boolean rememberMe
) {
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.requests;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

/**
 * DTO para formulário de criação/edição de role.
 * Contém validações Jakarta Bean Validation.
 */
public record RoleForm(
    String id,

    @NotBlank(message = "{role.nome.obrigatorio}")
    @Size(min = 3, max = 50, message = "{role.nome.tamanho}")
    @Pattern(regexp = "^[A-Z_]+$", message = "{role.nome.formato}")
    String nome,

    @Size(max = 500, message = "{role.descricao.tamanho}")
    String descricao,

    @NotNull(message = "{role.realm.obrigatorio}")
    String realmId,

    @NotNull(message = "{role.ativa.obrigatorio}")
    Boolean ativa,

    Boolean padrao
) {
    /**
     * Cria instância vazia para nova role.
     */
    public RoleForm() {
        this(
                null,
                null,
                null,
                null,
                true, // padrão: ativa
                false // padrão: não é padrão
        );
    }

    /**
     * Retorna true se este form está em modo de edição.
     */
    public boolean isEdit() {
        return id != null && !id.isBlank();
    }

    /**
     * Retorna true se esta role é uma role padrão.
     */
    public boolean isRolePadrao() {
        return "ADMIN".equals(nome) || "USER".equals(nome) || "SERVICE".equals(nome);
    }
}
```
```java
package br.com.plataforma.conexaodigital.admin.api.responses;

import java.time.LocalDateTime;
import java.util.UUID;

import br.com.plataforma.conexaodigital.chave.domain.model.StatusChave;

/**
 * DTO para resposta de chave ativa na listagem.
 */
public record ChaveAtivaResponse(
    UUID id,
    UUID realmId,
    String realmNome,
    String kid,
    String tipoChave,
    LocalDateTime dataCriacao,
    LocalDateTime dataExpiracao,
    StatusChave status,
    Integer diasRestantes
) {
    public String getBadgeDiasRestantes() {
        return diasRestantes != null ? getBadgeClass(diasRestantes) : "";
    }

    public String getStatusDescricao() {
        return status != null ? status.getDescricao() : "-";
    }

    private String getBadgeClass(Integer dias) {
        if (dias == null) return "bg-secondary-subtle text-secondary";
        if (dias < 0) return "bg-success-subtle text-success"; // expirada mas ainda válida no grace period
        if (dias <= 7) return "bg-danger-subtle text-danger";
        if (dias <= 30) return "bg-warning-subtle text-warning";
        return "bg-info-subtle text-info";
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.responses;

import java.time.LocalDateTime;
import java.util.List;

/**
 * DTO para resposta detalhada de uma role.
 * Contém todos os campos da entidade mais informações relacionadas.
 */
public record RoleDetailResponse(
    String id,
    String nome,
    String descricao,
    String realmNome,
    String realmId,
    Boolean padrao,
    Boolean ativa,
    Long totalUsuarios,
    List<String> usuariosNomes, // lista de usuários que possuem esta role
    LocalDateTime dataCriacao,
    LocalDateTime dataUltimaAtualizacao
) {
    /**
     * Método estático de fábrica para criar instância a partir da entidade.
     */
    public static RoleDetailResponse from(
        br.com.plataforma.conexaodigital.role.domain.model.Role role,
        String realmNome,
        String realmId,
        Long totalUsuarios,
        List<String> usuariosNomes
    ) {
        boolean isPadrao = role.getNome().equals("ADMIN") ||
                          role.getNome().equals("USER") ||
                          role.getNome().equals("SERVICE");

        return new RoleDetailResponse(
            role.getId().toString(),
            role.getNome(),
            role.getDescricao(),
            realmNome,
            realmId,
            isPadrao,
            role.ePadrao(), // Usar método correto
            totalUsuarios,
            usuariosNomes,
            role.getDataCriacao(),
            role.getDataAtualizacao()
        );
    }

    /**
     * Retorna a classe CSS para o badge de status.
     */
    public String getStatusBadgeClass() {
        return ativa ? "bg-success-subtle text-success" : "bg-danger-subtle text-danger";
    }

    /**
     * Retorna o texto do status.
     */
    public String getStatusText() {
        return ativa ? "Ativa" : "Inativa";
    }

    /**
     * Retorna a classe CSS para o badge de padrão.
     */
    public String getPadraoBadgeClass() {
        return padrao ? "bg-primary" : "bg-secondary";
    }

    /**
     * Retorna true se a role pode ser editada.
     * Roles padrão podem ter descrição editada, mas não nome ou status.
     */
    public boolean podeEditar() {
        return !padrao || (padrao && descricao != null && !descricao.isBlank());
    }

    /**
     * Retorna true se a role pode ser removida.
     * Roles padrão e roles com usuários não podem ser removidas.
     */
    public boolean podeRemover() {
        return !padrao && totalUsuarios == 0;
    }

    /**
     * Gera iniciais para avatar baseado no nome da role.
     */
    public String getIniciais() {
        if (nome == null || nome.isBlank()) {
            return "R";
        }
        
        String[] palavras = nome.split("_");
        if (palavras.length >= 2) {
            return String.valueOf(palavras[0].charAt(0)) + String.valueOf(palavras[1].charAt(0));
        } else {
            return nome.length() >= 2 ? nome.substring(0, 2) : nome;
        }
    }

    /**
     * Gera cor baseada no nome da role para avatar.
     */
    public String getAvatarColor() {
        if (nome == null) return "bg-primary";
        
        // Cores consistentes baseadas no nome
        return switch (nome) {
            case "ADMIN" -> "bg-danger";
            case "USER" -> "bg-info";
            case "SERVICE" -> "bg-warning";
            default -> {
                if (nome.startsWith("GERENTE")) yield "bg-success";
                if (nome.startsWith("ANALISTA")) yield "bg-secondary";
                if (nome.startsWith("DESENVOLVEDOR")) yield "bg-dark";
                yield "bg-primary";
            }
        };
    }
}
```
```java
package br.com.plataforma.conexaodigital.admin.api.responses;

import java.time.LocalDateTime;

/**
 * DTO para resposta de listagem de roles na página administrativa.
 * Contém os campos essenciais para exibição na tabela.
 */
public record RoleListResponse(
    String id,
    String nome,
    String descricao,
    String realmNome,
    String realmId,
    Boolean padrao, // se é role padrão (ADMIN, USER, SERVICE)
    Boolean ativa,
    Long totalUsuarios,
    LocalDateTime dataCriacao
) {
    /**
     * Método estático de fábrica para criar instância a partir da entidade.
     * @param role entidade Role
     * @param realmNome nome do realm da role
     * @param realmId ID do realm da role
     * @param totalUsuarios quantidade de usuários com esta role
     * @return instância de RoleListResponse
     */
    public static RoleListResponse from(
        br.com.plataforma.conexaodigital.role.domain.model.Role role,
        String realmNome,
        String realmId,
        Long totalUsuarios
    ) {
        boolean isPadrao = role.getNome().equals("ADMIN") ||
                          role.getNome().equals("USER") ||
                          role.getNome().equals("SERVICE");

        return new RoleListResponse(
            role.getId().toString(),
            role.getNome(),
            role.getDescricao(),
            realmNome,
            realmId,
            isPadrao,
            role.ePadrao(), // Usar método correto
            totalUsuarios,
            role.getDataCriacao()
        );
    }

    /**
     * Verifica se a role pode ser removida.
     * Roles padrão e roles com usuários não podem ser removidas.
     */
    public boolean podeRemover() {
        return !padrao && totalUsuarios == 0;
    }

    /**
     * Gera iniciais para avatar baseado no nome da role.
     */
    public String getIniciais() {
        if (nome == null || nome.isBlank()) {
            return "R";
        }
        
        String[] palavras = nome.split("_");
        if (palavras.length >= 2) {
            return String.valueOf(palavras[0].charAt(0)) + String.valueOf(palavras[1].charAt(0));
        } else {
            return nome.length() >= 2 ? nome.substring(0, 2) : nome;
        }
    }

    /**
     * Gera cor baseada no nome da role para avatar.
     */
    public String getAvatarColor() {
        if (nome == null) return "bg-primary";
        
        // Cores consistentes baseadas no nome
        return switch (nome) {
            case "ADMIN" -> "bg-danger";
            case "USER" -> "bg-info";
            case "SERVICE" -> "bg-warning";
            default -> {
                if (nome.startsWith("GERENTE")) yield "bg-success";
                if (nome.startsWith("ANALISTA")) yield "bg-secondary";
                if (nome.startsWith("DESENVOLVEDOR")) yield "bg-dark";
                yield "bg-primary";
            }
        };
    }

    /**
     * Retorna a classe CSS para o badge de status.
     */
    public String getStatusBadgeClass() {
        return ativa ? "bg-success-subtle text-success" : "bg-danger-subtle text-danger";
    }

    /**
     * Retorna o texto do status.
     */
    public String getStatusText() {
        return ativa ? "Ativa" : "Inativa";
    }

    /**
     * Retorna a classe CSS para o badge de padrão.
     */
    public String getPadraoBadgeClass() {
        return padrao ? "bg-primary" : "bg-secondary";
    }
}
```
```java
package br.com.plataforma.conexaodigital.admin.api.responses;

import java.time.LocalDateTime;
import java.util.UUID;

import br.com.plataforma.conexaodigital.chave.domain.model.TipoRotacao;

/**
 * DTO para resposta de histórico de rotação de chave.
 */
public record RotacaoHistoricoResponse(
    UUID id,
    UUID realmId,
    String realmNome,
    String chaveAnteriorKid,
    String chaveNovaKid,
    LocalDateTime dataRotacao,
    TipoRotacao tipo,
    String solicitante
) {
    public String getDataFormatada() {
        return dataRotacao != null ? dataRotacao.format(java.time.format.DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss")) : "-";
    }

    public String getTipoDescricao() {
        return tipo != null ? tipo.getDescricao() : "-";
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.api.service;

import br.com.plataforma.conexaodigital.admin.api.mapper.RoleMapper;
import br.com.plataforma.conexaodigital.admin.api.dto.forms.RoleForm;
import br.com.plataforma.conexaodigital.admin.api.dto.responses.RoleDetailResponse;
import br.com.plataforma.conexaodigital.admin.api.dto.responses.RoleListResponse;
import br.com.plataforma.conexaodigital.role.domain.exception.RoleEmUsoException;
import br.com.plataforma.conexaodigital.role.domain.exception.RoleJaExisteException;
import br.com.plataforma.conexaodigital.role.domain.exception.RoleNaoEncontradaException;
import br.com.plataforma.conexaodigital.role.domain.exception.RolePadraoNaoPodeRemoverException;
import br.com.plataforma.conexaodigital.role.domain.model.Role;
import br.com.plataforma.conexaodigital.role.domain.repository.RoleRepository;
import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;

/**
 * Serviço para gestão de roles na página administrativa.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class AdminRoleApiService {

    private final RoleRepository roleRepository;
    private final RealmRepository realmRepository;

    /**
     * Lista roles com paginação e filtros.
     */
    public Page<RoleListResponse> listarRoles(
        int page,
        int size,
        String nome,
        String realmId
    ) {
        log.debug("Listando roles - page: {}, size: {}, nome: {}, realmId: {}",
            page, size, nome, realmId);

        Pageable pageable = PageRequest.of(page, size, Sort.by("nome").ascending());

        Page<Role> rolesPage;

        if (temFiltros(nome, realmId)) {
            rolesPage = roleRepository.buscarComFiltros(nome, realmId, pageable);
        } else {
            rolesPage = roleRepository.findAll(pageable);
        }

        // Converter para Response DTO
        return rolesPage.map(role -> {
            Long totalUsuarios = roleRepository.countUsuariosByRole(role.getId());
            String realmNome = role.getRealm() != null ? role.getRealm().getNome() : "-";
            String realmIdValue = role.getRealm() != null ? role.getRealm().getId().toString() : null;

            return RoleListResponse.from(role, realmNome, realmIdValue, totalUsuarios);
        });
    }

    /**
     * Busca role por ID.
     */
    public RoleDetailResponse buscarPorId(String id) {
        log.debug("Buscando role por ID: {}", id);

        Role role = roleRepository.findById(UUID.fromString(id))
            .orElseThrow(() -> new RoleNaoEncontradaException("Role não encontrada"));

        // Buscar informações relacionadas
        String realmNome = role.getRealm() != null ? role.getRealm().getNome() : "-";
        String realmIdValue = role.getRealm() != null ? role.getRealm().getId().toString() : null;
        Long totalUsuarios = roleRepository.countUsuariosByRole(role.getId());
        List<String> usuariosNomes = roleRepository.findUsuariosNomesByRole(role.getId());

        return RoleDetailResponse.from(role, realmNome, realmIdValue, totalUsuarios, usuariosNomes);
    }

    /**
     * Cria nova role.
     */
    @Transactional
    public RoleDetailResponse criarRole(RoleForm form) {
        log.debug("Criando nova role: {}", form.getNome());

        // Verificar se realm existe
        Realm realm = realmRepository.findById(UUID.fromString(form.getRealmId()))
            .orElseThrow(() -> new IllegalArgumentException("Realm não encontrado"));

        // Verificar se nome já existe no realm
        boolean nomeJaExiste = roleRepository.existsByNomeAndRealmId(
            form.getNome().toUpperCase(),
            UUID.fromString(form.getRealmId())
        );

        if (nomeJaExiste) {
            throw new RoleJaExisteException("Role '" + form.getNome() + "' já existe neste realm");
        }

        // Criar role
        Role role = RoleMapper.toEntity(form);
        role.setRealm(realm);

        Role savedRole = roleRepository.save(role);

        log.info("Role criada com sucesso: {} (ID: {})", savedRole.getNome(), savedRole.getId());

        // Buscar informações relacionadas
        Long totalUsuarios = 0L;
        List<String> usuariosNomes = List.of();

        return RoleDetailResponse.from(savedRole, realm.getNome(), realm.getId().toString(),
            totalUsuarios, usuariosNomes);
    }

    /**
     * Atualiza role existente.
     */
    @Transactional
    public RoleDetailResponse atualizarRole(RoleForm form) {
        log.debug("Atualizando role: {} (ID: {})", form.getNome(), form.getId());

        Role role = roleRepository.findById(UUID.fromString(form.getId()))
            .orElseThrow(() -> new RoleNaoEncontradaException("Role não encontrada"));

        // Verificar se é role padrão
        boolean isPadrao = role.getNome().equals("ADMIN") ||
                          role.getNome().equals("USER") ||
                          role.getNome().equals("SERVICE");

        if (isPadrao && !form.getPadrao()) {
            throw new IllegalArgumentException("Não é possível remover marca de padrão de roles padrão");
        }

         if (!role.getNome().equalsIgnoreCase(form.getNome())) {
            // No need to check for uniqueness when name hasn't changed
            // The validation will be checked by repository on save
        }

        // Atualizar campos permitidos
        role.setNome(form.getNome().toUpperCase());
        role.setDescricao(form.getDescricao());
        role.markAsUpdated();

        Role savedRole = roleRepository.save(role);

        log.info("Role atualizada com sucesso: {} (ID: {})", savedRole.getNome(), savedRole.getId());

        // Buscar informações relacionadas
        String realmNome = role.getRealm() != null ? role.getRealm().getNome() : "-";
        String realmIdValue = role.getRealm() != null ? role.getRealm().getId().toString() : null;
        
        // TODO: Implement many-to-many relationship between User and Role
        // For now, return 0 for user counts and empty list for user names
        Long totalUsuarios = 0L;
        List<String> usuariosNomes = List.of();

        return RoleDetailResponse.from(savedRole, realmNome, realmIdValue, totalUsuarios, usuariosNomes);
    }

    /**
     * Remove role.
     */
    @Transactional
    public void removerRole(String id) {
        log.debug("Removendo role: {}", id);

        Role role = roleRepository.findById(UUID.fromString(id))
            .orElseThrow(() -> new RoleNaoEncontradaException("Role não encontrada"));

        // Verificar se é role padrão
        boolean isPadrao = role.getNome().equals("ADMIN") ||
                          role.getNome().equals("USER") ||
                          role.getNome().equals("SERVICE");

        if (isPadrao) {
            throw new RolePadraoNaoPodeRemoverException("Roles padrão (ADMIN, USER, SERVICE) não podem ser removidas");
        }

        // Verificar se tem usuários associados
        Long totalUsuarios = roleRepository.countUsuariosByRole(role.getId());

        if (totalUsuarios > 0) {
            throw new RoleEmUsoException("Role possui " + totalUsuarios +
                " usuário(s) associado(s) e não pode ser removida");
        }

        roleRepository.delete(role);

        log.info("Role removida com sucesso: {} (ID: {})", role.getNome(), role.getId());
    }

    /**
     * Lista todos os realms para os filtros.
     */
    public List<RealmSimpleResponse> listarTodosRealms() {
        return realmRepository.findAll().stream()
            .map(realm -> new RealmSimpleResponse(
                realm.getId().toString(),
                realm.getNome(),
                realm.isAtivo()
            ))
            .toList();
    }

    /**
     * Verifica se há filtros ativos.
     */
    private boolean temFiltros(String nome, String realmId) {
        return (nome != null && !nome.isBlank()) ||
               (realmId != null && !realmId.isBlank() && !realmId.equals("All"));
    }

    /**
     * DTO simplificado de realm para filtros.
     */
    public record RealmSimpleResponse(
        String id,
        String nome,
        Boolean ativo
    ) {}
}

```
```java
package br.com.plataforma.conexaodigital.admin.domain.exceptions;

public class NomeRealmJaExisteException extends RuntimeException {

    public NomeRealmJaExisteException(String message) {
        super(message);
    }

    public NomeRealmJaExisteException(String message, Throwable cause) {
        super(message, cause);
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.domain.exceptions;

public class RealmMasterNaoPodeSerEditadoException extends RuntimeException {

    public RealmMasterNaoPodeSerEditadoException(String message) {
        super(message);
    }

    public RealmMasterNaoPodeSerEditadoException(String message, Throwable cause) {
        super(message, cause);
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.domain.service;

import br.com.plataforma.conexaodigital.admin.api.dto.forms.RealmForm;
import br.com.plataforma.conexaodigital.admin.api.dto.responses.RealmDetailResponse;
import br.com.plataforma.conexaodigital.admin.api.dto.responses.RealmListResponse;
import br.com.plataforma.conexaodigital.admin.domain.exceptions.RealmMasterNaoPodeSerEditadoException;
import br.com.plataforma.conexaodigital.realm.domain.exceptions.NomeRealmJaExisteException;
import br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmNotFoundException;
import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import br.com.plataforma.conexaodigital.realm.domain.model.StatusRealm;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import br.com.plataforma.conexaodigital.usuario.domain.repository.UsuarioRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class AdminRealmService {

    private final RealmRepository realmRepository;
    private final UsuarioRepository usuarioRepository;

    public Page<RealmListResponse> listarRealms(int page, int size, String nome, String status) {
        log.info("Listando realms: page={}, size={}, nome={}, status={}", page, size, nome, status);

        Pageable pageable = PageRequest.of(page, size, Sort.by("nome").ascending());

        Page<Realm> realmsPage;
        if (nome != null && !nome.isBlank() && status != null && !status.isBlank()) {
            realmsPage = realmRepository.findByNomeContainingIgnoreCaseAndStatus(
                nome,
                StatusRealm.valueOf(status.toUpperCase()),
                pageable
            );
        } else if (nome != null && !nome.isBlank()) {
            realmsPage = realmRepository.findByNomeContainingIgnoreCase(nome, pageable);
        } else if (status != null && !status.isBlank()) {
            realmsPage = realmRepository.findByStatus(StatusRealm.valueOf(status.toUpperCase()), pageable);
        } else {
            realmsPage = realmRepository.findAll(pageable);
        }

        List<RealmListResponse> responses = realmsPage.getContent().stream()
            .map(realm -> {
                Long totalUsuarios = contarUsuariosPorRealm(realm.getId().toString());
                Long chavesAtivas = 1L;
                Long totalRoles = 0L;
                return RealmListResponse.from(realm, totalUsuarios, chavesAtivas, totalRoles);
            })
            .collect(Collectors.toList());

        return new PageImpl<>(responses, pageable, realmsPage.getTotalElements());
    }

    @Transactional(readOnly = true)
    public RealmDetailResponse buscarPorId(String id) {
        log.info("Buscando realm por ID: {}", id);

        Realm realm = realmRepository.findById(UUID.fromString(id))
            .orElseThrow(() -> new RealmNotFoundException("Realm não encontrado: " + id));

        Long totalUsuarios = contarUsuariosPorRealm(id);
        Long usuariosAtivos = contarUsuariosAtivosPorRealm(id);
        Long usuariosBloqueados = contarUsuariosBloqueadosPorRealm(id);
        Long chavesAtivas = 1L;
        Long chavesInativas = 0L;
        Long totalRoles = 0L;
        List<String> roles = List.of();

        return RealmDetailResponse.from(
            realm, totalUsuarios, usuariosAtivos, usuariosBloqueados,
            chavesAtivas, chavesInativas, totalRoles, roles
        );
    }

    @Transactional
    public Realm criarRealm(RealmForm form) {
        log.info("Criando novo realm: {}", form.getNome());

        validarUnicidadeNome(form.getNome(), null);

        Realm realm = new Realm(form.getNome(), form.getStatus());
        realm.setDescricao(form.getDescricao());
        realm.setEmpresaId(form.getEmpresaId());
        realm.setTenantId(form.getTenantId());
        realm.setMaster(false);
        realm.setDataCriacao(java.time.LocalDateTime.now());
        realm.setDataAtualizacao(java.time.LocalDateTime.now());

        Realm savedRealm = realmRepository.save(realm);
        log.info("Realm criado com sucesso: {}", savedRealm.getId());

        return savedRealm;
    }

    @Transactional
    public Realm atualizarRealm(String id, RealmForm form) {
        log.info("Atualizando realm: {}", id);

        Realm realm = realmRepository.findById(UUID.fromString(id))
            .orElseThrow(() -> new RealmNotFoundException("Realm não encontrado: " + id));

        if (realm.getMaster() != null && realm.getMaster()) {
            if (!realm.getNome().equals(form.getNome())) {
                throw new RealmMasterNaoPodeSerEditadoException("Nome do Realm Master não pode ser alterado");
            }
        }

        validarUnicidadeNome(form.getNome(), id);

        realm.setNome(form.getNome());
        realm.setDescricao(form.getDescricao());
        realm.setStatus(form.getStatus());
        realm.setEmpresaId(form.getEmpresaId());
        realm.setTenantId(form.getTenantId());
        realm.setDataAtualizacao(java.time.LocalDateTime.now());

        Realm updatedRealm = realmRepository.save(realm);
        log.info("Realm atualizado com sucesso: {}", updatedRealm.getId());

        return updatedRealm;
    }

    @Transactional
    public Realm ativarRealm(String id) {
        log.info("Ativando realm: {}", id);

        Realm realm = realmRepository.findById(UUID.fromString(id))
            .orElseThrow(() -> new RealmNotFoundException("Realm não encontrado: " + id));

        if (realm.isAtivo()) {
            log.warn("Realm já está ativo: {}", id);
            return realm;
        }

        realm.setStatus(StatusRealm.ATIVO);
        realm.setDataReativacao(java.time.LocalDateTime.now());
        realm.setDataAtualizacao(java.time.LocalDateTime.now());

        Realm activatedRealm = realmRepository.save(realm);
        log.info("Realm ativado com sucesso: {}", activatedRealm.getId());

        return activatedRealm;
    }

    @Transactional
    public Realm desativarRealm(String id) {
        log.info("Desativando realm: {}", id);

        Realm realm = realmRepository.findById(UUID.fromString(id))
            .orElseThrow(() -> new RealmNotFoundException("Realm não encontrado: " + id));

        if (realm.getMaster() != null && realm.getMaster()) {
            throw new RealmMasterNaoPodeSerEditadoException("Realm Master não pode ser desativado");
        }

        if (realm.isInativo()) {
            log.warn("Realm já está inativo: {}", id);
            return realm;
        }

        realm.setStatus(StatusRealm.INATIVO);
        realm.setDataDesativacao(java.time.LocalDateTime.now());
        realm.setDataAtualizacao(java.time.LocalDateTime.now());

        Realm deactivatedRealm = realmRepository.save(realm);
        log.info("Realm desativado com sucesso: {}", deactivatedRealm.getId());

        return deactivatedRealm;
    }

    public void validarUnicidadeNome(String nome, String id) {
        realmRepository.findByNomeIgnoreCase(nome).ifPresent(realm -> {
            if (id == null || !realm.getId().toString().equals(id)) {
                throw new NomeRealmJaExisteException("Nome de realm já existe: " + nome);
            }
        });
    }

    @Transactional(readOnly = true)
    public Long contarUsuariosPorRealm(String realmId) {
        return usuarioRepository.countByRealmId(UUID.fromString(realmId));
    }

    @Transactional(readOnly = true)
    public Long contarUsuariosAtivosPorRealm(String realmId) {
        return usuarioRepository.countByRealmIdAndStatusAtivo(UUID.fromString(realmId));
    }

    @Transactional(readOnly = true)
    public Long contarUsuariosBloqueadosPorRealm(String realmId) {
        return usuarioRepository.countByRealmIdAndBloqueadoTrue(UUID.fromString(realmId));
    }

    @Transactional(readOnly = true)
    public Long contarChavesAtivasPorRealm(String realmId) {
        return 1L;
    }

    @Transactional(readOnly = true)
    public Long contarChavesInativasPorRealm(String realmId) {
        return 0L;
    }

    @Transactional(readOnly = true)
    public List<String> listarRolesPorRealm(String realmId) {
        return List.of();
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.domain.service;

import br.com.plataforma.conexaodigital.admin.api.dto.forms.RoleForm;
import br.com.plataforma.conexaodigital.admin.api.dto.responses.RoleDetailResponse;
import br.com.plataforma.conexaodigital.admin.api.dto.responses.RoleListResponse;
import br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmNotFoundException;
import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import br.com.plataforma.conexaodigital.role.domain.exceptions.NomeRoleJaExisteException;
import br.com.plataforma.conexaodigital.role.domain.exception.RoleEmUsoException;
import br.com.plataforma.conexaodigital.role.domain.exceptions.RoleNotFoundException;
import br.com.plataforma.conexaodigital.role.domain.exceptions.RolePadraoNaoPodeSerRemovidaException;
import br.com.plataforma.conexaodigital.role.domain.model.Role;
import br.com.plataforma.conexaodigital.role.domain.repository.RoleRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Service para gestão administrativa de roles.
 * Fornece operações CRUD para a interface web administrativa.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AdminRoleService {

    private final RoleRepository roleRepository;
    private final RealmRepository realmRepository;
    private final br.com.plataforma.conexaodigital.usuario.domain.repository.UsuarioRepository usuarioRepository;

    /**
     * Lista todas as roles com paginação e filtros.
     */
    @Transactional(readOnly = true)
    public Page<RoleListResponse> listarRoles(int page, int size, String nome, String realmId, Boolean padrao) {
        log.info("Listando roles: page={}, size={}, nome={}, realmId={}, padrao={}", page, size, nome, realmId, padrao);

        Pageable pageable = PageRequest.of(page, size, Sort.by("nome").ascending());

        Page<Role> rolesPage;

        if (nome != null && !nome.isBlank() && realmId != null && !realmId.isBlank()) {
            // Filtra por nome e realm usando a query de filtros
            rolesPage = roleRepository.buscarComFiltros(nome, realmId, pageable);
        } else if (nome != null && !nome.isBlank()) {
            // Filtra apenas por nome usando a query de filtros
            rolesPage = roleRepository.buscarComFiltros(nome, null, pageable);
        } else if (realmId != null && !realmId.isBlank()) {
            // Filtra apenas por realm
            rolesPage = roleRepository.findByRealmId(UUID.fromString(realmId), pageable);
        } else {
            // Sem filtros
            rolesPage = roleRepository.findAll(pageable);
        }

        // Filtra por padrao se especificado
        List<Role> rolesFiltradas = rolesPage.getContent().stream()
                .filter(role -> padrao == null ||
                        (padrao && ("ADMIN".equals(role.getNome()) || "USER".equals(role.getNome()) || "SERVICE".equals(role.getNome()))) ||
                        (!padrao && !("ADMIN".equals(role.getNome()) || "USER".equals(role.getNome()) || "SERVICE".equals(role.getNome()))))
                .collect(Collectors.toList());

        // Converte para DTOs
        List<RoleListResponse> responses = rolesFiltradas.stream()
                .map(role -> {
                    String realmNome = role.getRealm() != null ? role.getRealm().getNome() : "N/A";
                    String realmIdStr = role.getRealm() != null ? role.getRealm().getId().toString() : null;
                    Long totalUsuarios = contarUsuariosPorRole(role.getId().toString());
                    return RoleListResponse.from(role, realmNome, realmIdStr, totalUsuarios);
                })
                .collect(Collectors.toList());

        return new PageImpl<>(responses, pageable, rolesPage.getTotalElements());
    }

    /**
     * Busca uma role por ID.
     */
    @Transactional(readOnly = true)
    public RoleDetailResponse buscarPorId(String id) {
        log.info("Buscando role por ID: {}", id);

        Role role = roleRepository.findById(UUID.fromString(id))
                .orElseThrow(() -> new RoleNotFoundException(UUID.fromString(id)));

        String realmNome = role.getRealm() != null ? role.getRealm().getNome() : "N/A";
        String realmIdStr = role.getRealm() != null ? role.getRealm().getId().toString() : null;
        Long totalUsuarios = contarUsuariosPorRole(id);
        List<String> usuariosNomes = listarNomesUsuariosPorRole(id);

        return RoleDetailResponse.from(role, realmNome, realmIdStr, totalUsuarios, usuariosNomes);
    }

    /**
     * Cria uma nova role.
     */
    @Transactional
    public Role criarRole(RoleForm form) {
        log.info("Criando nova role: {} no realm: {}", form.getNome(), form.getRealmId());

        // Busca o realm
        Realm realm = realmRepository.findById(UUID.fromString(form.getRealmId()))
                .orElseThrow(() -> new RealmNotFoundException("Realm não encontrado: " + form.getRealmId()));

        // Valida unicidade do nome no realm
        if (roleRepository.existsByNomeAndRealmId(form.getNome(), realm.getId())) {
            throw new NomeRoleJaExisteException("Já existe uma role com o nome \"" + form.getNome() + "\" no realm \"" + realm.getNome() + "\"", UUID.randomUUID());
        }

        // Cria a role
        Role role = new Role(form.getNome(), form.getDescricao(), realm, form.getPadrao() != null && form.getPadrao());

        role.setDataCriacao(java.time.LocalDateTime.now());
        role.setDataAtualizacao(java.time.LocalDateTime.now());
        role.setVersao(0L);

        Role savedRole = roleRepository.save(role);
        log.info("Role criada com sucesso: {}", savedRole.getId());

        return savedRole;
    }

    /**
     * Atualiza uma role existente.
     */
    @Transactional
    public void atualizarRole(String id, RoleForm form) {
        log.info("Atualizando role: {}", id);

        Role role = roleRepository.findById(UUID.fromString(id))
                .orElseThrow(() -> new RoleNotFoundException(UUID.fromString(id)));

        // Apenas a descrição pode ser alterada (nome e realm são imutáveis)
        role.setDescricao(form.getDescricao());
        role.setDataAtualizacao(java.time.LocalDateTime.now());

        Role updatedRole = roleRepository.save(role);
        log.info("Role atualizada com sucesso: {}", updatedRole.getId());
    }

    /**
     * Remove uma role.
     */
    @Transactional
    public void removerRole(String id) {
        log.info("Removendo role: {}", id);

        Role role = roleRepository.findById(UUID.fromString(id))
                .orElseThrow(() -> new RoleNotFoundException(UUID.fromString(id)));

        // Verifica se é uma role padrão
        if ("ADMIN".equals(role.getNome()) || "USER".equals(role.getNome()) || "SERVICE".equals(role.getNome())) {
            throw new RolePadraoNaoPodeSerRemovidaException();
        }

        Long totalUsuarios = contarUsuariosPorRole(id);
        if (totalUsuarios > 0) {
            String msg = "Nao é possível remover a role \"" + role.getNome() + "\" pois há " +
                       totalUsuarios + " usuário(s) associado(s)";
            throw new RoleEmUsoException(msg);
        }

        roleRepository.delete(role);
        log.info("Role removida com sucesso: {}", id);
    }

    /**
     * Conta o número de usuários associados a uma role.
     */
    @Transactional(readOnly = true)
    private Long contarUsuariosPorRole(String roleId) {
        try {
            return roleRepository.countUsuariosByRole(UUID.fromString(roleId));
        } catch (Exception e) {
            log.warn("Erro ao contar usuários da role {}: {}", roleId, e.getMessage());
            return 0L;
        }
    }

    /**
     * Lista os nomes dos usuários associados a uma role.
     */
    @Transactional(readOnly = true)
    private List<String> listarNomesUsuariosPorRole(String roleId) {
        try {
            return roleRepository.findUsuariosNomesByRole(UUID.fromString(roleId));
        } catch (Exception e) {
            log.warn("Erro ao listar nomes de usuários da role {}: {}", roleId, e.getMessage());
            return List.of();
        }
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.domain.service;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.springframework.stereotype.Service;

import br.com.plataforma.conexaodigital.admin.api.dto.DashboardResponse;
import br.com.plataforma.conexaodigital.admin.api.dto.EventoAuditoriaItem;
import br.com.plataforma.conexaodigital.chave.domain.model.StatusChave;
import br.com.plataforma.conexaodigital.chave.domain.repository.ChaveCriptograficaRepository;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import br.com.plataforma.conexaodigital.role.domain.repository.RoleRepository;
import br.com.plataforma.conexaodigital.usuario.domain.model.enums.StatusUsuario;
import br.com.plataforma.conexaodigital.usuario.domain.repository.UsuarioRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Service para fornecer dados do Dashboard administrativo.
 * Agrega métricas de diferentes domínios do sistema.
 */
@Service
@Slf4j
@RequiredArgsConstructor
public class DashboardService {

    private final UsuarioRepository usuarioRepository;
    private final RealmRepository realmRepository;
    private final RoleRepository roleRepository;
    private final ChaveCriptograficaRepository chaveCriptograficaRepository;

    /**
     * Obtém os dados do Dashboard com métricas e eventos recentes.
     *
     * @return DashboardResponse com todas as métricas e eventos
     */
    public DashboardResponse obterDashboard() {
        log.debug("Obtendo dados do dashboard");

        // Métricas totais
        long totalRealms = realmRepository.count();
        long totalUsuarios = usuarioRepository.count();
        long totalRoles = roleRepository.count();
        long totalChavesAtivas = chaveCriptograficaRepository.countByStatus(StatusChave.ATIVA);

        // Dados para gráfico de usuários por realm
        List<String> labelsUsuariosPorRealm = realmRepository.findAll().stream()
                .map(realm -> realm.getNome())
                .toList();
        List<Long> dadosUsuariosPorRealm = realmRepository.findAll().stream()
                .map(realm -> usuarioRepository.countByRealmId(realm.getId()))
                .toList();

        // Dados para gráfico de usuários por status
        List<Long> dadosUsuariosPorStatus = List.of(
                usuarioRepository.countByStatus(StatusUsuario.ATIVO),
                usuarioRepository.countByStatus(StatusUsuario.INATIVO),
                usuarioRepository.countByStatus(StatusUsuario.BLOQUEADO));

        // Eventos recentes (simulado até implementação do Epic 7)
        List<EventoAuditoriaItem> eventosRecentes = criarEventosRecentesSimulados();

        return new DashboardResponse(
                totalRealms,
                totalUsuarios,
                totalRoles,
                totalChavesAtivas,
                labelsUsuariosPorRealm,
                dadosUsuariosPorRealm,
                dadosUsuariosPorStatus,
                eventosRecentes);
    }

    /**
     * Obtém métricas para atualização AJAX do dashboard.
     * OBSERVAÇÃO: Este método não é mais utilizado.
     * As métricas são obtidas diretamente pelo AdminApiController.
     * Mantido para compatibilidade futura.
     */
    public DashboardResponse obterDashboardMetrics() {
        return obterDashboard();
    }

    /**
     * Obtém dados do gráfico de evolução de usuários.
     */
    public Map<String, Object> getUserEvolution(int periodDays) {
        LocalDateTime startDate = LocalDateTime.now().minusDays(periodDays);

        // Dados simulados - substituir por implementação real quando Epic 2 estiver
        // completo
        List<String> periodos = new ArrayList<>();
        List<Long> valores = new ArrayList<>();

        for (int i = periodDays - 1; i >= 0; i--) {
            LocalDateTime date = LocalDateTime.now().minusDays(i);
            periodos.add(date.format(DateTimeFormatter.ofPattern("dd/MM")));
            valores.add(10L + (long) (Math.random() * 15));
        }

        return Map.of(
                "label", "Novos Usuários",
                "valores", valores,
                "periodos", periodos);
    }

    /**
     * Obtém distribuição de usuários por realm.
     */
    public List<Map<String, Object>> getRealmDistribution() {
        Long totalUsuarios = usuarioRepository.count();

        String[] cores = {
                "rgb(59, 130, 246)", // blue-500
                "rgb(16, 185, 129)", // green-500
                "rgb(245, 158, 11)", // amber-500
                "rgb(239, 68, 68)", // red-500
                "rgb(139, 92, 246)", // violet-500
                "rgb(236, 72, 153)", // pink-500
                "rgb(6, 182, 212)", // cyan-500
                "rgb(249, 115, 22)" // orange-500
        };

        List<Map<String, Object>> distribution = new ArrayList<>();
        int colorIndex = 0;

        var realms = realmRepository.findAll();
        for (var realm : realms) {
            Long totalPorRealm = usuarioRepository.countByRealmId(realm.getId());
            Double porcentagem = (totalUsuarios > 0)
                    ? (totalPorRealm.doubleValue() / totalUsuarios) * 100
                    : 0.0;

            distribution.add(Map.of(
                    "realmNome", realm.getNome(),
                    "totalUsuarios", totalPorRealm,
                    "porcentagem", porcentagem,
                    "cor", cores[colorIndex % cores.length]));
            colorIndex++;
        }

        // Ordenar por total (maior para menor)
        distribution.sort((a, b) -> Long.compare((Long) b.get("totalUsuarios"), (Long) a.get("totalUsuarios")));

        return distribution;
    }

    /**
     * Obtém eventos por tipo para o gráfico.
     */
    public List<Map<String, Object>> getEventsByType() {
        // Dados simulados - substituir por implementação real do Epic 7
        String[] tipos = { "LOGIN", "CRIACAO", "EDICAO", "BLOQUEIO", "DESBLOQUEIO", "RESET_SENHA" };
        Long[] quantidades = { 65L, 12L, 8L, 3L, 2L, 5L };

        String[] cores = {
                "rgb(59, 130, 246)", // blue - LOGIN
                "rgb(16, 185, 129)", // green - CRIACAO
                "rgb(245, 158, 11)", // amber - EDICAO
                "rgb(239, 68, 68)", // red - BLOQUEIO
                "rgb(139, 92, 246)", // violet - DESBLOQUEIO
                "rgb(6, 182, 212)" // cyan - RESET_SENHA
        };

        List<Map<String, Object>> eventosPorTipo = new ArrayList<>();
        long totalEventos = 0L;
        for (Long q : quantidades) {
            totalEventos += q;
        }

        for (int i = 0; i < tipos.length && i < cores.length; i++) {
            Long quantidade = quantidades[i];
            Double porcentagem = (totalEventos > 0)
                    ? (quantidade.doubleValue() / totalEventos) * 100
                    : 0.0;

            eventosPorTipo.add(Map.of(
                    "tipo", tipos[i],
                    "quantidade", quantidade,
                    "porcentagem", porcentagem,
                    "cor", cores[i]));
        }

        return eventosPorTipo;
    }

    /**
     * Obtém informações sobre a próxima rotação de chaves.
     */
    public Map<String, Object> getKeyRotationInfo() {
        // Calcular dia 1 do próximo mês às 00:00:00
        LocalDateTime proximaRotacao = LocalDateTime.now()
                .plusMonths(1)
                .withDayOfMonth(1)
                .withHour(0)
                .withMinute(0)
                .withSecond(0)
                .withNano(0);

        LocalDateTime agora = LocalDateTime.now();

        // Calcular tempo restante
        long diasRestantes = java.time.temporal.ChronoUnit.DAYS.between(agora, proximaRotacao);
        long horasRestantes = java.time.temporal.ChronoUnit.HOURS.between(agora, proximaRotacao) % 24;
        long minutosRestantes = java.time.temporal.ChronoUnit.MINUTES.between(agora, proximaRotacao) % 60;
        long segundosRestantes = java.time.temporal.ChronoUnit.SECONDS.between(agora, proximaRotacao) % 60;

        // Calcular status
        String status;
        if (diasRestantes <= 0 && horasRestantes < 1) {
            status = "DANGER";
        } else if (diasRestantes < 7) {
            status = "WARNING";
        } else {
            status = "NORMAL";
        }

        // Calcular progresso (baseado em 30 dias como período total)
        long periodoTotal = 30;
        long diasPassados = periodoTotal - diasRestantes;
        double progresso = (diasPassados * 100.0) / periodoTotal;
        progresso = Math.max(0, Math.min(100, progresso));

        return Map.of(
                "proximaRotacao", proximaRotacao,
                "diasRestantes", diasRestantes,
                "horasRestantes", horasRestantes,
                "minutosRestantes", minutosRestantes,
                "segundosRestantes", segundosRestantes,
                "status", status,
                "progresso", progresso);
    }

    /**
     * Cria eventos de auditoria recentes simulados para o dashboard.
     * Este método deve ser substituído pela implementação real do Epic 7
     * (Auditoria).
     *
     * @return Lista de eventos de auditoria simulados
     */
    private List<EventoAuditoriaItem> criarEventosRecentesSimulados() {
        // TODO: Substituir pela implementação real quando o Epic 7 for implementado
        return List.of(
                new EventoAuditoriaItem(LocalDateTime.now().minusMinutes(5), "LOGIN",
                        "Usuário admin@example.com realizou login"),
                new EventoAuditoriaItem(LocalDateTime.now().minusHours(1), "CADASTRO_USUARIO",
                        "Novo usuário criado: joao@example.com"),
                new EventoAuditoriaItem(LocalDateTime.now().minusHours(2), "ROTACAO_CHAVE",
                        "Rotação de chaves executada para realm master"),
                new EventoAuditoriaItem(LocalDateTime.now().minusHours(3), "ATUALIZACAO_USUARIO",
                        "Usuário maria@example.com atualizado"),
                new EventoAuditoriaItem(LocalDateTime.now().minusHours(5), "CRIACAO_ROLE", "Role MODERADOR criada"),
                new EventoAuditoriaItem(LocalDateTime.now().minusHours(6), "BLOQUEIO_USUARIO",
                        "Usuário bloqueado: suspeito@example.com"),
                new EventoAuditoriaItem(LocalDateTime.now().minusHours(8), "DESBLOQUEIO_USUARIO",
                        "Usuário desbloqueado: usuario@example.com"),
                new EventoAuditoriaItem(LocalDateTime.now().minusHours(12), "LOGIN",
                        "Usuário admin@example.com realizou login"),
                new EventoAuditoriaItem(LocalDateTime.now().minusHours(15), "ROTACAO_CHAVE",
                        "Rotação automática de chaves realizada"),
                new EventoAuditoriaItem(LocalDateTime.now().minusHours(24), "CRIACAO_REALM",
                        "Realm 'empresa-xyz' criado"));
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.security;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.*;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.authentication.AuthenticationFailureHandler;
import org.springframework.stereotype.Component;
import org.springframework.web.util.UriComponentsBuilder;

import java.io.IOException;

/**
 * Handler customizado para falhas de autenticação.
 * Mapeia diferentes exceções para mensagens amigáveis ao usuário.
 */
@Component
public class CustomAuthenticationFailureHandler implements AuthenticationFailureHandler {

    @Override
    public void onAuthenticationFailure(
        HttpServletRequest request,
        HttpServletResponse response,
        AuthenticationException exception
    ) throws IOException {

        String username = request.getParameter("username");
        String errorMessage = getErrorMessage(exception);

        // Redirecionar para página de login com erro e mensagem
        String redirectUrl = UriComponentsBuilder.fromPath("/admin/login")
            .queryParam("error", true)
            .queryParam("message", errorMessage)
            .queryParam("username", username)
            .build()
            .toUriString();

        response.sendRedirect(redirectUrl);
    }

    /**
     * Mapear diferentes exceções de autenticação para mensagens amigáveis.
     *
     * @param exception Exceção de autenticação
     * @return Código de erro para exibição ao usuário
     */
    private String getErrorMessage(AuthenticationException exception) {
        if (exception instanceof BadCredentialsException) {
            // Verificar se é usuário não encontrado ou senha incorreta
            String message = exception.getMessage();
            if (message != null && message.contains("User not found")) {
                return "USER_NOT_FOUND";
            }
            return "INVALID_CREDENTIALS";
        }

        if (exception instanceof DisabledException) {
            return "ACCOUNT_DISABLED";
        }

        if (exception instanceof LockedException) {
            return "ACCOUNT_LOCKED";
        }

        if (exception instanceof AccountExpiredException) {
            return "ACCOUNT_EXPIRED";
        }

        if (exception instanceof CredentialsExpiredException) {
            return "CREDENTIALS_EXPIRED";
        }

        // Default
        return "AUTHENTICATION_FAILED";
    }
}

```
```java
package br.com.plataforma.conexaodigital.admin.security;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.core.Authentication;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;
import org.springframework.stereotype.Component;
import org.springframework.web.util.UriComponentsBuilder;

import java.io.IOException;

/**
 * Handler customizado para sucesso de autenticação.
 * Registra evento de login e redireciona para o dashboard.
 */
@Component
public class CustomAuthenticationSuccessHandler implements AuthenticationSuccessHandler {

    @Override
    public void onAuthenticationSuccess(
        HttpServletRequest request,
        HttpServletResponse response,
        Authentication authentication
    ) throws IOException {
        String username = authentication.getName();

        // TODO: Registrar evento de login bem-sucedido na auditoria
        // auditoriaService.registrarEvento(
        //     TipoEventoAuditoria.LOGIN,
        //     username,
        //     null,
        //     "Login realizado com sucesso",
        //     request.getRemoteAddr(),
        //     "SUCCESS"
        // );

        // Redirecionar para dashboard
        String redirectUrl = UriComponentsBuilder.fromPath("/admin/dashboard")
            .build()
            .toUriString();

        response.sendRedirect(redirectUrl);
    }
}

```
```java
package br.com.plataforma.conexaodigital.auditoria.api.controller;

import br.com.plataforma.conexaodigital.auditoria.api.responses.EventoAuditoriaResponse;
import br.com.plataforma.conexaodigital.auditoria.domain.model.enums.TipoEventoAuditoria;
import br.com.plataforma.conexaodigital.auditoria.domain.service.AuditoriaService;
import br.com.plataforma.conexaodigital.auditoria.domain.service.impl.AuditoriaServiceImpl.EventoAuditoriaNotFoundException;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * REST controller for audit events.
 */
@RestController
@RequestMapping("/api/v1/auditoria")
@RequiredArgsConstructor
@Tag(name = "Auditoria", description = "Operações de auditoria de eventos de segurança")
public class AuditoriaController {
    
    private final AuditoriaService auditoriaService;
    
    @GetMapping("/eventos")
    @Operation(summary = "Listar eventos de auditoria", description = "Lista eventos de auditoria com paginação e filtros opcionais")
    @ApiResponses({
        @ApiResponse(responseCode = "200", description = "Lista de eventos retornada com sucesso")
    })
    ResponseEntity<Page<EventoAuditoriaResponse>> listar(
        @Parameter(description = "ID do realm para filtro") @RequestParam(required = false) UUID realmId,
        @Parameter(description = "Tipo do evento para filtro") @RequestParam(required = false) TipoEventoAuditoria tipo,
        @Parameter(description = "Email do usuário para filtro (busca parcial)") @RequestParam(required = false) String usuarioEmail,
        @Parameter(description = "Data início do período") @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime dataInicio,
        @Parameter(description = "Data fim do período") @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime dataFim,
        @Parameter(description = "Número da página (0-based)") @RequestParam(defaultValue = "0") int page,
        @Parameter(description = "Tamanho da página (máximo 100)") @RequestParam(defaultValue = "20") int size,
        @Parameter(description = "Ordenação (padrão: dataCriacao,desc)") @RequestParam(defaultValue = "dataCriacao,desc") String sort
    ) {
        // Validação do tamanho máximo da página
        if (size > 100) {
            size = 100;
        }
        
        // Configuração da paginação com ordenação padrão
        Pageable pageable = PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "dataCriacao"));
        
        Page<EventoAuditoriaResponse> response = auditoriaService.listar(
            realmId, tipo, usuarioEmail, dataInicio, dataFim, pageable
        );
        return ResponseEntity.ok(response);
    }
    
    @GetMapping("/eventos/{id}")
    @Operation(summary = "Buscar evento por ID", description = "Retorna os detalhes de um evento de auditoria específico")
    @ApiResponses({
        @ApiResponse(responseCode = "200", description = "Evento encontrado"),
        @ApiResponse(responseCode = "404", description = "Evento não encontrado")
    })
    ResponseEntity<EventoAuditoriaResponse> buscarPorId(@PathVariable UUID id) {
        EventoAuditoriaResponse response = auditoriaService.buscarPorId(id);
        return ResponseEntity.ok(response);
    }
}
```
```java
package br.com.plataforma.conexaodigital.auditoria.api.responses;

import br.com.plataforma.conexaodigital.auditoria.domain.model.enums.TipoEventoAuditoria;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.UUID;

/**
 * DTO for audit event responses.
 */
public record EventoAuditoriaResponse(
    UUID id,
    TipoEventoAuditoria tipo,
    UUID usuarioId,
    String usuarioEmail,
    UUID realmId,
    String realmNome,
    String descricao,
    String ipAddress,
    String userAgent,
    Map<String, Object> detalhes,
    LocalDateTime dataCriacao
) {}
```
```java
package br.com.plataforma.conexaodigital.auditoria.domain.model;

import br.com.plataforma.conexaodigital.auditoria.domain.model.enums.TipoEventoAuditoria;
import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import br.com.plataforma.conexaodigital.shared.domain.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.Index;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Represents an audit event in system.
 * Audit events track important security and business operations.
 */
@Entity
@Table(name = "evento_auditoria", indexes = {
    @Index(name = "idx_evento_auditoria_realm", columnList = "realm_id"),
    @Index(name = "idx_evento_auditoria_tipo", columnList = "tipo"),
    @Index(name = "idx_evento_auditoria_data_criacao", columnList = "data_criacao")
})
public class EventoAuditoria extends BaseEntity {
    
    @Enumerated(EnumType.STRING)
    @Column(name = "tipo", nullable = false)
    private TipoEventoAuditoria tipo;
    
    @Column(name = "usuario_id", length = 36)
    private UUID usuarioId;
    
    @Column(name = "usuario_email", length = 255)
    private String usuarioEmail;
    
    @ManyToOne
    @JoinColumn(name = "realm_id", referencedColumnName = "id")
    private Realm realm;
    
    @Column(name = "descricao", nullable = false, length = 1000)
    private String descricao;
    
    @Column(name = "ip_address", length = 45)
    private String ipAddress;
    
    @Column(name = "user_agent", length = 500)
    private String userAgent;
    
    @Column(name = "detalhes", columnDefinition = "TEXT")
    private String detalhes;
    
    @Column(name = "data_criacao", nullable = false, updatable = false)
    private LocalDateTime dataCriacao;
    
    /**
     * Default constructor required by JPA.
     */
    protected EventoAuditoria() {
    }
    
    /**
     * Creates a new EventoAuditoria.
     *
     * @param tipo         The type of audit event
     * @param descricao    The description of event
     * @param realm        The realm where event occurred (optional)
     * @param usuarioId    The user ID who performed action (optional)
     * @param usuarioEmail The user email who performed action (optional)
     * @param ipAddress    The IP address of origin
     * @param userAgent    The user agent of client
     * @param detalhes     Additional details in JSON format (optional)
     * @param dataCriacao  The timestamp of event
     */
    public EventoAuditoria(TipoEventoAuditoria tipo, String descricao, Realm realm, 
                          UUID usuarioId, String usuarioEmail, String ipAddress, 
                          String userAgent, String detalhes, LocalDateTime dataCriacao) {
        this.tipo = tipo;
        this.descricao = descricao;
        this.realm = realm;
        this.usuarioId = usuarioId;
        this.usuarioEmail = usuarioEmail;
        this.ipAddress = ipAddress;
        this.userAgent = userAgent;
        this.detalhes = detalhes;
        this.dataCriacao = dataCriacao;
    }
    
    // Getters
    
    public TipoEventoAuditoria getTipo() {
        return tipo;
    }
    
    public UUID getUsuarioId() {
        return usuarioId;
    }
    
    public String getUsuarioEmail() {
        return usuarioEmail;
    }
    
    public Realm getRealm() {
        return realm;
    }
    
    public String getDescricao() {
        return descricao;
    }
    
    public String getIpAddress() {
        return ipAddress;
    }
    
    public String getUserAgent() {
        return userAgent;
    }
    
    public String getDetalhes() {
        return detalhes;
    }
    
    public LocalDateTime getDataCriacao() {
        return dataCriacao;
    }
    
    // Setters (only for business logic use)
    
    public void setTipo(TipoEventoAuditoria tipo) {
        this.tipo = tipo;
    }
    
    public void setUsuarioId(UUID usuarioId) {
        this.usuarioId = usuarioId;
    }
    
    public void setUsuarioEmail(String usuarioEmail) {
        this.usuarioEmail = usuarioEmail;
    }
    
    public void setRealm(Realm realm) {
        this.realm = realm;
    }
    
    public void setDescricao(String descricao) {
        this.descricao = descricao;
    }
    
    public void setIpAddress(String ipAddress) {
        this.ipAddress = ipAddress;
    }
    
    public void setUserAgent(String userAgent) {
        this.userAgent = userAgent;
    }
    
    public void setDetalhes(String detalhes) {
        this.detalhes = detalhes;
    }
    
    public void setDataCriacao(LocalDateTime dataCriacao) {
        this.dataCriacao = dataCriacao;
    }
    
    @Override
    public String toString() {
        return "EventoAuditoria{" +
                "id=" + getId() +
                ", tipo=" + tipo +
                ", usuarioId=" + usuarioId +
                ", usuarioEmail='" + usuarioEmail + '\'' +
                ", realm=" + (realm != null ? realm.getId() : null) +
                ", descricao='" + descricao + '\'' +
                ", ipAddress='" + ipAddress + '\'' +
                ", userAgent='" + userAgent + '\'' +
                ", detalhes='" + detalhes + '\'' +
                ", dataCriacao=" + dataCriacao +
                '}';
    }
}
```
```java
package br.com.plataforma.conexaodigital.auditoria.domain.model.enums;

/**
 * Enum representing types of audit events in system.
 */
public enum TipoEventoAuditoria {
    
    LOGIN,
    LOGOUT,
    LOGIN_REMEMBER_ME,
    CRIACAO_USUARIO,
    ATUALIZACAO_USUARIO,
    BLOQUEIO_USUARIO,
    DESBLOQUEIO_USUARIO,
    RESET_SENHA_ADMIN,
    SOLICITACAO_RECUPERACAO_SENHA,
    REDEFINICAO_SENHA,
    CRIACAO_REALM,
    ATUALIZACAO_REALM,
    DESATIVACAO_REALM,
    REATIVACAO_REALM,
    CRIACAO_ROLE,
    ATUALIZACAO_ROLE,
    EXCLUSAO_ROLE,
    EMISSAO_TOKEN,
    REVOGACAO_TOKEN,
    REFRESH_TOKEN,
    AUTENTICACAO_CLIENT,
    GERACAO_CHAVE,
    ROTACAO_CHAVE_MANUAL,
    ROTACAO_CHAVE_AUTOMATICA,
    BOOTSTRAP_REALM_MASTER,
    BOOTSTRAP_ROLES,
    BOOTSTRAP_USUARIO_ADMIN,
    BOOTSTRAP_CHAVES_CRIPTOGRAFICAS
}
```
```java
package br.com.plataforma.conexaodigital.auditoria.domain.repository;

import br.com.plataforma.conexaodigital.auditoria.domain.model.EventoAuditoria;
import br.com.plataforma.conexaodigital.auditoria.domain.model.enums.TipoEventoAuditoria;
import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

/**
 * Repository for EventoAuditoria entities.
 */
@Repository
public interface EventoAuditoriaRepository extends JpaRepository<EventoAuditoria, UUID>, JpaSpecificationExecutor<EventoAuditoria> {
    List<EventoAuditoria> findByRealmOrderByDataCriacaoDesc(Realm realm);
    List<EventoAuditoria> findByTipoOrderByDataCriacaoDesc(TipoEventoAuditoria tipo);
    
    @Query("SELECT e FROM EventoAuditoria e WHERE e.dataCriacao < :dataLimite")
    List<EventoAuditoria> findByDataCriacaoBefore(@Param("dataLimite") LocalDateTime dataLimite);
    
    @Query("SELECT e.id FROM EventoAuditoria e WHERE e.dataCriacao < :dataLimite")
    List<UUID> findIdsByDataCriacaoBefore(@Param("dataLimite") LocalDateTime dataLimite, Pageable pageable);
    
    @Modifying
    @Query("DELETE FROM EventoAuditoria e WHERE e.id IN :ids")
    void deleteAllByIdInBatch(@Param("ids") List<UUID> ids);
}
```
```java
package br.com.plataforma.conexaodigital.auditoria.domain.service;

import br.com.plataforma.conexaodigital.auditoria.api.responses.EventoAuditoriaResponse;
import br.com.plataforma.conexaodigital.auditoria.domain.model.enums.TipoEventoAuditoria;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.UUID;

/**
 * Service interface for audit event operations.
 */
public interface AuditoriaService {
    void registrarEvento(TipoEventoAuditoria tipo, String descricao);
    void registrarEvento(TipoEventoAuditoria tipo, String descricao, UUID usuarioId, String usuarioEmail);
    void registrarEvento(TipoEventoAuditoria tipo, String descricao, UUID realmId);
    void registrarEvento(TipoEventoAuditoria tipo, String descricao, UUID usuarioId, String usuarioEmail, UUID realmId, Map<String, Object> detalhes);
    
    Page<EventoAuditoriaResponse> listar(UUID realmId, TipoEventoAuditoria tipo, 
                                                   String usuarioEmail, LocalDateTime dataInicio, LocalDateTime dataFim, 
                                                   Pageable pageable);
    
    EventoAuditoriaResponse buscarPorId(UUID id);
}
```
```java
package br.com.plataforma.conexaodigital.auditoria.domain.service.impl;

import br.com.plataforma.conexaodigital.auditoria.api.responses.EventoAuditoriaResponse;
import br.com.plataforma.conexaodigital.auditoria.domain.model.EventoAuditoria;
import br.com.plataforma.conexaodigital.auditoria.domain.model.enums.TipoEventoAuditoria;
import br.com.plataforma.conexaodigital.auditoria.domain.repository.EventoAuditoriaRepository;
import br.com.plataforma.conexaodigital.auditoria.domain.service.AuditoriaService;
import br.com.plataforma.conexaodigital.auditoria.infrastructure.persistence.EventoAuditoriaSpecification;
import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import java.time.LocalDateTime;
import java.util.Collections;
import java.util.Map;
import java.util.UUID;

/**
 * Implementation of AuditoriaService.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class AuditoriaServiceImpl implements AuditoriaService {
    
    private final EventoAuditoriaRepository repository;
    private final RealmRepository realmRepository;
    private final ObjectMapper objectMapper;
    
    @Override
    @Transactional
    public void registrarEvento(TipoEventoAuditoria tipo, String descricao) {
        registrarEvento(tipo, descricao, null, null);
    }
    
    @Override
    @Transactional
    public void registrarEvento(TipoEventoAuditoria tipo, String descricao, UUID usuarioId, String usuarioEmail) {
        registrarEvento(tipo, descricao, usuarioId, usuarioEmail, null, null);
    }
    
    @Override
    @Transactional
    public void registrarEvento(TipoEventoAuditoria tipo, String descricao, UUID realmId) {
        registrarEvento(tipo, descricao, null, null, realmId, null);
    }
    
    @Override
    @Transactional
    public void registrarEvento(TipoEventoAuditoria tipo, String descricao, UUID usuarioId, String usuarioEmail, UUID realmId, Map<String, Object> detalhes) {
        try {
            EventoAuditoria evento = new EventoAuditoria(
                tipo,
                descricao,
                obterRealm(realmId),
                usuarioId,
                usuarioEmail,
                obterIpAddress(),
                obterUserAgent(),
                serializarDetalhes(detalhes),
                LocalDateTime.now()
            );
            
            repository.save(evento);
            log.debug("Evento de auditoria registrado: {}", evento);
        } catch (Exception e) {
            log.error("Erro ao registrar evento de auditoria", e);
            // Erros no registro não devem quebrar a transação principal
        }
    }
    
    @Override
    @Transactional(readOnly = true)
    public Page<EventoAuditoriaResponse> listar(UUID realmId, TipoEventoAuditoria tipo, 
                                                   String usuarioEmail, LocalDateTime dataInicio, LocalDateTime dataFim, 
                                                   org.springframework.data.domain.Pageable pageable) {
        
        Specification<EventoAuditoria> spec = Specification.where(null);
        
        if (realmId != null) {
            spec = spec.and(EventoAuditoriaSpecification.comRealmId(realmId));
        }
        if (tipo != null) {
            spec = spec.and(EventoAuditoriaSpecification.comTipo(tipo));
        }
        if (usuarioEmail != null) {
            spec = spec.and(EventoAuditoriaSpecification.comUsuarioEmail(usuarioEmail));
        }
        if (dataInicio != null || dataFim != null) {
            spec = spec.and(EventoAuditoriaSpecification.comDataCriacaoEntre(dataInicio, dataFim));
        }
        
        Page<EventoAuditoria> eventos = repository.findAll(spec, pageable);
        
        return eventos.map(this::mapToResponse);
    }
    
    @Override
    @Transactional(readOnly = true)
    public EventoAuditoriaResponse buscarPorId(UUID id) {
        EventoAuditoria evento = repository.findById(id)
            .orElseThrow(() -> new EventoAuditoriaNotFoundException(id));
        return mapToResponse(evento);
    }
    
    private Realm obterRealm(UUID realmId) {
        if (realmId == null) {
            return null;
        }
        return realmRepository.findById(realmId).orElse(null);
    }
    
    private String obterIpAddress() {
        HttpServletRequest request = obterRequestAtual();
        if (request == null) {
            return "127.0.0.1"; // Default para processos internos (bootstrap/async)
        }
        
        String ipAddress = request.getHeader("X-Forwarded-For");
        if (ipAddress == null) {
            ipAddress = request.getHeader("X-Real-IP");
        }
        if (ipAddress == null) {
            ipAddress = request.getRemoteAddr();
        }
        return ipAddress;
    }
    
    private String obterUserAgent() {
        HttpServletRequest request = obterRequestAtual();
        if (request == null) {
            return "System/Internal"; // Default para processos internos
        }
        return request.getHeader("User-Agent");
    }
    
    private HttpServletRequest obterRequestAtual() {
        try {
            ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
            return attributes != null ? attributes.getRequest() : null;
        } catch (Exception e) {
            return null;
        }
    }
    
    private String serializarDetalhes(Map<String, Object> detalhes) {
        if (detalhes == null || detalhes.isEmpty()) {
            return null;
        }
        try {
            return objectMapper.writeValueAsString(detalhes);
        } catch (Exception e) {
            log.warn("Erro ao serializar detalhes do evento", e);
            return null;
        }
    }
    
    private EventoAuditoriaResponse mapToResponse(EventoAuditoria evento) {
        try {
            Map<String, Object> detalhes = Collections.emptyMap();
            if (evento.getDetalhes() != null) {
                detalhes = objectMapper.readValue(evento.getDetalhes(), Map.class);
            }
            
            return new EventoAuditoriaResponse(
                evento.getId(),
                evento.getTipo(),
                evento.getUsuarioId(),
                evento.getUsuarioEmail(),
                evento.getRealm() != null ? evento.getRealm().getId() : null,
                evento.getRealm() != null ? evento.getRealm().getNome() : null,
                evento.getDescricao(),
                evento.getIpAddress(),
                evento.getUserAgent(),
                detalhes,
                evento.getDataCriacao()
            );
        } catch (Exception e) {
            log.warn("Erro ao desserializar detalhes do evento", e);
            return new EventoAuditoriaResponse(
                evento.getId(),
                evento.getTipo(),
                evento.getUsuarioId(),
                evento.getUsuarioEmail(),
                evento.getRealm() != null ? evento.getRealm().getId() : null,
                evento.getRealm() != null ? evento.getRealm().getNome() : null,
                evento.getDescricao(),
                evento.getIpAddress(),
                evento.getUserAgent(),
                Collections.emptyMap(),
                evento.getDataCriacao()
            );
        }
    }
    
    /**
     * Exception thrown when audit event is not found.
     */
    public static class EventoAuditoriaNotFoundException extends RuntimeException {
        public EventoAuditoriaNotFoundException(UUID id) {
            super("Evento de auditoria não encontrado: " + id);
        }
    }
}
```
```java
package br.com.plataforma.conexaodigital.auditoria.infrastructure.persistence;

import br.com.plataforma.conexaodigital.auditoria.domain.model.EventoAuditoria;
import br.com.plataforma.conexaodigital.auditoria.domain.model.enums.TipoEventoAuditoria;
import org.springframework.data.jpa.domain.Specification;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * JPA Specification for dynamic filtering of EventoAuditoria.
 */
public class EventoAuditoriaSpecification {
    
    public static Specification<EventoAuditoria> comRealmId(UUID realmId) {
        return (root, query, cb) -> 
            realmId == null ? null : cb.equal(root.get("realm").get("id"), realmId);
    }
    
    public static Specification<EventoAuditoria> comTipo(TipoEventoAuditoria tipo) {
        return (root, query, cb) -> 
            tipo == null ? null : cb.equal(root.get("tipo"), tipo);
    }
    
    public static Specification<EventoAuditoria> comUsuarioEmail(String usuarioEmail) {
        return (root, query, cb) -> 
            usuarioEmail == null ? null : cb.like(cb.lower(root.get("usuarioEmail")), "%" + usuarioEmail.toLowerCase() + "%");
    }
    
    public static Specification<EventoAuditoria> comDataCriacaoEntre(LocalDateTime inicio, LocalDateTime fim) {
        return (root, query, cb) -> {
            if (inicio == null && fim == null) return null;
            if (inicio == null) return cb.lessThanOrEqualTo(root.get("dataCriacao"), fim);
            if (fim == null) return cb.greaterThanOrEqualTo(root.get("dataCriacao"), inicio);
            return cb.between(root.get("dataCriacao"), inicio, fim);
        };
    }
}
```
```java
package br.com.plataforma.conexaodigital.auditoria.infrastructure.scheduler;

import br.com.plataforma.conexaodigital.auditoria.domain.repository.EventoAuditoriaRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.PageRequest;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

/**
 * Scheduler for cleanup of old audit events based on retention policy.
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class AuditoriaLimpezaScheduler {
    
    private final EventoAuditoriaRepository repository;
    
    @Value("${auditoria.retencao.dias:90}")
    private int diasRetencao;
    
    @Value("${auditoria.limpeza.batch.size:1000}")
    private int batchSize;
    
    @Scheduled(cron = "${auditoria.limpeza.cron:0 0 0 * * ?}")
    @Transactional
    public void limparEventosAntigos() {
        LocalDateTime dataLimite = LocalDateTime.now().minusDays(diasRetencao);
        
        log.info("Iniciando limpeza de eventos de auditoria anteriores a {}", dataLimite);
        
        int totalRemovidos = 0;
        List<UUID> eventosParaRemover;
        
        do {
            eventosParaRemover = repository.findIdsByDataCriacaoBefore(dataLimite, PageRequest.of(0, batchSize));
            
            if (!eventosParaRemover.isEmpty()) {
                repository.deleteAllByIdInBatch(eventosParaRemover);
                totalRemovidos += eventosParaRemover.size();
                log.info("Removidos {} eventos de auditoria (total: {})", eventosParaRemover.size(), totalRemovidos);
            }
        } while (eventosParaRemover.size() == batchSize);
        
        log.info("Limpeza de eventos de auditoria concluída. Total removido: {}", totalRemovidos);
    }
}
```
```java
package br.com.plataforma.conexaodigital.bootstrap.api.controller;

import br.com.plataforma.conexaodigital.bootstrap.api.dto.BootstrapStatusResponse;
import br.com.plataforma.conexaodigital.bootstrap.domain.dto.BootstrapStatus;
import br.com.plataforma.conexaodigital.bootstrap.domain.service.BootstrapService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * Controller para o endpoint de status de bootstrap.
 * Fornece informações sobre o status de execução do bootstrap do sistema.
 */
@RestController
@RequestMapping("/api/v1/bootstrap")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Bootstrap", description = "Operações de bootstrap do sistema")
public class BootstrapController {

    private final BootstrapService bootstrapService;

    /**
     * Obtém o status atual do processo de bootstrap do sistema.
     * Endpoint público que não requer autenticação.
     *
     * @return BootstrapStatusResponse com informações sobre o status do bootstrap
     */
    @GetMapping(value = "/status", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(
            summary = "Status do bootstrap",
            description = """
                    Retorna o status de execução do bootstrap do sistema.
                    O endpoint é público e não requer autenticação.
                    Permite verificar se o Realm Master, Roles Padrão, Usuário
                    Administrador e Chaves Criptográficas foram criados com sucesso.
                    """
    )
    @ApiResponses({
            @ApiResponse(
                    responseCode = "200",
                    description = "Status do bootstrap retornado com sucesso",
                    content = @Content(schema = @Schema(implementation = BootstrapStatusResponse.class))
            )
    })
    public ResponseEntity<BootstrapStatusResponse> obterStatus() {
        log.info("Requisição de status do bootstrap recebida");

        BootstrapStatus status = bootstrapService.obterStatus();

        boolean concluido = status.dataUltimaExecucao() != null
                && status.realmMasterCriado()
                && status.rolesCriadas()
                && status.usuarioAdminCriado()
                && status.oauth2ClientesCriados()
                && status.chavesCriadas();

        BootstrapStatusResponse response = new BootstrapStatusResponse(
                status.realmMasterCriado(),
                status.rolesCriadas(),
                status.usuarioAdminCriado(),
                status.oauth2ClientesCriados(),
                status.chavesCriadas(),
                status.dataUltimaExecucao(),
                concluido
        );

        log.info("Status do bootstrap retornado: concluido={}", concluido);

        return ResponseEntity.ok(response);
    }
}

```
```java
package br.com.plataforma.conexaodigital.bootstrap.api.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import io.swagger.v3.oas.annotations.media.Schema;

import java.time.LocalDateTime;

/**
 * DTO representing the bootstrap status response.
 * Contains information about the bootstrap process status.
 */
@Schema(description = "Status do processo de bootstrap do sistema")
public record BootstrapStatusResponse(

        @Schema(description = "Indica se o Realm Master foi criado", example = "true")
        boolean realmMasterCriado,

        @Schema(description = "Indica se as Roles Padrão foram criadas", example = "true")
        boolean rolesCriadas,

        @Schema(description = "Indica se o Usuário Administrador foi criado", example = "true")
        boolean usuarioAdminCriado,

        @Schema(description = "Indica se os Clientes OAuth2 foram criados", example = "true")
        boolean oauth2ClientesCriados,

        @Schema(description = "Indica se as Chaves Criptográficas foram criadas", example = "true")
        boolean chavesCriadas,

        @Schema(description = "Data e hora da última execução do bootstrap", example = "2025-12-24T10:30:00")
        @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss")
        LocalDateTime dataUltimaExecucao,

        @Schema(
                description = "Indica se o bootstrap foi concluído com sucesso. "
                        + "É true apenas se todos os componentes foram criados e "
                        + "dataUltimaExecucao não é nula",
                example = "true"
        )
        boolean concluido

) {}

```
```java
package br.com.plataforma.conexaodigital.bootstrap.config;

import br.com.plataforma.conexaodigital.bootstrap.domain.service.BootstrapService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;

/**
 * Configuration class for the bootstrap process.
 * Configures the application listener that triggers the bootstrap
 * when the application is ready.
 */
@Slf4j
@Configuration
@ConditionalOnProperty(name = "bootstrap.habilitado", havingValue = "true", matchIfMissing = true)
@RequiredArgsConstructor
public class BootstrapConfig {
    
    private final BootstrapService bootstrapService;
    
    /**
     * Creates an application listener that executes the bootstrap process
     * when the application is ready.
     *
     * @return the application listener
     */
    @Bean
    @Order(1) // Ensure bootstrap runs before other listeners
    public ApplicationListener<ApplicationReadyEvent> bootstrapApplicationListener() {
        return event -> {
            log.info("Application ready event received. Starting bootstrap process...");
            bootstrapService.executarBootstrap();
        };
    }
}
```
```java
package br.com.plataforma.conexaodigital.bootstrap.domain.dto;

import java.time.LocalDateTime;

/**
 * DTO representing status of bootstrap process.
 */
public record BootstrapStatus(
    boolean realmMasterCriado,
    boolean rolesCriadas,
    boolean usuarioAdminCriado,
    boolean oauth2ClientesCriados,
    boolean chavesCriadas,
    LocalDateTime dataUltimaExecucao
) {

    /**
     * Returns true if all bootstrap steps are completed.
     */
    public boolean bootstrapConcluido() {
        return realmMasterCriado &&
               rolesCriadas &&
               usuarioAdminCriado &&
               oauth2ClientesCriados &&
               chavesCriadas;
    }
}
```
```java
package br.com.plataforma.conexaodigital.bootstrap.domain.exception;

/**
 * Exception thrown when an error occurs during the bootstrap process.
 */
public class BootstrapException extends RuntimeException {

    public BootstrapException(String message) {
        super(message);
    }

    public BootstrapException(String message, Throwable cause) {
        super(message, cause);
    }
}
```
```java
package br.com.plataforma.conexaodigital.bootstrap.domain.service;

import br.com.plataforma.conexaodigital.bootstrap.domain.dto.BootstrapStatus;

/**
 * Service interface responsible for executing the system bootstrap process.
 */
public interface BootstrapService {
    
    /**
     * Executes the bootstrap process to initialize essential system data.
     * The process is idempotent and will only create data if it doesn't already exist.
     *
     * @throws BootstrapException if an error occurs during bootstrap
     */
    void executarBootstrap();
    
    /**
     * Returns the current status of the bootstrap process.
     *
     * @return the bootstrap status
     */
    BootstrapStatus obterStatus();
}
```
```java
package br.com.plataforma.conexaodigital.bootstrap.domain.service;

/**
 * Service interface responsible for bootstrapping cryptographic keys.
 */
public interface ChaveBootstrapService {
    
    /**
     * Creates cryptographic keys for all realms if they don't already exist.
     */
    void criarChavesParaTodosRealms();
    
    /**
     * Checks if cryptographic keys have been created.
     *
     * @return true if keys exist, false otherwise
     */
    boolean chavesCriadas();
}
```
```java
package br.com.plataforma.conexaodigital.bootstrap.domain.service;

/**
 * Service interface responsible for bootstrapping OAuth2 clients.
 */
public interface OAuth2ClientBootstrapService {

    /**
     * Creates default OAuth2 clients if they don't already exist.
     */
    void criarClientesOAuth2();

    /**
     * Checks if default OAuth2 clients have been created.
     *
     * @return true if OAuth2 clients exist, false otherwise
     */
    boolean clientesOAuth2Criados();
}
```
```java
package br.com.plataforma.conexaodigital.bootstrap.domain.service;

import br.com.plataforma.conexaodigital.realm.domain.model.Realm;

/**
 * Service interface responsible for bootstrapping the master realm.
 */
public interface RealmBootstrapService {
    
    /**
     * Creates the master realm if it doesn't already exist.
     */
    void criarRealmMaster();
    
    /**
     * Checks if the master realm has been created.
     *
     * @return true if the master realm exists, false otherwise
     */
    boolean realmMasterCriado();
    
    /**
     * Retrieves the master realm.
     *
     * @return the master realm
     * @throws br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmNotFoundException if master realm doesn't exist
     */
    Realm obterRealmMaster();
}
```
```java
package br.com.plataforma.conexaodigital.bootstrap.domain.service;

/**
 * Service interface responsible for bootstrapping default roles.
 */
public interface RoleBootstrapService {
    
    /**
     * Creates default roles if they don't already exist.
     */
    void criarRolesPadrao();
    
    /**
     * Checks if default roles have been created.
     *
     * @return true if default roles exist, false otherwise
     */
    boolean rolesCriadas();
}
```
```java
package br.com.plataforma.conexaodigital.bootstrap.domain.service;

/**
 * Service interface responsible for bootstrapping the admin user.
 */
public interface UsuarioBootstrapService {
    
    /**
     * Creates the admin user if it doesn't already exist.
     */
    void criarUsuarioAdmin();
    
    /**
     * Checks if the admin user has been created.
     *
     * @return true if the admin user exists, false otherwise
     */
    boolean usuarioAdminCriado();
}
```
```java
package br.com.plataforma.conexaodigital.bootstrap.domain.service.impl;

import br.com.plataforma.conexaodigital.bootstrap.domain.dto.BootstrapStatus;
import br.com.plataforma.conexaodigital.bootstrap.domain.exception.BootstrapException;
import br.com.plataforma.conexaodigital.bootstrap.domain.service.BootstrapService;
import br.com.plataforma.conexaodigital.bootstrap.domain.service.ChaveBootstrapService;
import br.com.plataforma.conexaodigital.bootstrap.domain.service.OAuth2ClientBootstrapService;
import br.com.plataforma.conexaodigital.bootstrap.domain.service.RealmBootstrapService;
import br.com.plataforma.conexaodigital.bootstrap.domain.service.RoleBootstrapService;
import br.com.plataforma.conexaodigital.bootstrap.domain.service.UsuarioBootstrapService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;

/**
 * Implementation of the BootstrapService responsible for orchestrating
 * the system bootstrap process.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class BootstrapServiceImpl implements BootstrapService {

    private final RealmBootstrapService realmBootstrapService;
    private final RoleBootstrapService roleBootstrapService;
    private final UsuarioBootstrapService usuarioBootstrapService;
    private final ChaveBootstrapService chaveBootstrapService;
    private final OAuth2ClientBootstrapService oauth2ClientBootstrapService;

    private LocalDateTime dataUltimaExecucao;

    @Override
    @Transactional
    public void executarBootstrap() {
        log.info("========================================");
        log.info("Iniciando bootstrap do sistema");
        log.info("========================================");

        try {
            // 1. Criar Realm Master
            log.info("Executando bootstrap do Realm Master");
            realmBootstrapService.criarRealmMaster();

            // 2. Criar Roles Padrão
            log.info("Executando bootstrap das Roles Padrão");
            roleBootstrapService.criarRolesPadrao();

            // 3. Criar Usuário Administrador
            log.info("Executando bootstrap do Usuário Administrador");
            usuarioBootstrapService.criarUsuarioAdmin();

            // 4. Criar Clientes OAuth2
            log.info("Executando bootstrap dos Clientes OAuth2");
            oauth2ClientBootstrapService.criarClientesOAuth2();

            // 5. Criar Chaves Criptográficas
            log.info("Executando bootstrap das Chaves Criptográficas");
            chaveBootstrapService.criarChavesParaTodosRealms();

            dataUltimaExecucao = LocalDateTime.now();

            log.info("========================================");
            log.info("Bootstrap do sistema concluído com sucesso");
            log.info("========================================");
        } catch (Exception e) {
            log.error("Erro durante bootstrap do sistema", e);
            throw new BootstrapException("Erro durante bootstrap do sistema", e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public BootstrapStatus obterStatus() {
        try {
            return new BootstrapStatus(
                realmBootstrapService.realmMasterCriado(),
                roleBootstrapService.rolesCriadas(),
                usuarioBootstrapService.usuarioAdminCriado(),
                oauth2ClientBootstrapService.clientesOAuth2Criados(),
                chaveBootstrapService.chavesCriadas(),
                dataUltimaExecucao
            );
        } catch (Exception e) {
            log.warn("Erro ao verificar status do bootstrap. Retornando status incompleto.", e);
            return new BootstrapStatus(
                false, false, false, false, false, dataUltimaExecucao
            );
        }
    }
}
```
```java
package br.com.plataforma.conexaodigital.bootstrap.domain.service.impl;

import java.util.List;
import java.util.UUID;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.plataforma.conexaodigital.bootstrap.domain.service.ChaveBootstrapService;
import br.com.plataforma.conexaodigital.chave.domain.repository.ChaveCriptograficaRepository;
import br.com.plataforma.conexaodigital.chave.domain.service.ChaveService;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Implementation of ChaveBootstrapService responsible for creating
 * cryptographic keys for all realms during system bootstrap.
 * 
 * This service delegates actual key generation to ChaveService
 * and only handles the bootstrap orchestration logic.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class ChaveBootstrapServiceImpl implements ChaveBootstrapService {

    private final ChaveService chaveService;
    private final ChaveCriptograficaRepository chaveRepository;
    private final RealmRepository realmRepository;

    @Override
    @Transactional
    public void criarChavesParaTodosRealms() {
        log.info("Iniciando bootstrap de chaves criptográficas...");

        List<UUID> realmIds = realmRepository.findAllIds();

        if (realmIds.isEmpty()) {
            log.warn("Nenhum realm encontrado para criar chaves. Pulando bootstrap de chaves.");
            return;
        }

        log.info("Encontrados {} realms para criar chaves", realmIds.size());

        for (UUID realmId : realmIds) {
            try {
                // Verificar se já existe chave ativa para este realm
                if (chaveRepository.existsByRealmIdAndStatus(realmId,
                        br.com.plataforma.conexaodigital.chave.domain.model.StatusChave.ATIVA)) {
                    log.info("Realm {} já possui chave ativa. Pulando criação.", realmId);
                    continue;
                }

                // Verificar se realm existe antes de criar chave
                if (!realmRepository.existsById(realmId)) {
                    log.warn("Realm {} não encontrado. Pulando criação de chave.", realmId);
                    continue;
                }

                log.info("Criando chave para realm: {}", realmId);
                chaveService.gerarChave(realmId);
                log.info("Chave criada com sucesso para realm: {}", realmId);

            } catch (Exception e) {
                log.error("Erro ao criar chave para realm: {}", realmId, e);
                // Continue com outros realms mesmo se um falhar
            }
        }

        log.info("Bootstrap de chaves criptográficas concluído.");
    }

    @Override
    @Transactional(readOnly = true)
    public boolean chavesCriadas() {
        try {
            List<UUID> realmIds = realmRepository.findAllIds();

            if (realmIds.isEmpty()) {
                log.debug("Nenhum realm encontrado para verificar chaves.");
                return false;
            }

            // Verificar se todos os realms têm pelo menos uma chave (ativa ou inativa)
            long realmsComChaves = realmIds.stream()
                    .mapToLong(realmId -> chaveRepository.existsByRealmId(realmId) ? 1 : 0)
                    .sum();

            boolean todasTemChaves = realmsComChaves >= realmIds.size();
            log.debug("Realms com chaves: {}/{}", realmsComChaves, realmIds.size());

            return todasTemChaves;

        } catch (Exception e) {
            log.error("Erro ao verificar se chaves foram criadas", e);
            return false;
        }
    }
}
```
```java
package br.com.plataforma.conexaodigital.bootstrap.domain.service.impl;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.plataforma.conexaodigital.bootstrap.domain.service.OAuth2ClientBootstrapService;
import br.com.plataforma.conexaodigital.oauth2.domain.model.OAuth2Client;
import br.com.plataforma.conexaodigital.oauth2.domain.repository.OAuth2ClientRepository;
import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Implementation of OAuth2ClientBootstrapService responsible for creating
 * default OAuth2 clients during system bootstrap.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class OAuth2ClientBootstrapServiceImpl implements OAuth2ClientBootstrapService {

    private final OAuth2ClientRepository oauth2ClientRepository;
    private final RealmRepository realmRepository;
    private final PasswordEncoder passwordEncoder;

    @Value("${bootstrap.oauth2.client.id:conexaoauth-client}")
    private String clientId;

    @Value("${bootstrap.oauth2.client.secret:conexaoauth-secret}")
    private String clientSecret;

    @Value("${bootstrap.oauth2.client.name:ConexaoAuth Client}")
    private String clientName;

    private static final String NOME_REALM_MASTER = "master";

    @Override
    @Transactional
    public void criarClientesOAuth2() {
        log.info("Iniciando bootstrap de clientes OAuth2...");

        // Verificar se já existe cliente com o ID padrão
        if (oauth2ClientRepository.existsByClientId(clientId)) {
            log.info("Cliente OAuth2 com ID '{}' já existe, ignorando criação", clientId);
            return;
        }

        // Obter Realm Master
        Realm realmMaster = realmRepository.findByNomeIgnoreCase(NOME_REALM_MASTER)
                .orElseThrow(() -> new IllegalStateException(
                        "Realm Master não encontrado. Execute o bootstrap de realms primeiro."));

        log.info("Criando cliente OAuth2 padrão: {}", clientId);

        OAuth2Client oauth2Client = OAuth2Client.builder()
                .clientId(clientId)
                .clientSecret(passwordEncoder.encode(clientSecret))
                .realm(realmMaster)
                .ativo(true)
                .empresaId("conexaoauth")
                .tenantId("conexaoauth-tenant")
                .descricao(clientName)
                .dataCriacao(java.time.LocalDateTime.now())
                .dataAtualizacao(java.time.LocalDateTime.now())
                .build();

        // Adicionar scopes padrão
        oauth2Client.addScope("read");
        oauth2Client.addScope("write");
        oauth2Client.addScope("openid");
        oauth2Client.addScope("profile");

        OAuth2Client savedClient = oauth2ClientRepository.save(oauth2Client);

        log.info("Cliente OAuth2 criado com sucesso: {}", savedClient.getClientId());
    }

    @Override
    @Transactional(readOnly = true)
    public boolean clientesOAuth2Criados() {
        return oauth2ClientRepository.existsByClientId(clientId);
    }
}
```
```java
package br.com.plataforma.conexaodigital.bootstrap.domain.service.impl;

import br.com.plataforma.conexaodigital.auditoria.domain.model.enums.TipoEventoAuditoria;
import br.com.plataforma.conexaodigital.auditoria.domain.service.AuditoriaService;
import br.com.plataforma.conexaodigital.bootstrap.domain.service.RealmBootstrapService;
import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import br.com.plataforma.conexaodigital.realm.domain.model.StatusRealm;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * Implementation of RealmBootstrapService responsible for creating
 * the master realm during system bootstrap.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class RealmBootstrapServiceImpl implements RealmBootstrapService {
    
    private final RealmRepository repository;
    private final AuditoriaService auditoriaService;
    
    private static final String NOME_REALM_MASTER = "master";
    
    @Override
    @Transactional
    public void criarRealmMaster() {
        if (repository.existsByNomeIgnoreCase(NOME_REALM_MASTER)) {
            log.info("Realm Master já existe, ignorando criação");
            return;
        }
        
        log.info("Criando Realm Master: {}", NOME_REALM_MASTER);

        Realm realmMaster = new Realm(NOME_REALM_MASTER, StatusRealm.ATIVO);
        realmMaster.setMaster(true); // Define como realm master
        realmMaster = repository.save(realmMaster);
        
        auditoriaService.registrarEvento(
            TipoEventoAuditoria.BOOTSTRAP_REALM_MASTER,
            "Realm Master criado via bootstrap: " + realmMaster.getId()
        );
        
        log.info("Realm Master criado com sucesso: {}", realmMaster.getId());
    }
    
    @Override
    @Transactional(readOnly = true)
    public boolean realmMasterCriado() {
        return repository.existsByNomeIgnoreCase(NOME_REALM_MASTER);
    }
    
    @Override
    @Transactional(readOnly = true)
    public Realm obterRealmMaster() {
        return repository.findByNomeIgnoreCase(NOME_REALM_MASTER)
            .orElseThrow(() -> new RealmNotFoundException("Realm Master não encontrado"));
    }
}
```
```java
package br.com.plataforma.conexaodigital.bootstrap.domain.service.impl;

import br.com.plataforma.conexaodigital.auditoria.domain.model.enums.TipoEventoAuditoria;
import br.com.plataforma.conexaodigital.auditoria.domain.service.AuditoriaService;
import br.com.plataforma.conexaodigital.bootstrap.domain.service.RoleBootstrapService;
import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import br.com.plataforma.conexaodigital.role.domain.model.Role;
import br.com.plataforma.conexaodigital.role.domain.repository.RoleRepository;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

/**
 * Implementation of RoleBootstrapService responsible for creating
 * default roles during system bootstrap.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class RoleBootstrapServiceImpl implements RoleBootstrapService {
    
    private final RoleRepository repository;
    private final RealmRepository realmRepository;
    private final AuditoriaService auditoriaService;
    
    private static final List<String> ROLES_PADRAO = List.of("ADMIN", "USER", "SERVICE");
    private static final String NOME_REALM_MASTER = "master";
    
    @Override
    @Transactional
    public void criarRolesPadrao() {
        Optional<Realm> realmMasterOpt = realmRepository.findByNomeIgnoreCase(NOME_REALM_MASTER);
        
        if (realmMasterOpt.isEmpty()) {
            log.warn("Realm Master não encontrado. Pulando criação de roles.");
            return;
        }
        
        Realm realmMaster = realmMasterOpt.get();
        
        for (String nomeRole : ROLES_PADRAO) {
            criarRoleSeNaoExistir(nomeRole, realmMaster);
        }
    }
    
    private void criarRoleSeNaoExistir(String nomeRole, Realm realm) {
        if (repository.existsByNomeAndRealmId(nomeRole, realm.getId())) {
            log.info("Role {} já existe no Realm Master, ignorando criação", nomeRole);
            return;
        }
        
        log.info("Criando role padrão: {} no Realm Master", nomeRole);
        
        Role role = new Role(nomeRole, "Role padrão: " + nomeRole, realm, true);
        role = repository.save(role);
        
        auditoriaService.registrarEvento(
            TipoEventoAuditoria.BOOTSTRAP_ROLES,
            "Role padrão criada via bootstrap: " + role.getNome(),
            null, null, realm.getId(), null
        );
        
        log.info("Role padrão criada com sucesso: {}", role.getId());
    }
    
    @Override
    @Transactional(readOnly = true)
    public boolean rolesCriadas() {
        Optional<Realm> realmMasterOpt = realmRepository.findByNomeIgnoreCase(NOME_REALM_MASTER);
        
        if (realmMasterOpt.isEmpty()) {
            log.debug("Realm Master não encontrado. Roles não podem ser verificadas.");
            return false;
        }
        
        Realm realmMaster = realmMasterOpt.get();
        
        for (String nomeRole : ROLES_PADRAO) {
            if (!repository.existsByNomeAndRealmId(nomeRole, realmMaster.getId())) {
                return false;
            }
        }
        
        return true;
    }
}
```
```java
package br.com.plataforma.conexaodigital.bootstrap.domain.service.impl;

import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.plataforma.conexaodigital.auditoria.domain.model.enums.TipoEventoAuditoria;
import br.com.plataforma.conexaodigital.auditoria.domain.service.AuditoriaService;
import br.com.plataforma.conexaodigital.bootstrap.domain.service.UsuarioBootstrapService;
import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import br.com.plataforma.conexaodigital.usuario.domain.model.Usuario;
import br.com.plataforma.conexaodigital.usuario.domain.model.enums.StatusUsuario;
import br.com.plataforma.conexaodigital.usuario.domain.repository.UsuarioRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Implementation of UsuarioBootstrapService responsible for creating
 * default admin user during system bootstrap.
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class UsuarioBootstrapServiceImpl implements UsuarioBootstrapService {

    private final UsuarioRepository usuarioRepository;
    private final RealmRepository realmRepository;
    private final AuditoriaService auditoriaService;
    private final PasswordEncoder passwordEncoder;

    @Value("${bootstrap.admin.username:Admin}")
    private String adminUsername;

    @Value("${bootstrap.admin.email:admin@conexaoauth.com}")
    private String adminEmail;

    @Value("${bootstrap.admin.password:Admin@123}")
    private String adminPassword;

    private static final String NOME_REALM_MASTER = "master";

    @Override
    @Transactional
    public void criarUsuarioAdmin() {
        // Primeiro verificar se já existe usuário admin
        if (usuarioRepository.existsByEmailIgnoreCase(adminEmail)) {
            log.info("Usuário admin já existe, ignorando criação");
            return;
        }

        // Obter ou criar Realm Master
        Realm realmMaster = realmRepository.findByNomeIgnoreCase(NOME_REALM_MASTER)
                .orElseGet(() -> {
                    log.warn("Realm Master não encontrado durante bootstrap de usuário. Isso não deveria acontecer.");
                    return null; // Vai falhar com NullPointerException se chamado
                });

        if (realmMaster == null) {
            log.error("Não é possível criar usuário admin sem Realm Master");
            return;
        }

        log.info("Criando usuário administrador padrão: {}", adminEmail);

        Usuario adminUsuario = Usuario.builder()
                .id(UUID.randomUUID())
                .email(adminEmail)
                .nome("Administrador do Sistema")
                .senha(passwordEncoder.encode(adminPassword))
                .status(StatusUsuario.ATIVO)
                .dataCriacao(java.time.LocalDateTime.now())
                .cpfOrCnpj("123456789")
                .dataUltimoLogin(java.time.LocalDateTime.now())
                .dataAtualizacao(java.time.LocalDateTime.now())
                .version(0L)
                .realmId(realmMaster.getId())
                .empresaId("conexaoauth")
                .tenantId("default")
                .build();

        adminUsuario = usuarioRepository.save(adminUsuario);

        Map<String, Object> detalhes = new HashMap<>();
        detalhes.put("usuarioId", adminUsuario.getId());
        detalhes.put("usuarioEmail", adminUsuario.getEmail());

        auditoriaService.registrarEvento(
                TipoEventoAuditoria.BOOTSTRAP_USUARIO_ADMIN,
                "Usuário admin criado via bootstrap: " + adminUsuario.getEmail(),
                null, null, realmMaster.getId(), detalhes);

        log.info("Usuário administrador criado com sucesso: {}", adminUsuario.getEmail());
    }

    @Override
    @Transactional(readOnly = true)
    public boolean usuarioAdminCriado() {
        return usuarioRepository.existsByEmailIgnoreCase(adminEmail);
    }
}
```
```java
package br.com.plataforma.conexaodigital.chave.api.controller;

import br.com.plataforma.conexaodigital.chave.api.responses.ChaveResponse;
import br.com.plataforma.conexaodigital.chave.api.responses.RotacaoChaveResponse;
import br.com.plataforma.conexaodigital.chave.domain.model.StatusChave;
import br.com.plataforma.conexaodigital.chave.domain.model.TipoRotacao;
import br.com.plataforma.conexaodigital.chave.domain.service.ChaveService;
import br.com.plataforma.conexaodigital.chave.domain.service.RotacaoChaveService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.constraints.NotNull;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

/**
 * REST controller for cryptographic key management operations.
 * Provides endpoints for key generation, rotation, and consultation.
 */
@RestController
@RequestMapping("/api/v1/chaves")
@RequiredArgsConstructor
@Validated
@Slf4j
@Tag(name = "Gerenciamento de Chaves Criptográficas", description = "APIs para gerenciamento de chaves RSA por realm")
public class ChaveController {

    private final ChaveService chaveService;
    private final RotacaoChaveService rotacaoService;

    /**
     * Generates a new RSA-2048 key pair for a realm.
     *
     * @param realmId The realm ID to generate keys for
     * @return ResponseEntity with the generated key information
     */
    @PostMapping("/{realmId}")
    @Operation(
        summary = "Gerar par de chaves RSA para realm",
        description = "Gera um novo par de chaves RSA-2048 para um realm específico. A chave pública não é criptografada, enquanto a chave privada é criptografada com AES-128 antes de ser armazenada."
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "201",
            description = "Chave gerada com sucesso",
            content = @Content(
                mediaType = "application/json",
                schema = @Schema(implementation = ChaveResponse.class)
            )
        ),
        @ApiResponse(
            responseCode = "404",
            description = "Realm não encontrado",
            content = @Content
        ),
        @ApiResponse(
            responseCode = "500",
            description = "Erro interno ao gerar chave",
            content = @Content
        )
    })
    public ResponseEntity<ChaveResponse> gerarChave(
            @Parameter(
                description = "ID do realm para gerar as chaves",
                required = true,
                example = "550e8400-e29b-41d4-a716-446655440000"
            )
            @PathVariable
            @NotNull(message = "ID do realm é obrigatório")
            UUID realmId) {

        log.info("Recebida requisição para gerar chave para realm: {}", realmId);

        try {
            ChaveResponse response = chaveService.gerarChave(realmId);
            
            log.info("Chave gerada com sucesso: {} para realm: {}", response.id(), realmId);
            
            return ResponseEntity.status(HttpStatus.CREATED).body(response);

        } catch (Exception e) {
            log.error("Erro ao gerar chave para realm: {}", realmId, e);
            throw e; // Will be handled by global exception handler
        }
    }

    /**
     * Lists all cryptographic keys for a realm with optional status filter.
     *
     * @param realmId The realm ID to list keys for
     * @param status  Optional status filter (ATIVA, INATIVA, EXPIRADA)
     * @return ResponseEntity with list of keys
     */
    @GetMapping("/{realmId}")
    @Operation(
        summary = "Listar chaves do realm",
        description = "Lista todas as chaves de um realm, com filtros opcionais por status. Inclui próxima rotação automática prevista."
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "200",
            description = "Lista de chaves retornada com sucesso",
            content = @Content(
                mediaType = "application/json",
                array = @ArraySchema(schema = @Schema(implementation = ChaveResponse.class))
            )
        ),
        @ApiResponse(
            responseCode = "404",
            description = "Realm não encontrado",
            content = @Content
        )
    })
    public ResponseEntity<List<ChaveResponse>> listar(
            @Parameter(
                description = "ID do realm para listar as chaves",
                required = true,
                example = "550e8400-e29b-41d4-a716-446655440000"
            )
            @PathVariable
            @NotNull(message = "ID do realm é obrigatório")
            UUID realmId,
            @Parameter(
                description = "Filtro opcional por status da chave",
                example = "ATIVA"
            )
            @RequestParam(required = false) StatusChave status) {

        log.debug("Listando chaves para realm: {} com status: {}", realmId, status);

        List<ChaveResponse> chaves = chaveService.listar(realmId, status);

        log.debug("Encontradas {} chaves para realm: {}", chaves.size(), realmId);

        return ResponseEntity.ok(chaves);
    }

    /**
     * Finds the active key for a realm.
     *
     * @param realmId The realm ID to find active key for
     * @return ResponseEntity with the active key
     */
    @GetMapping("/{realmId}/ativa")
    @Operation(
        summary = "Buscar chave ativa de um realm",
        description = "Retorna a chave atualmente ativa para um realm específico. Esta é a chave usada para assinar novos tokens JWT."
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "200",
            description = "Chave ativa encontrada com sucesso",
            content = @Content(
                mediaType = "application/json",
                schema = @Schema(implementation = ChaveResponse.class)
            )
        ),
        @ApiResponse(
            responseCode = "404",
            description = "Nenhuma chave ativa encontrada para o realm",
            content = @Content
        )
    })
    public ResponseEntity<ChaveResponse> buscarChaveAtiva(
            @Parameter(
                description = "ID do realm para buscar a chave ativa",
                required = true,
                example = "550e8400-e29b-41d4-a716-446655440000"
            )
            @PathVariable
            @NotNull(message = "ID do realm é obrigatório")
            UUID realmId) {

        log.debug("Buscando chave ativa para realm: {}", realmId);

        ChaveResponse chave = chaveService.buscarChaveAtiva(realmId);

        log.debug("Chave ativa encontrada: {} para realm: {}", chave.id(), realmId);

        return ResponseEntity.ok(chave);
    }

    /**
     * Finds keys that can validate tokens for a realm.
     *
     * @param realmId The realm ID to find validation keys for
     * @return ResponseEntity with list of validation keys
     */
    @GetMapping("/{realmId}/validacao")
    @Operation(
        summary = "Buscar chaves para validação de tokens",
        description = "Retorna todas as chaves que podem validar tokens para um realm específico (chaves ATIVAS e INATIVAS, no grace period). Usado para validação de tokens JWT."
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "200",
            description = "Lista de chaves de validação retornada com sucesso",
            content = @Content(
                mediaType = "application/json",
                schema = @Schema(implementation = ChaveResponse.class)
            )
        )
    })
    public ResponseEntity<List<ChaveResponse>> buscarChavesParaValidacao(
            @Parameter(
                description = "ID do realm para buscar chaves de validação",
                required = true,
                example = "550e8400-e29b-41d4-a716-446655440000"
            )
            @PathVariable
            @NotNull(message = "ID do realm é obrigatório")
            UUID realmId) {

        log.debug("Buscando chaves para validação de tokens para realm: {}", realmId);

        List<ChaveResponse> chaves = chaveService.buscarChavesParaValidacao(realmId);

        log.debug("Encontradas {} chaves para validação no realm: {}", chaves.size(), realmId);

        return ResponseEntity.ok(chaves);
    }

    /**
     * Returns the rotation history for a realm.
     *
     * @param realmId    The realm ID to get history for
     * @param tipo       Optional rotation type filter
     * @param dataInicio Optional start date filter
     * @param dataFim    Optional end date filter
     * @return ResponseEntity with rotation history
     */
    @GetMapping("/{realmId}/historico")
    @Operation(
        summary = "Histórico de rotações",
        description = "Retorna o histórico de rotações de chaves de um realm, com filtros opcionais por tipo e período"
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "200",
            description = "Histórico retornado com sucesso",
            content = @Content(
                mediaType = "application/json",
                array = @ArraySchema(schema = @Schema(implementation = RotacaoChaveResponse.class))
            )
        ),
        @ApiResponse(
            responseCode = "404",
            description = "Realm não encontrado",
            content = @Content
        )
    })
    public ResponseEntity<List<RotacaoChaveResponse>> historico(
            @Parameter(
                description = "ID do realm para buscar o histórico",
                required = true,
                example = "550e8400-e29b-41d4-a716-446655440000"
            )
            @PathVariable
            @NotNull(message = "ID do realm é obrigatório")
            UUID realmId,
            @Parameter(
                description = "Filtro opcional por tipo de rotação",
                example = "MANUAL"
            )
            @RequestParam(required = false) TipoRotacao tipo,
            @Parameter(
                description = "Filtro opcional por data de início",
                example = "2024-01-01T00:00:00"
            )
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime dataInicio,
            @Parameter(
                description = "Filtro opcional por data de fim",
                example = "2024-12-31T23:59:59"
            )
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime dataFim) {

        log.debug("Buscando histórico de rotações para realm: {} - tipo: {} - período: {} a {}", 
            realmId, tipo, dataInicio, dataFim);

        List<RotacaoChaveResponse> historico = rotacaoService.historico(realmId, tipo, dataInicio, dataFim);

        log.debug("Encontradas {} rotações no histórico para realm: {}", historico.size(), realmId);

        return ResponseEntity.ok(historico);
    }

    /**
     * Finds a specific key by ID.
     *
     * @param chaveId The key ID to find
     * @return ResponseEntity with the key information
     */
    @GetMapping("/detalhes/{chaveId}")
    @Operation(
        summary = "Buscar detalhes de uma chave",
        description = "Retorna informações detalhadas de uma chave criptográfica específica pelo seu ID. A chave privada nunca é incluída na resposta por segurança."
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "200",
            description = "Chave encontrada com sucesso",
            content = @Content(
                mediaType = "application/json",
                schema = @Schema(implementation = ChaveResponse.class)
            )
        ),
        @ApiResponse(
            responseCode = "404",
            description = "Chave não encontrada",
            content = @Content
        )
    })
    public ResponseEntity<ChaveResponse> buscarChave(
            @Parameter(
                description = "ID da chave criptográfica",
                required = true,
                example = "550e8400-e29b-41d4-a716-446655440001"
            )
            @PathVariable
            @NotNull(message = "ID da chave é obrigatório")
            UUID chaveId) {

        log.debug("Buscando chave: {}", chaveId);

        ChaveResponse chave = chaveService.buscarChave(chaveId);

        log.debug("Chave encontrada: {}", chaveId);

        return ResponseEntity.ok(chave);
    }
}
```
```java
package br.com.plataforma.conexaodigital.chave.api.controller;

import br.com.plataforma.conexaodigital.chave.domain.service.ChaveService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.constraints.NotNull;
import java.security.PrivateKey;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * REST controller for cryptographic key internal operations.
 * Provides endpoints for key decryption and validation.
 */
@RestController
@RequestMapping("/api/v1/chaves/internal")
@RequiredArgsConstructor
@Validated
@Slf4j
@Tag(name = "Operações Internas de Chaves", description = "APIs internas para operações criptográficas de chaves")
public class ChaveInternalController {

    private final ChaveService chaveService;

    /**
     * Decrypts a private key for internal use.
     * This endpoint is intended for internal use by the authorization server
     * to sign JWT tokens.
     *
     * @param chaveId The key ID to decrypt
     * @return ResponseEntity with the decrypted private key in Base64 format
     */
    @PostMapping("/{chaveId}/descriptografar")
    @Operation(
        summary = "Descriptografar chave privada",
        description = "Descriptografa a chave privada armazenada no banco usando AES-128. Retorna a chave privada em formato Base64 para uso interno em assinatura de tokens JWT."
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "200",
            description = "Chave privada descriptografada com sucesso",
            content = @Content(
                mediaType = "application/json",
                schema = @Schema(implementation = ChavePrivadaResponse.class)
            )
        ),
        @ApiResponse(
            responseCode = "404",
            description = "Chave não encontrada",
            content = @Content
        ),
        @ApiResponse(
            responseCode = "500",
            description = "Erro ao descriptografar chave privada",
            content = @Content
        )
    })
    public ResponseEntity<ChavePrivadaResponse> descriptografarChavePrivada(
            @Parameter(
                description = "ID da chave criptográfica para descriptografar",
                required = true,
                example = "550e8400-e29b-41d4-a716-446655440001"
            )
            @PathVariable
            @NotNull(message = "ID da chave é obrigatório")
            UUID chaveId) {

        log.debug("Recebida requisição para descriptografar chave privada: {}", chaveId);

        try {
            // Decrypt the private key
            PrivateKey privateKey = chaveService.descriptografarChavePrivada(chaveId);
            
            // Validate the decrypted key
            boolean isValid = chaveService.validarChavePrivada(privateKey);
            if (!isValid) {
                log.error("Chave privada descriptografada é inválida: {}", chaveId);
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
            }

            // Convert to Base64 for response
            String privateKeyBase64 = Base64.getEncoder().encodeToString(privateKey.getEncoded());
            
            ChavePrivadaResponse response = new ChavePrivadaResponse(
                chaveId,
                privateKeyBase64,
                "RSA",
                privateKey.getEncoded().length * 8, // Convert bytes to bits
                isValid
            );

            log.debug("Chave privada descriptografada com sucesso: {}", chaveId);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Erro ao descriptografar chave privada: {}", chaveId, e);
            throw e; // Will be handled by global exception handler
        }
    }

    /**
     * Validates the integrity of a decrypted private key.
     *
     * @param chaveId The key ID to validate
     * @return ResponseEntity with validation result
     */
    @PostMapping("/{chaveId}/validar")
    @Operation(
        summary = "Validar integridade da chave privada",
        description = "Descriptografa e valida a integridade de uma chave privada para garantir que está em formato correto e pode ser usada para operações criptográficas."
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "200",
            description = "Validação realizada com sucesso",
            content = @Content(
                mediaType = "application/json",
                schema = @Schema(implementation = ValidacaoChaveResponse.class)
            )
        ),
        @ApiResponse(
            responseCode = "404",
            description = "Chave não encontrada",
            content = @Content
        )
    })
    public ResponseEntity<ValidacaoChaveResponse> validarChavePrivada(
            @Parameter(
                description = "ID da chave criptográfica para validar",
                required = true,
                example = "550e8400-e29b-41d4-a716-446655440001"
            )
            @PathVariable
            @NotNull(message = "ID da chave é obrigatório")
            UUID chaveId) {

        log.debug("Recebida requisição para validar chave privada: {}", chaveId);

        try {
            // Decrypt and validate the private key
            PrivateKey privateKey = chaveService.descriptografarChavePrivada(chaveId);
            boolean isValid = chaveService.validarChavePrivada(privateKey);
            
            String algorithm = privateKey.getAlgorithm();
            int keySizeBits = privateKey.getEncoded().length * 8;
            String errorMessage = isValid ? null : "Chave privada falhou na validação de integridade";

            ValidacaoChaveResponse response = new ValidacaoChaveResponse(
                chaveId,
                isValid,
                algorithm,
                keySizeBits,
                errorMessage
            );

            log.debug("Validação de chave privada concluída: {} - Válida: {}", chaveId, isValid);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Erro ao validar chave privada: {}", chaveId, e);
            
            ValidacaoChaveResponse errorResponse = new ValidacaoChaveResponse(
                chaveId,
                false,
                null,
                0,
                e.getMessage()
            );
            
            return ResponseEntity.ok(errorResponse);
        }
    }

    /**
     * Record for private key response.
     */
    public record ChavePrivadaResponse(
            UUID chaveId,
            String privateKeyBase64,
            String algorithm,
            int keySizeBits,
            boolean isValid
    ) {}

    /**
     * Record for validation response.
     */
    public record ValidacaoChaveResponse(
            UUID chaveId,
            boolean isValid,
            String algorithm,
            int keySizeBits,
            String errorMessage
    ) {}
}
```
```java
package br.com.plataforma.conexaodigital.chave.api.controller;

import br.com.plataforma.conexaodigital.chave.api.responses.ChaveResponse;
import br.com.plataforma.conexaodigital.chave.api.responses.RotacaoChaveResponse;
import br.com.plataforma.conexaodigital.chave.domain.service.RotacaoChaveService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.constraints.NotNull;
import java.util.List;
import java.util.UUID;

/**
 * REST controller for key rotation operations.
 * Provides endpoints for manual key rotation and rotation history.
 */
@RestController
@RequestMapping("/api/v1/chaves")
@RequiredArgsConstructor
@Validated
@Slf4j
@Tag(name = "Rotação de Chaves", description = "APIs para rotação manual e automática de chaves criptográficas")
public class RotacaoChaveController {

    private final RotacaoChaveService rotacaoService;

    /**
     * Performs manual rotation of keys for a realm.
     * Generates a new key pair and marks the previous key as inactive.
     * Previous keys remain valid for token validation (grace period).
     *
     * @param realmId The realm ID to rotate keys for
     * @return ResponseEntity with the new active key information
     */
    @PostMapping("/{realmId}/rotacionar")
    @Operation(
        summary = "Rotacionar chaves manualmente",
        description = "Gera um novo par de chaves RSA-2048 e marca a chave anterior como INATIVA. A nova chave é marcada como ATIVA e será usada para assinar novos tokens. Chaves anteriores continuam válidas para validação de tokens existentes (grace period)."
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "200",
            description = "Chaves rotacionadas com sucesso",
            content = @Content(
                mediaType = "application/json",
                schema = @Schema(implementation = ChaveResponse.class)
            )
        ),
        @ApiResponse(
            responseCode = "404",
            description = "Realm não encontrado ou nenhuma chave ativa encontrada",
            content = @Content
        ),
        @ApiResponse(
            responseCode = "500",
            description = "Erro ao rotacionar chaves",
            content = @Content
        )
    })
    public ResponseEntity<ChaveResponse> rotacionarChaves(
            @Parameter(
                description = "ID do realm para rotacionar as chaves",
                required = true,
                example = "550e8400-e29b-41d4-a716-446655440000"
            )
            @PathVariable
            @NotNull(message = "ID do realm é obrigatório")
            UUID realmId) {

        log.info("Recebida requisição para rotacionar chaves manualmente para realm: {}", realmId);

        try {
            ChaveResponse response = rotacaoService.rotacionar(realmId, 
                br.com.plataforma.conexaodigital.chave.domain.model.TipoRotacao.MANUAL);

            log.info("Chaves rotacionadas com sucesso para realm: {} - Nova chave: {}", 
                realmId, response.id());

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("Erro ao rotacionar chaves para realm: {}", realmId, e);
            throw e; // Will be handled by global exception handler
        }
    }

    /**
     * Lists all rotation events for a realm.
     *
     * @param realmId The realm ID to list rotations for
     * @return ResponseEntity with list of rotation events
     */
    @GetMapping("/{realmId}/rotacoes")
    @Operation(
        summary = "Listar histórico de rotações",
        description = "Retorna o histórico completo de rotações de chaves para um realm específico, ordenado por data (mais recentes primeiro). Inclui rotações manuais e automáticas."
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "200",
            description = "Histórico de rotações retornado com sucesso",
            content = @Content(
                mediaType = "application/json",
                schema = @Schema(implementation = RotacaoChaveResponse.class)
            )
        )
    })
    public ResponseEntity<List<RotacaoChaveResponse>> listarRotacoes(
            @Parameter(
                description = "ID do realm para listar o histórico de rotações",
                required = true,
                example = "550e8400-e29b-41d4-a716-446655440000"
            )
            @PathVariable
            @NotNull(message = "ID do realm é obrigatório")
            UUID realmId) {

        log.debug("Listando rotações para realm: {}", realmId);

        List<RotacaoChaveResponse> rotacoes = rotacaoService.listarRotacoesPorRealm(realmId);

        log.debug("Encontradas {} rotações para realm: {}", rotacoes.size(), realmId);

        return ResponseEntity.ok(rotacoes);
    }

    /**
     * Finds the most recent rotation event for a realm.
     *
     * @param realmId The realm ID to find most recent rotation for
     * @return ResponseEntity with the most recent rotation event
     */
    @GetMapping("/{realmId}/rotacoes/recente")
    @Operation(
        summary = "Buscar rotação mais recente",
        description = "Retorna a rotação de chaves mais recente para um realm específico. Útil para verificar quando foi a última rotação e qual chave está ativa."
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "200",
            description = "Rotação mais recente encontrada com sucesso",
            content = @Content(
                mediaType = "application/json",
                schema = @Schema(implementation = RotacaoChaveResponse.class)
            )
        ),
        @ApiResponse(
            responseCode = "404",
            description = "Nenhuma rotação encontrada para o realm",
            content = @Content
        )
    })
    public ResponseEntity<RotacaoChaveResponse> buscarRotacaoMaisRecente(
            @Parameter(
                description = "ID do realm para buscar a rotação mais recente",
                required = true,
                example = "550e8400-e29b-41d4-a716-446655440000"
            )
            @PathVariable
            @NotNull(message = "ID do realm é obrigatório")
            UUID realmId) {

        log.debug("Buscando rotação mais recente para realm: {}", realmId);

        RotacaoChaveResponse rotacao = rotacaoService.buscarRotacaoMaisRecente(realmId);

        log.debug("Rotação mais recente encontrada: {} para realm: {}", rotacao.id(), realmId);

        return ResponseEntity.ok(rotacao);
    }

    /**
     * Gets rotation status and statistics for a realm.
     *
     * @param realmId The realm ID to get rotation status for
     * @return ResponseEntity with rotation status information
     */
    @GetMapping("/{realmId}/rotacoes/status")
    @Operation(
        summary = "Verificar status de rotação",
        description = "Retorna informações sobre o status atual das chaves e quando foi a última rotação. Inclui contagem de chaves ativas e inativas."
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "200",
            description = "Status de rotação retornado com sucesso",
            content = @Content(
                mediaType = "application/json",
                schema = @Schema(implementation = RotacaoStatusResponse.class)
            )
        )
    })
    public ResponseEntity<RotacaoStatusResponse> verificarStatusRotacao(
            @Parameter(
                description = "ID do realm para verificar status de rotação",
                required = true,
                example = "550e8400-e29b-41d4-a716-446655440000"
            )
            @PathVariable
            @NotNull(message = "ID do realm é obrigatório")
            UUID realmId) {

        log.debug("Verificando status de rotação para realm: {}", realmId);

        List<RotacaoChaveResponse> rotacoes = rotacaoService.listarRotacoesPorRealm(realmId);
        
        RotacaoStatusResponse status = new RotacaoStatusResponse(
            realmId,
            rotacoes.size(),
            rotacoes.isEmpty() ? null : rotacoes.get(0).dataRotacao(),
            rotacoes.stream()
                .filter(r -> r.tipo() == br.com.plataforma.conexaodigital.chave.domain.model.TipoRotacao.MANUAL)
                .count(),
            rotacoes.stream()
                .filter(r -> r.tipo() == br.com.plataforma.conexaodigital.chave.domain.model.TipoRotacao.AUTOMATICA)
                .count()
        );

        log.debug("Status de rotação verificado para realm: {} - Total rotações: {}", 
            realmId, status.totalRotacoes());

        return ResponseEntity.ok(status);
    }

    /**
     * Record for rotation status response.
     */
    public record RotacaoStatusResponse(
            UUID realmId,
            long totalRotacoes,
            java.time.LocalDateTime ultimaRotacao,
            long rotacoesManuais,
            long rotacoesAutomaticas
    ) {}
}
```
```java
package br.com.plataforma.conexaodigital.chave.api.responses;

import java.time.LocalDateTime;
import java.util.UUID;

import br.com.plataforma.conexaodigital.chave.domain.model.StatusChave;

/**
 * Response DTO for cryptographic key information.
 * Private key is never included in responses for security.
 */
public record ChaveResponse(
        UUID id,
        UUID versao,
        UUID realmId,
        String realmNome,
        StatusChave status,
        String publicKey,
        LocalDateTime dataCriacao,
        LocalDateTime dataInativacao,
        LocalDateTime dataExpiracao,
        String proximaRotacao) {

    /**
     * Creates a new ChaveResponse.
     *
     * @param id             The key ID
     * @param versao         The key version (kid)
     * @param realmId        The realm ID
     * @param realmNome      The realm name
     * @param status         The key status
     * @param publicKey      The RSA public key in Base64 format
     * @param dataCriacao    The creation date
     * @param dataInativacao The inactivation date (null if still active)
     * @param proximaRotacao The next automatic rotation date (null if expired)
     */
    public ChaveResponse {
    }
}
```
```java
package br.com.plataforma.conexaodigital.chave.api.responses;

import br.com.plataforma.conexaodigital.chave.domain.model.TipoRotacao;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Response DTO for key rotation information.
 * Contains detailed information about key rotations for display in admin dashboard.
 */
public record RotacaoChaveResponse(
        UUID id,
        UUID realmId,
        String realmNome,
        UUID chaveAnteriorId,
        UUID chaveNovaId,
        String versaoAntiga,      // Human-readable version of previous key
        String versaoNova,         // Human-readable version of new key
        TipoRotacao tipo,
        String motivo,             // Description derived from rotation type
        LocalDateTime dataRotacao,
        String solicitante,
        String responsavel,        // Alias for solicitante (for UI consistency)
        String status              // Always "CONCLUIDA" for historical rotations
) {

    /**
     * Creates a new RotacaoChaveResponse.
     *
     * @param id              The rotation ID
     * @param realmId         The realm ID
     * @param realmNome       The realm name
     * @param chaveAnteriorId The previous key ID (null for first key)
     * @param chaveNovaId     The new key ID
     * @param versaoAntiga   Human-readable version of previous key
     * @param versaoNova     Human-readable version of new key
     * @param tipo            The rotation type
     * @param motivo          Description of rotation reason
     * @param dataRotacao     The rotation date
     * @param solicitante     The user/system that initiated the rotation
     * @param responsavel     Alias for solicitante (for UI consistency)
     * @param status          Rotation status (always CONCLUIDA for history)
     */
    public RotacaoChaveResponse {
    }
}
```
```java
package br.com.plataforma.conexaodigital.chave.domain.exception;

import java.util.UUID;

/**
 * Exception thrown when a cryptographic key is not found.
 */
public class ChaveNotFoundException extends RuntimeException {

    private final UUID chaveId;

    public ChaveNotFoundException(UUID chaveId) {
        super("Chave não encontrada: " + chaveId);
        this.chaveId = chaveId;
    }

    public ChaveNotFoundException(String message, UUID chaveId) {
        super(message);
        this.chaveId = chaveId;
    }

    public ChaveNotFoundException(String message, Throwable cause, UUID chaveId) {
        super(message, cause);
        this.chaveId = chaveId;
    }

    public UUID getChaveId() {
        return chaveId;
    }
}
```
```java
package br.com.plataforma.conexaodigital.chave.domain.exception;

/**
 * Exception thrown when cryptographic operations fail.
 */
public class CriptografiaException extends RuntimeException {

    public CriptografiaException(String message) {
        super(message);
    }

    public CriptografiaException(String message, Throwable cause) {
        super(message, cause);
    }
}
```
```java
package br.com.plataforma.conexaodigital.chave.domain.exception;

import java.util.UUID;

/**
 * Exception thrown when no active key is found for a realm.
 */
public class NenhumaChaveAtivaException extends RuntimeException {

    private final UUID realmId;

    public NenhumaChaveAtivaException(UUID realmId) {
        super("Nenhuma chave ativa encontrada para o realm: " + realmId);
        this.realmId = realmId;
    }

    public NenhumaChaveAtivaException(String message, UUID realmId) {
        super(message);
        this.realmId = realmId;
    }

    public NenhumaChaveAtivaException(String message, Throwable cause, UUID realmId) {
        super(message, cause);
        this.realmId = realmId;
    }

    public UUID getRealmId() {
        return realmId;
    }
}
```
```java
package br.com.plataforma.conexaodigital.chave.domain.exception;

import java.util.UUID;

/**
 * Exception thrown when a realm is not found.
 */
public class RealmNotFoundException extends RuntimeException {

    private final UUID realmId;

    public RealmNotFoundException(UUID realmId) {
        super("Realm não encontrado: " + realmId);
        this.realmId = realmId;
    }

    public RealmNotFoundException(String message, UUID realmId) {
        super(message);
        this.realmId = realmId;
    }

    public RealmNotFoundException(String message, Throwable cause, UUID realmId) {
        super(message, cause);
        this.realmId = realmId;
    }

    public UUID getRealmId() {
        return realmId;
    }
}
```
```java
package br.com.plataforma.conexaodigital.chave.domain.model;

import java.time.LocalDateTime;
import java.util.UUID;

import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.persistence.Version;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Represents a cryptographic key pair stored in database.
 * Each key belongs to a realm and contains RSA public/private keys.
 * The private key is encrypted with AES-128 for security.
 */
@Entity
@Table(name = "chave_criptografica")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ChaveCriptografica {

    @Id
    @Column(name = "id", updatable = false, nullable = false)
    private UUID id;

    @Column(name = "versao", nullable = false, updatable = false)
    private UUID versao;

    @NotNull(message = "Realm é obrigatório")
    @ManyToOne
    @JoinColumn(name = "realm_id", nullable = false)
    private Realm realm;

    @Column(name = "public_key", nullable = false, columnDefinition = "TEXT")
    private String publicKey;

    @Column(name = "private_key", nullable = false, columnDefinition = "TEXT")
    private String privateKey;

    @NotNull(message = "Status da chave é obrigatório")
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private StatusChave status;

    @Column(name = "data_criacao", nullable = false, updatable = false)
    private LocalDateTime dataCriacao;

    @Column(name = "data_inativacao")
    private LocalDateTime dataInativacao;
    @Column(name = "data_espiracao")
    private LocalDateTime dataExpiracao;

    @Version
    @Column(name = "versao_registro")
    private Long versaoRegistro;

    /**
     * Creates a new ChaveCriptografica with the specified parameters.
     *
     * @param versao     The version ID (kid) of the key
     * @param realm      The realm this key belongs to
     * @param publicKey  The RSA public key in Base64 format
     * @param privateKey The AES-128 encrypted RSA private key in Base64 format
     * @param status     The status of the key
     */
    public ChaveCriptografica(UUID versao, Realm realm, String publicKey, String privateKey, StatusChave status) {
        this.id = UUID.randomUUID();
        this.versao = versao;
        this.realm = realm;
        this.publicKey = publicKey;
        this.privateKey = privateKey;
        this.status = status;
        this.dataCriacao = LocalDateTime.now();
        this.versaoRegistro = 0L;
    }

    // Getters

    public UUID getId() {
        return id;
    }

    public UUID getVersao() {
        return versao;
    }

    public Realm getRealm() {
        return realm;
    }

    public String getPublicKey() {
        return publicKey;
    }

    public String getPrivateKey() {
        return privateKey;
    }

    public StatusChave getStatus() {
        return status;
    }

    public LocalDateTime getDataCriacao() {
        return dataCriacao;
    }

    public LocalDateTime getDataInativacao() {
        return dataInativacao;
    }

    public LocalDateTime getDataExpiracao() {
        return dataInativacao;
    }

    /**
     * Marks the key as inactive with the current timestamp.
     */
    public void inativar() {
        this.status = StatusChave.INATIVA;
        this.dataInativacao = LocalDateTime.now();
    }

    /**
     * Checks if the key is active.
     *
     * @return true if the key is ATIVA, false otherwise
     */
    public boolean isAtiva() {
        return StatusChave.ATIVA.equals(this.status);
    }

    /**
     * Checks if the key can validate tokens (ATIVA or INATIVA).
     *
     * @return true if the key can validate tokens, false otherwise
     */
    public boolean podeValidarTokens() {
        return StatusChave.ATIVA.equals(this.status) || StatusChave.INATIVA.equals(this.status);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        ChaveCriptografica that = (ChaveCriptografica) o;
        return id != null && id.equals(that.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }

    @Override
    public String toString() {
        return "ChaveCriptografica{" +
                "id=" + id +
                ", versao=" + versao +
                ", realm=" + realm +
                ", status=" + status +
                ", dataCriacao=" + dataCriacao +
                ", dataInativacao=" + dataInativacao +
                ", versaoRegistro=" + versaoRegistro +
                '}';
    }
}
```
```java
package br.com.plataforma.conexaodigital.chave.domain.model;

import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.persistence.Version;
import jakarta.validation.constraints.NotNull;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Represents a key rotation event in the system.
 * Records when keys are rotated from old to new ones.
 */
@Entity
@Table(name = "rotacao_chave")
public class RotacaoChave {

    @Id
    @Column(name = "id", updatable = false, nullable = false)
    private UUID id;

    @NotNull(message = "Realm é obrigatório")
    @ManyToOne
    @JoinColumn(name = "realm_id", nullable = false)
    private Realm realm;

    @Column(name = "chave_anterior_id")
    private UUID chaveAnteriorId;

    @NotNull(message = "Chave nova é obrigatória")
    @Column(name = "chave_nova_id", nullable = false)
    private UUID chaveNovaId;

    @NotNull(message = "Tipo de rotação é obrigatório")
    @Enumerated(EnumType.STRING)
    @Column(name = "tipo", nullable = false, length = 20)
    private TipoRotacao tipo;

    @NotNull(message = "Data de rotação é obrigatória")
    @Column(name = "data_rotacao", nullable = false)
    private LocalDateTime dataRotacao;

    @Column(name = "solicitante", length = 100)
    private String solicitante;

    @Version
    @Column(name = "versao_registro")
    private Long versaoRegistro;

    /**
     * Default constructor required by JPA.
     */
    protected RotacaoChave() {
    }

    /**
     * Creates a new RotacaoChave with the specified parameters.
     *
     * @param realm           The realm where the rotation occurred
     * @param chaveAnteriorId The ID of the previous key (may be null for first key)
     * @param chaveNovaId     The ID of the new key
     * @param tipo            The type of rotation (MANUAL or AUTOMATICA)
     * @param solicitante     The user/system that initiated the rotation
     */
    public RotacaoChave(Realm realm, UUID chaveAnteriorId, UUID chaveNovaId, TipoRotacao tipo, String solicitante) {
        this.id = UUID.randomUUID();
        this.realm = realm;
        this.chaveAnteriorId = chaveAnteriorId;
        this.chaveNovaId = chaveNovaId;
        this.tipo = tipo;
        this.dataRotacao = LocalDateTime.now();
        this.solicitante = solicitante;
        this.versaoRegistro = 0L;
    }

    // Getters

    public UUID getId() {
        return id;
    }

    public Realm getRealm() {
        return realm;
    }

    public UUID getChaveAnteriorId() {
        return chaveAnteriorId;
    }

    public UUID getChaveNovaId() {
        return chaveNovaId;
    }

    public TipoRotacao getTipo() {
        return tipo;
    }

    public LocalDateTime getDataRotacao() {
        return dataRotacao;
    }

    public String getSolicitante() {
        return solicitante;
    }

    public Long getVersaoRegistro() {
        return versaoRegistro;
    }

    // Setters (only for business logic use)

    public void setId(UUID id) {
        this.id = id;
    }

    public void setRealm(Realm realm) {
        this.realm = realm;
    }

    public void setChaveAnteriorId(UUID chaveAnteriorId) {
        this.chaveAnteriorId = chaveAnteriorId;
    }

    public void setChaveNovaId(UUID chaveNovaId) {
        this.chaveNovaId = chaveNovaId;
    }

    public void setTipo(TipoRotacao tipo) {
        this.tipo = tipo;
    }

    public void setDataRotacao(LocalDateTime dataRotacao) {
        this.dataRotacao = dataRotacao;
    }

    public void setSolicitante(String solicitante) {
        this.solicitante = solicitante;
    }

    public void setVersaoRegistro(Long versaoRegistro) {
        this.versaoRegistro = versaoRegistro;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        RotacaoChave that = (RotacaoChave) o;
        return id != null && id.equals(that.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }

    @Override
    public String toString() {
        return "RotacaoChave{" +
                "id=" + id +
                ", realm=" + realm +
                ", chaveAnteriorId=" + chaveAnteriorId +
                ", chaveNovaId=" + chaveNovaId +
                ", tipo=" + tipo +
                ", dataRotacao=" + dataRotacao +
                ", solicitante='" + solicitante + '\'' +
                ", versaoRegistro=" + versaoRegistro +
                '}';
    }
}
```
```java
package br.com.plataforma.conexaodigital.chave.domain.model;

/**
 * Enum representing the status of a cryptographic key.
 * A key can be ATIVA (active), INATIVA (inactive), or EXPIRADA (expired).
 */
public enum StatusChave {

    /**
     * Key is active and can be used for signing/validating tokens.
     */
    ATIVA("Ativa"),

    /**
     * Key is inactive and no longer used for signing, but can still validate tokens (grace period).
     */
    INATIVA("Inativa"),

    /**
     * Key is expired and cannot be used for any operation.
     */
    EXPIRADA("Expirada");

    private final String descricao;

    StatusChave(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}
```
```java
package br.com.plataforma.conexaodigital.chave.domain.model;

/**
 * Enum representing the type of key rotation.
 * A rotation can be MANUAL (initiated by administrator) or AUTOMATICA (scheduled).
 */
public enum TipoRotacao {

    /**
     * Manual rotation initiated by an administrator.
     */
    MANUAL("Manual"),

    /**
     * Automatic rotation scheduled by the system.
     */
    AUTOMATICA("Automática");

    private final String descricao;

    TipoRotacao(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}
```
```java
package br.com.plataforma.conexaodigital.chave.domain.repository;

import br.com.plataforma.conexaodigital.chave.domain.model.ChaveCriptografica;
import br.com.plataforma.conexaodigital.chave.domain.model.StatusChave;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Repository interface for ChaveCriptografica entities.
 */
@Repository
public interface ChaveCriptograficaRepository extends JpaRepository<ChaveCriptografica, UUID> {

    /**
     * Finds a key by realm ID and status.
     *
     * @param realmId The realm ID
     * @param status  The key status
     * @return Optional containing the key if found
     */
    Optional<ChaveCriptografica> findByRealmIdAndStatus(UUID realmId, StatusChave status);

    /**
     * Finds all keys by realm ID and status.
     *
     * @param realmId The realm ID
     * @param status  The key status
     * @return List of keys with the specified status
     */
    List<ChaveCriptografica> findAllByRealmIdAndStatus(UUID realmId, StatusChave status);

    /**
     * Finds all keys belonging to a realm.
     *
     * @param realmId The realm ID
     * @return List of keys for the realm
     */
    List<ChaveCriptografica> findByRealmIdOrderByDataCriacaoDesc(UUID realmId);

    /**
     * Finds all keys that can validate tokens (ATIVA or INATIVA) for a realm.
     *
     * @param realmId The realm ID
     * @return List of keys that can validate tokens
     */
    @Query("SELECT k FROM ChaveCriptografica k WHERE k.realm.id = :realmId AND k.status IN :statuses ORDER BY k.dataCriacao DESC")
    List<ChaveCriptografica> findByRealmIdAndStatusInOrderByDataCriacaoDesc(@Param("realmId") UUID realmId, @Param("statuses") List<StatusChave> statuses);

    /**
     * Finds a key by its version (kid) and realm.
     *
     * @param versao  The key version (kid)
     * @param realmId The realm ID
     * @return Optional containing the key if found
     */
    Optional<ChaveCriptografica> findByVersaoAndRealmId(UUID versao, UUID realmId);

    /**
     * Checks if a realm has any active keys.
     *
     * @param realmId The realm ID
     * @return true if the realm has active keys, false otherwise
     */
    boolean existsByRealmIdAndStatus(UUID realmId, StatusChave status);

    /**
     * Counts keys by realm and status.
     *
     * @param realmId The realm ID
     * @param status  The key status
     * @return Number of keys with specified status
     */
    long countByRealmIdAndStatus(UUID realmId, StatusChave status);

    /**
     * Counts keys by status.
     *
     * @param status The key status
     * @return Number of keys with specified status
     */
    long countByStatus(StatusChave status);

    /**
     * Checks if a realm has any keys.
     *
     * @param realmId The realm ID
     * @return true if realm has any keys, false otherwise
     */
    boolean existsByRealmId(UUID realmId);
}
```
```java
package br.com.plataforma.conexaodigital.chave.domain.repository;

import br.com.plataforma.conexaodigital.chave.domain.model.RotacaoChave;
import br.com.plataforma.conexaodigital.chave.domain.model.TipoRotacao;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Repository interface for RotacaoChave entities.
 */
@Repository
public interface RotacaoChaveRepository extends JpaRepository<RotacaoChave, UUID> {

    /**
     * Finds all rotations for a realm ordered by date descending.
     *
     * @param realmId The realm ID
     * @return List of rotations for the realm
     */
    List<RotacaoChave> findByRealmIdOrderByDataRotacaoDesc(UUID realmId);

    /**
     * Finds rotations by realm and type.
     *
     * @param realmId The realm ID
     * @param tipo    The rotation type
     * @return List of rotations matching the criteria
     */
    List<RotacaoChave> findByRealmIdAndTipoOrderByDataRotacaoDesc(UUID realmId, TipoRotacao tipo);

    /**
     * Finds rotations within a date range.
     *
     * @param realmId The realm ID
     * @param inicio  Start date
     * @param fim     End date
     * @return List of rotations within the date range
     */
    @Query("SELECT r FROM RotacaoChave r WHERE r.realm.id = :realmId AND r.dataRotacao BETWEEN :inicio AND :fim ORDER BY r.dataRotacao DESC")
    List<RotacaoChave> findByRealmIdAndDataRotacaoBetweenOrderByDataRotacaoDesc(
            @Param("realmId") UUID realmId,
            @Param("inicio") LocalDateTime inicio,
            @Param("fim") LocalDateTime fim);

    /**
     * Finds the most recent rotation for a realm.
     *
     * @param realmId The realm ID
     * @return Optional containing the most recent rotation if found
     */
    @Query("SELECT r FROM RotacaoChave r WHERE r.realm.id = :realmId ORDER BY r.dataRotacao DESC LIMIT 1")
    Optional<RotacaoChave> findMostRecentByRealmId(@Param("realmId") UUID realmId);

    /**
     * Counts rotations by realm and type.
     *
     * @param realmId The realm ID
     * @param tipo    The rotation type
     * @return Number of rotations of the specified type
     */
    long countByRealmIdAndTipo(UUID realmId, TipoRotacao tipo);

    /**
     * Finds the most recent automatic rotation for a realm.
     *
     * @param realm The realm entity
     * @param tipo  The rotation type
     * @return Optional containing the most recent rotation if found
     */
    Optional<RotacaoChave> findTopByRealmAndTipoOrderByDataRotacaoDesc(br.com.plataforma.conexaodigital.realm.domain.model.Realm realm, TipoRotacao tipo);
}
```
```java
package br.com.plataforma.conexaodigital.chave.domain.service;

import br.com.plataforma.conexaodigital.chave.api.responses.ChaveResponse;
import br.com.plataforma.conexaodigital.chave.domain.exception.ChaveNotFoundException;
import br.com.plataforma.conexaodigital.chave.domain.exception.CriptografiaException;
import br.com.plataforma.conexaodigital.chave.domain.model.ChaveCriptografica;
import br.com.plataforma.conexaodigital.chave.domain.model.StatusChave;
import br.com.plataforma.conexaodigital.chave.domain.repository.ChaveCriptograficaRepository;

import java.security.PrivateKey;
import java.util.List;
import java.util.UUID;

/**
 * Service interface for cryptographic key management operations.
 */
public interface ChaveService {

    /**
     * Generates a new RSA-2048 key pair for a realm.
     *
     * @param realmId The realm ID
     * @return ChaveResponse with the generated key information
     * @throws br.com.plataforma.conexaodigital.chave.domain.exception.RealmNotFoundException if realm not found
     * @throws CriptografiaException if key generation or encryption fails
     */
    ChaveResponse gerarChave(UUID realmId);

    /**
     * Decrypts and returns a private key for internal use.
     *
     * @param chaveId The key ID
     * @return The decrypted PrivateKey object
     * @throws ChaveNotFoundException if key not found
     * @throws CriptografiaException if decryption fails
     */
    PrivateKey descriptografarChavePrivada(UUID chaveId);

    /**
     * Validates the integrity of a decrypted private key.
     *
     * @param privateKey The private key to validate
     * @return true if the key is valid, false otherwise
     */
    boolean validarChavePrivada(PrivateKey privateKey);

    /**
     * Finds a key by ID and returns the response DTO.
     *
     * @param chaveId The key ID
     * @return ChaveResponse with key information
     * @throws ChaveNotFoundException if key not found
     */
    ChaveResponse buscarChave(UUID chaveId);

    /**
     * Lists all keys for a realm.
     *
     * @param realmId The realm ID
     * @return List of keys for the realm
     */
    List<ChaveResponse> listarChavesPorRealm(UUID realmId);

    /**
     * Finds the active key for a realm.
     *
     * @param realmId The realm ID
     * @return ChaveResponse with the active key
     * @throws br.com.plataforma.conexaodigital.chave.domain.exception.NenhumaChaveAtivaException if no active key found
     */
    ChaveResponse buscarChaveAtiva(UUID realmId);

    /**
     * Finds all keys that can validate tokens for a realm.
     *
     * @param realmId The realm ID
     * @return List of keys that can validate tokens (ATIVA or INATIVA)
     */
    List<ChaveResponse> buscarChavesParaValidacao(UUID realmId);

    /**
     * Lists all keys for a realm with optional status filter.
     *
     * @param realmId The realm ID
     * @param status  Optional status filter (ATIVA, INATIVA, EXPIRADA)
     * @return List of keys for the realm with next rotation info
     * @throws br.com.plataforma.conexaodigital.chave.domain.exception.RealmNotFoundException if realm not found
     */
    List<ChaveResponse> listar(UUID realmId, StatusChave status);
}
```
```java
package br.com.plataforma.conexaodigital.chave.domain.service;

import br.com.plataforma.conexaodigital.chave.api.responses.ChaveResponse;
import br.com.plataforma.conexaodigital.chave.api.responses.RotacaoChaveResponse;
import br.com.plataforma.conexaodigital.chave.domain.model.TipoRotacao;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

/**
 * Service interface for key rotation operations.
 */
public interface RotacaoChaveService {

    /**
     * Performs manual rotation of keys for a realm.
     *
     * @param realmId The realm ID to rotate keys for
     * @param tipo    The rotation type (MANUAL or AUTOMATICA)
     * @return ChaveResponse with the new active key
     * @throws br.com.plataforma.conexaodigital.chave.domain.exception.RealmNotFoundException if realm not found
     * @throws br.com.plataforma.conexaodigital.chave.domain.exception.NenhumaChaveAtivaException if no active key found
     * @throws br.com.plataforma.conexaodigital.chave.domain.exception.CriptografiaException if rotation fails
     */
    ChaveResponse rotacionar(UUID realmId, TipoRotacao tipo);

    /**
     * Finds all rotation events for a realm.
     *
     * @param realmId The realm ID to list rotations for
     * @return List of rotation events
     */
    List<RotacaoChaveResponse> listarRotacoesPorRealm(UUID realmId);

    /**
     * Finds the most recent rotation for a realm.
     *
     * @param realmId The realm ID to find most recent rotation for
     * @return RotacaoChaveResponse with the most recent rotation
     */
    RotacaoChaveResponse buscarRotacaoMaisRecente(UUID realmId);

    /**
     * Returns rotation history for a realm with optional filters.
     *
     * @param realmId The realm ID
     * @param tipo    Optional rotation type filter (MANUAL or AUTOMATICA)
     * @param dataInicio Optional start date filter
     * @param dataFim  Optional end date filter
     * @return List of rotation events matching the criteria
     * @throws br.com.plataforma.conexaodigital.chave.domain.exception.RealmNotFoundException if realm not found
     */
    List<RotacaoChaveResponse> historico(UUID realmId, TipoRotacao tipo, LocalDateTime dataInicio, LocalDateTime dataFim);
}
```
```java
package br.com.plataforma.conexaodigital.chave.domain.service.impl;

import java.security.KeyPair;
import java.security.PrivateKey;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.plataforma.conexaodigital.chave.api.responses.ChaveResponse;
import br.com.plataforma.conexaodigital.chave.domain.exception.ChaveNotFoundException;
import br.com.plataforma.conexaodigital.chave.domain.exception.CriptografiaException;
import br.com.plataforma.conexaodigital.chave.domain.exception.NenhumaChaveAtivaException;
import br.com.plataforma.conexaodigital.chave.domain.exception.RealmNotFoundException;
import br.com.plataforma.conexaodigital.chave.domain.model.ChaveCriptografica;
import br.com.plataforma.conexaodigital.chave.domain.model.RotacaoChave;
import br.com.plataforma.conexaodigital.chave.domain.model.StatusChave;
import br.com.plataforma.conexaodigital.chave.domain.model.TipoRotacao;
import br.com.plataforma.conexaodigital.chave.domain.repository.ChaveCriptograficaRepository;
import br.com.plataforma.conexaodigital.chave.domain.repository.RotacaoChaveRepository;
import br.com.plataforma.conexaodigital.chave.domain.service.ChaveService;
import br.com.plataforma.conexaodigital.chave.infrastructure.criptografia.AesCriptografiaService;
import br.com.plataforma.conexaodigital.chave.infrastructure.criptografia.RsaKeyGenerator;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Implementation of ChaveService for cryptographic key management operations.
 */
@Service
@RequiredArgsConstructor
@Slf4j
@Transactional
public class ChaveServiceImpl implements ChaveService {

    private final ChaveCriptograficaRepository chaveRepository;
    private final RealmRepository realmRepository;
    private final RotacaoChaveRepository rotacaoRepository;
    private final AesCriptografiaService aesService;
    private final RsaKeyGenerator rsaGenerator;

    @Override
    public ChaveResponse gerarChave(UUID realmId) {
        log.info("Gerando nova chave para realm: {}", realmId);

        // Validate realm exists
        var realm = realmRepository.findById(realmId)
                .orElseThrow(() -> new RealmNotFoundException(realmId));

        // Validate AES secret is properly configured
        if (!aesService.isSecretValid()) {
            throw new CriptografiaException("Segredo AES não está configurado corretamente");
        }

        try {
            // Generate RSA key pair
            KeyPair keyPair = rsaGenerator.generateKeyPair();

            // Validate key pair
            if (!rsaGenerator.validateKeyPair(keyPair)) {
                throw new CriptografiaException("Par de chaves gerado é inválido");
            }

            // Create encrypted key entity
            UUID versao = UUID.randomUUID();
            ChaveCriptografica chave = new ChaveCriptografica(
                    versao,
                    realm,
                    rsaGenerator.publicKeyToString(keyPair.getPublic()),
                    aesService.encrypt(rsaGenerator.privateKeyToString(keyPair.getPrivate())),
                    StatusChave.ATIVA);

            // Save to database
            chave = chaveRepository.save(chave);

            log.info("Chave gerada com sucesso: {} para realm: {}", chave.getId(), realmId);

            return mapToResponse(chave);

        } catch (CriptografiaException e) {
            throw e;
        } catch (Exception e) {
            log.error("Erro ao gerar chave para realm: {}", realmId, e);
            throw new CriptografiaException("Erro ao gerar chave RSA", e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public PrivateKey descriptografarChavePrivada(UUID chaveId) {
        log.debug("Descriptografando chave privada: {}", chaveId);

        ChaveCriptografica chave = chaveRepository.findById(chaveId)
                .orElseThrow(() -> new ChaveNotFoundException(chaveId));

        try {
            // Decrypt the private key
            String privateKeyEncrypted = chave.getPrivateKey();
            String privateKeyPem = aesService.decrypt(privateKeyEncrypted);

            // Convert to PrivateKey object
            PrivateKey privateKey = rsaGenerator.stringToPrivateKey(privateKeyPem);

            // Validate the decrypted key
            if (!validarChavePrivada(privateKey)) {
                throw new CriptografiaException("Chave privada descriptografada é inválida");
            }

            log.debug("Chave privada descriptografada com sucesso: {}", chaveId);
            return privateKey;

        } catch (CriptografiaException e) {
            throw e;
        } catch (Exception e) {
            log.error("Erro ao descriptografar chave privada: {}", chaveId, e);
            throw new CriptografiaException("Erro ao descriptografar chave privada", e);
        }
    }

    @Override
    public boolean validarChavePrivada(PrivateKey privateKey) {
        try {
            // Basic validation checks
            if (privateKey == null) {
                return false;
            }

            // Check algorithm
            if (!"RSA".equals(privateKey.getAlgorithm())) {
                return false;
            }

            // Check key size (should be 2048 bits = 256 bytes)
            byte[] encoded = privateKey.getEncoded();
            if (encoded == null || encoded.length != 256) {
                return false;
            }

            // Try to reconstruct the key to verify integrity
            rsaGenerator.stringToPrivateKey(rsaGenerator.privateKeyToString(privateKey));

            return true;

        } catch (Exception e) {
            log.debug("Chave privada inválida", e);
            return false;
        }
    }

    @Override
    @Transactional(readOnly = true)
    public ChaveResponse buscarChave(UUID chaveId) {
        ChaveCriptografica chave = chaveRepository.findById(chaveId)
                .orElseThrow(() -> new ChaveNotFoundException(chaveId));

        return mapToResponse(chave);
    }

    @Override
    @Transactional(readOnly = true)
    public List<ChaveResponse> listarChavesPorRealm(UUID realmId) {
        List<ChaveCriptografica> chaves = chaveRepository.findByRealmIdOrderByDataCriacaoDesc(realmId);

        return chaves.stream()
                .map(this::mapToResponse)
                .toList();
    }

    @Override
    @Transactional(readOnly = true)
    public ChaveResponse buscarChaveAtiva(UUID realmId) {
        Optional<ChaveCriptografica> chaveOpt = chaveRepository.findByRealmIdAndStatus(realmId, StatusChave.ATIVA);

        ChaveCriptografica chave = chaveOpt
                .orElseThrow(() -> new NenhumaChaveAtivaException(realmId));

        return mapToResponse(chave);
    }

    @Override
    @Transactional(readOnly = true)
    public List<ChaveResponse> buscarChavesParaValidacao(UUID realmId) {
        List<StatusChave> statuses = List.of(StatusChave.ATIVA, StatusChave.INATIVA);
        List<ChaveCriptografica> chaves = chaveRepository.findByRealmIdAndStatusInOrderByDataCriacaoDesc(realmId,
                statuses);

        return chaves.stream()
                .map(this::mapToResponse)
                .toList();
    }

    @Override
    @Transactional(readOnly = true)
    public List<ChaveResponse> listar(UUID realmId, StatusChave status) {
        // Validate realm exists
        var realm = realmRepository.findById(realmId)
                .orElseThrow(() -> new RealmNotFoundException(realmId));

        List<ChaveCriptografica> chaves;
        if (status != null) {
            chaves = chaveRepository.findAllByRealmIdAndStatus(realmId, status);
        } else {
            chaves = chaveRepository.findByRealmIdOrderByDataCriacaoDesc(realmId);
        }

        return chaves.stream()
                .map(chave -> mapToResponseWithNextRotation(chave, realm))
                .toList();
    }

    /**
     * Maps ChaveCriptografica entity to ChaveResponse DTO.
     *
     * @param chave The entity to map
     * @return The response DTO
     */
    private ChaveResponse mapToResponse(ChaveCriptografica chave) {
        String proximaRotacao = calcularProximaRotacao(chave);

        return new ChaveResponse(
                chave.getId(),
                chave.getVersao(),
                chave.getRealm().getId(),
                chave.getRealm().getNome(),
                chave.getStatus(),
                chave.getPublicKey(),
                chave.getDataCriacao(),
                chave.getDataInativacao(),
                chave.getDataExpiracao(),
                proximaRotacao);
    }

    /**
     * Maps ChaveCriptografica entity to ChaveResponse DTO with next rotation info.
     *
     * @param chave The entity to map
     * @param realm The realm entity
     * @return The response DTO with next rotation
     */
    private ChaveResponse mapToResponseWithNextRotation(ChaveCriptografica chave,
            br.com.plataforma.conexaodigital.realm.domain.model.Realm realm) {
        String proximaRotacao = calcularProximaRotacao(chave);

        return new ChaveResponse(
                chave.getId(),
                chave.getVersao(),
                realm.getId(),
                realm.getNome(),
                chave.getStatus(),
                chave.getPublicKey(),
                chave.getDataCriacao(),
                chave.getDataInativacao(),
                chave.getDataExpiracao(),
                proximaRotacao);
    }

    /**
     * Calculates the next automatic rotation date for a key.
     *
     * @param chave The key entity
     * @return Next rotation date as string or null if expired
     */
    private String calcularProximaRotacao(ChaveCriptografica chave) {
        if (chave.getStatus() == StatusChave.EXPIRADA) {
            return null;
        }

        LocalDateTime baseDate;

        // Find the last automatic rotation for this realm
        Optional<RotacaoChave> ultimaRotacao = rotacaoRepository
                .findTopByRealmAndTipoOrderByDataRotacaoDesc(chave.getRealm(), TipoRotacao.AUTOMATICA);

        if (ultimaRotacao.isPresent()) {
            baseDate = ultimaRotacao.get().getDataRotacao();
        } else {
            // If no automatic rotation, use key creation date
            baseDate = chave.getDataCriacao();
        }

        // Calculate next rotation: first day of next month at 00:00
        LocalDateTime proximaRotacao = baseDate.plusMonths(1).withDayOfMonth(1).withHour(0).withMinute(0).withSecond(0)
                .withNano(0);

        return proximaRotacao.toString();
    }
}
```
```java
package br.com.plataforma.conexaodigital.chave.domain.service.impl;

import br.com.plataforma.conexaodigital.chave.api.responses.ChaveResponse;
import br.com.plataforma.conexaodigital.chave.api.responses.RotacaoChaveResponse;
import br.com.plataforma.conexaodigital.chave.domain.exception.CriptografiaException;
import br.com.plataforma.conexaodigital.chave.domain.exception.NenhumaChaveAtivaException;
import br.com.plataforma.conexaodigital.chave.domain.exception.RealmNotFoundException;
import br.com.plataforma.conexaodigital.chave.domain.model.ChaveCriptografica;
import br.com.plataforma.conexaodigital.chave.domain.model.RotacaoChave;
import br.com.plataforma.conexaodigital.chave.domain.model.StatusChave;
import br.com.plataforma.conexaodigital.chave.domain.model.TipoRotacao;
import br.com.plataforma.conexaodigital.chave.domain.repository.ChaveCriptograficaRepository;
import br.com.plataforma.conexaodigital.chave.domain.repository.RotacaoChaveRepository;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import br.com.plataforma.conexaodigital.chave.domain.service.ChaveService;
import br.com.plataforma.conexaodigital.chave.domain.service.RotacaoChaveService;
import br.com.plataforma.conexaodigital.chave.infrastructure.criptografia.AesCriptografiaService;
import br.com.plataforma.conexaodigital.chave.infrastructure.criptografia.RsaKeyGenerator;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.security.KeyPair;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Implementation of RotacaoChaveService for key rotation operations.
 */
@Service
@RequiredArgsConstructor
@Transactional
public class RotacaoChaveServiceImpl implements RotacaoChaveService {

    private final ChaveCriptograficaRepository chaveRepository;
    private final RotacaoChaveRepository rotacaoRepository;
    private final RealmRepository realmRepository;
    private final RsaKeyGenerator rsaGenerator;
    private final AesCriptografiaService aesService;
    private static final Logger log = LoggerFactory.getLogger(RotacaoChaveServiceImpl.class);

    @Override
    public ChaveResponse rotacionar(UUID realmId, TipoRotacao tipo) {
        log.info("Iniciando rotação de chaves para realm: {} - Tipo: {}", realmId, tipo);

        // Validate realm exists
        var realm = realmRepository.findById(realmId)
            .orElseThrow(() -> new RealmNotFoundException(realmId));

        // Validate AES secret is properly configured
        if (!aesService.isSecretValid()) {
            throw new CriptografiaException("Segredo AES não está configurado corretamente");
        }

        try {
            // Find current active key (if exists)
            Optional<ChaveCriptografica> chaveAtualOpt = chaveRepository
                .findByRealmIdAndStatus(realmId, StatusChave.ATIVA);

            ChaveCriptografica chaveAtual = null;
            if (chaveAtualOpt.isPresent()) {
                chaveAtual = chaveAtualOpt.get();
                
                // Mark current key as inactive
                chaveAtual.inativar();
                chaveRepository.save(chaveAtual);
                
                log.info("Chave anterior marcada como inativa: {} para realm: {}", 
                    chaveAtual.getId(), realmId);
            } else if (tipo == TipoRotacao.MANUAL) {
                // For manual rotation, we expect an active key to exist
                throw new NenhumaChaveAtivaException(realmId);
            }
            // For automatic rotation, it's okay if no active key exists (first key)

            // Create new active key
            ChaveCriptografica novaChave = criarNovaChave(realm);
            novaChave = chaveRepository.save(novaChave);

            // Record rotation event
            RotacaoChave rotacao = new RotacaoChave(
                realm,
                chaveAtual != null ? chaveAtual.getId() : null,
                novaChave.getId(),
                tipo,
                tipo == TipoRotacao.MANUAL ? "admin" : "system"
            );
            rotacao = rotacaoRepository.save(rotacao);

            log.info("Rotação de chaves concluída com sucesso: {} para realm: {} - Nova chave: {}", 
                rotacao.getId(), realmId, novaChave.getId());

            return mapToResponse(novaChave);

        } catch (RealmNotFoundException | NenhumaChaveAtivaException | CriptografiaException e) {
            throw e;
        } catch (Exception e) {
            log.error("Erro ao rotacionar chaves para realm: {}", realmId, e);
            throw new CriptografiaException("Erro ao rotacionar chaves", e);
        }
    }

    @Override
    @Transactional(readOnly = true)
    public List<RotacaoChaveResponse> listarRotacoesPorRealm(UUID realmId) {
        log.debug("Listando rotações para realm: {}", realmId);

        List<RotacaoChave> rotacoes = rotacaoRepository.findByRealmIdOrderByDataRotacaoDesc(realmId);

        return rotacoes.stream()
            .map(this::mapToResponse)
            .toList();
    }

    @Override
    @Transactional(readOnly = true)
    public RotacaoChaveResponse buscarRotacaoMaisRecente(UUID realmId) {
        log.debug("Buscando rotação mais recente para realm: {}", realmId);

        Optional<RotacaoChave> rotacaoOpt = rotacaoRepository.findMostRecentByRealmId(realmId);

        return rotacaoOpt
            .map(this::mapToResponse)
            .orElseThrow(() -> new NenhumaChaveAtivaException(realmId));
    }

    @Override
    @Transactional(readOnly = true)
    public List<RotacaoChaveResponse> historico(UUID realmId, TipoRotacao tipo, LocalDateTime dataInicio, LocalDateTime dataFim) {
        log.debug("Buscando histórico de rotações para realm: {} - tipo: {} - período: {} a {}", 
            realmId, tipo, dataInicio, dataFim);

        // Validate realm exists
        var realm = realmRepository.findById(realmId)
            .orElseThrow(() -> new RealmNotFoundException(realmId));

        // Get all rotations for the realm
        List<RotacaoChave> rotacoes = rotacaoRepository.findByRealmIdOrderByDataRotacaoDesc(realmId);

        // Apply filters
        if (tipo != null) {
            rotacoes = rotacoes.stream()
                .filter(r -> r.getTipo() == tipo)
                .toList();
        }

        if (dataInicio != null) {
            rotacoes = rotacoes.stream()
                .filter(r -> !r.getDataRotacao().isBefore(dataInicio))
                .toList();
        }

        if (dataFim != null) {
            rotacoes = rotacoes.stream()
                .filter(r -> !r.getDataRotacao().isAfter(dataFim))
                .toList();
        }

        return rotacoes.stream()
            .map(this::mapToResponse)
            .toList();
    }

    /**
     * Creates a new cryptographic key for the specified realm.
     *
     * @param realm The realm to create the key for
     * @return The new ChaveCriptografica entity
     * @throws CriptografiaException if key generation or encryption fails
     */
    private ChaveCriptografica criarNovaChave(br.com.plataforma.conexaodigital.realm.domain.model.Realm realm) {
        try {
            // Generate RSA key pair
            KeyPair keyPair = rsaGenerator.generateKeyPair();
            
            // Validate key pair
            if (!rsaGenerator.validateKeyPair(keyPair)) {
                throw new CriptografiaException("Par de chaves gerado é inválido");
            }

            // Create encrypted key entity
            UUID versao = UUID.randomUUID();
            ChaveCriptografica chave = new ChaveCriptografica(
                versao,
                realm,
                rsaGenerator.publicKeyToString(keyPair.getPublic()),
                aesService.encrypt(rsaGenerator.privateKeyToString(keyPair.getPrivate())),
                StatusChave.ATIVA
            );

            log.debug("Nova chave criada com versão: {} para realm: {}", versao, realm.getId());

            return chave;

        } catch (Exception e) {
            log.error("Erro ao criar nova chave para realm: {}", realm.getId(), e);
            throw new CriptografiaException("Erro ao criar nova chave", e);
        }
    }

    /**
     * Maps ChaveCriptografica entity to ChaveResponse DTO.
     *
     * @param chave The entity to map
     * @return The response DTO
     */
    private ChaveResponse mapToResponse(ChaveCriptografica chave) {
        String proximaRotacao = null;
        
        return new ChaveResponse(
            chave.getId(),
            chave.getVersao(),
            chave.getRealm().getId(),
            chave.getRealm().getNome(),
            chave.getStatus(),
            chave.getPublicKey(),
            chave.getDataCriacao(),
            chave.getDataInativacao(),
            chave.getDataExpiracao(),
            proximaRotacao
        );
    }

    /**
     * Maps RotacaoChave entity to RotacaoChaveResponse DTO.
     *
     * @param rotacao The entity to map
     * @return The response DTO
     */
    private RotacaoChaveResponse mapToResponse(RotacaoChave rotacao) {
        // Buscar versões das chaves anterior e nova
        String versaoAntiga = null;
        if (rotacao.getChaveAnteriorId() != null) {
            try {
                versaoAntiga = chaveRepository.findById(rotacao.getChaveAnteriorId())
                    .map(chave -> chave.getVersao().toString())
                    .orElse(null);
            } catch (Exception e) {
                log.debug("Não foi possível buscar versão da chave anterior: {}", rotacao.getChaveAnteriorId());
            }
        }

        String versaoNova = null;
        if (rotacao.getChaveNovaId() != null) {
            try {
                versaoNova = chaveRepository.findById(rotacao.getChaveNovaId())
                    .map(chave -> chave.getVersao().toString())
                    .orElse(null);
            } catch (Exception e) {
                log.debug("Não foi possível buscar versão da chave nova: {}", rotacao.getChaveNovaId());
            }
        }

        // Determinar motivo baseado no tipo de rotação
        final String motivo = rotacao.getTipo() == TipoRotacao.MANUAL ? "Rotação manual" : "Rotação automática mensal";

        // Responsável é o solicitante
        final String responsavel = rotacao.getSolicitante();

        // Status sempre CONCLUIDA para histórico
        final String status = "CONCLUIDA";

        return new RotacaoChaveResponse(
            rotacao.getId(),
            rotacao.getRealm().getId(),
            rotacao.getRealm().getNome(),
            rotacao.getChaveAnteriorId(),
            rotacao.getChaveNovaId(),
            versaoAntiga,
            versaoNova,
            rotacao.getTipo(),
            motivo,
            rotacao.getDataRotacao(),
            rotacao.getSolicitante(),
            responsavel,
            status
        );
    }
}
```
```java
package br.com.plataforma.conexaodigital.chave.infrastructure.criptografia;

import br.com.plataforma.conexaodigital.chave.domain.exception.CriptografiaException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.Base64;

/**
 * Service for AES-128 encryption and decryption operations.
 * Used to encrypt private keys before storing them in the database.
 */
@Component
public class AesCriptografiaService {

    private static final String ALGORITHM = "AES";
    private static final String TRANSFORMATION = "AES/CBC/PKCS5Padding";
    private static final int KEY_LENGTH = 16; // 128 bits
    private static final int IV_LENGTH = 16; // 128 bits

    @Value("${chave.aes.secret:default-secret-key-change-in-production}")
    private String aesSecret;

    private final SecureRandom secureRandom = new SecureRandom();

    /**
     * Encrypts data using AES-128 with CBC mode and PKCS5 padding.
     *
     * @param data The data to encrypt
     * @return Base64 encoded encrypted data (IV + encrypted data)
     * @throws CriptografiaException if encryption fails
     */
    public String encrypt(String data) {
        try {
            // Validate secret before attempting encryption
            if (aesSecret == null || aesSecret.isEmpty()) {
                throw new CriptografiaException("Segredo AES não está configurado");
            }

            // Generate a proper key from the secret
            SecretKeySpec keySpec = generateKeyFromSecret();

            // Generate random IV
            byte[] iv = new byte[IV_LENGTH];
            secureRandom.nextBytes(iv);
            IvParameterSpec ivSpec = new IvParameterSpec(iv);

            // Encrypt the data
            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);
            byte[] encrypted = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));

            // Combine IV and encrypted data, then encode as Base64
            byte[] combined = new byte[IV_LENGTH + encrypted.length];
            System.arraycopy(iv, 0, combined, 0, IV_LENGTH);
            System.arraycopy(encrypted, 0, combined, IV_LENGTH, encrypted.length);

            return Base64.getEncoder().encodeToString(combined);
        } catch (CriptografiaException e) {
            throw e; // Re-throw CriptografiaException
        } catch (Exception e) {
            throw new CriptografiaException("Erro ao criptografar dados com AES-128", e);
        }
    }

    /**
     * Decrypts data using AES-128 with CBC mode and PKCS5 padding.
     *
     * @param encryptedData Base64 encoded encrypted data (IV + encrypted data)
     * @return The decrypted data
     * @throws CriptografiaException if decryption fails
     */
    public String decrypt(String encryptedData) {
        try {
            // Generate a proper key from the secret
            SecretKeySpec keySpec = generateKeyFromSecret();
            
            // Decode the combined data
            byte[] combined = Base64.getDecoder().decode(encryptedData);
            
            // Extract IV and encrypted data
            byte[] iv = new byte[IV_LENGTH];
            byte[] encrypted = new byte[combined.length - IV_LENGTH];
            System.arraycopy(combined, 0, iv, 0, IV_LENGTH);
            System.arraycopy(combined, IV_LENGTH, encrypted, 0, encrypted.length);
            
            // Decrypt the data
            IvParameterSpec ivSpec = new IvParameterSpec(iv);
            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
            byte[] decrypted = cipher.doFinal(encrypted);
            
            return new String(decrypted, StandardCharsets.UTF_8);
        } catch (Exception e) {
            throw new CriptografiaException("Erro ao descriptografar dados com AES-128", e);
        }
    }

    /**
     * Generates a proper AES-128 key from the secret using SHA-256.
     *
     * @return SecretKeySpec for AES-128
     * @throws Exception if key generation fails
     */
    private SecretKeySpec generateKeyFromSecret() throws Exception {
        // Use SHA-256 to hash the secret and take first 16 bytes for AES-128
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] hash = digest.digest(aesSecret.getBytes(StandardCharsets.UTF_8));
        byte[] keyBytes = Arrays.copyOf(hash, KEY_LENGTH);
        
        return new SecretKeySpec(keyBytes, ALGORITHM);
    }

    /**
     * Validates if the AES secret is properly configured.
     *
     * @return true if the secret is valid, false otherwise
     */
    public boolean isSecretValid() {
        return aesSecret != null && !aesSecret.isEmpty() && 
               !aesSecret.equals("default-secret-key-change-in-production");
    }
}
```
```java
package br.com.plataforma.conexaodigital.chave.infrastructure.criptografia;

import br.com.plataforma.conexaodigital.chave.domain.exception.CriptografiaException;
import org.springframework.stereotype.Component;

import java.security.*;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

/**
 * Service for RSA key generation and conversion operations.
 * Generates RSA-2048 key pairs for JWT signing and validation.
 */
@Component
public class RsaKeyGenerator {

    private static final String ALGORITHM = "RSA";
    private static final int KEY_SIZE = 2048;

    /**
     * Generates a new RSA-2048 key pair.
     *
     * @return The generated KeyPair
     * @throws CriptografiaException if key generation fails
     */
    public KeyPair generateKeyPair() {
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(ALGORITHM);
            keyPairGenerator.initialize(KEY_SIZE);
            return keyPairGenerator.generateKeyPair();
        } catch (NoSuchAlgorithmException e) {
            throw new CriptografiaException("Algoritmo RSA não disponível", e);
        }
    }

    /**
     * Converts a public key to Base64 string format.
     *
     * @param publicKey The public key to convert
     * @return Base64 encoded public key
     * @throws CriptografiaException if conversion fails
     */
    public String publicKeyToString(PublicKey publicKey) {
        try {
            return Base64.getEncoder().encodeToString(publicKey.getEncoded());
        } catch (Exception e) {
            throw new CriptografiaException("Erro ao converter chave pública para string", e);
        }
    }

    /**
     * Converts a private key to Base64 string format.
     *
     * @param privateKey The private key to convert
     * @return Base64 encoded private key
     * @throws CriptografiaException if conversion fails
     */
    public String privateKeyToString(PrivateKey privateKey) {
        try {
            return Base64.getEncoder().encodeToString(privateKey.getEncoded());
        } catch (Exception e) {
            throw new CriptografiaException("Erro ao converter chave privada para string", e);
        }
    }

    /**
     * Converts a Base64 string to a public key.
     *
     * @param publicKeyBase64 Base64 encoded public key
     * @return The PublicKey object
     * @throws CriptografiaException if conversion fails
     */
    public PublicKey stringToPublicKey(String publicKeyBase64) {
        try {
            byte[] keyBytes = Base64.getDecoder().decode(publicKeyBase64);
            X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
            KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM);
            return keyFactory.generatePublic(spec);
        } catch (Exception e) {
            throw new CriptografiaException("Erro ao converter string para chave pública", e);
        }
    }

    /**
     * Converts a Base64 string to a private key.
     *
     * @param privateKeyBase64 Base64 encoded private key
     * @return The PrivateKey object
     * @throws CriptografiaException if conversion fails
     */
    public PrivateKey stringToPrivateKey(String privateKeyBase64) {
        try {
            byte[] keyBytes = Base64.getDecoder().decode(privateKeyBase64);
            PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
            KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM);
            return keyFactory.generatePrivate(spec);
        } catch (Exception e) {
            throw new CriptografiaException("Erro ao converter string para chave privada", e);
        }
    }

    /**
     * Converts a PEM formatted public key to a PublicKey object.
     *
     * @param publicKeyPem PEM formatted public key
     * @return The PublicKey object
     * @throws CriptografiaException if conversion fails
     */
    public PublicKey pemToPublicKey(String publicKeyPem) {
        try {
            String cleanPem = publicKeyPem
                .replace("-----BEGIN PUBLIC KEY-----", "")
                .replace("-----END PUBLIC KEY-----", "")
                .replaceAll("\\s", "");
            
            return stringToPublicKey(cleanPem);
        } catch (Exception e) {
            throw new CriptografiaException("Erro ao converter PEM para chave pública", e);
        }
    }

    /**
     * Converts a PEM formatted private key to a PrivateKey object.
     *
     * @param privateKeyPem PEM formatted private key
     * @return The PrivateKey object
     * @throws CriptografiaException if conversion fails
     */
    public PrivateKey pemToPrivateKey(String privateKeyPem) {
        try {
            String cleanPem = privateKeyPem
                .replace("-----BEGIN PRIVATE KEY-----", "")
                .replace("-----END PRIVATE KEY-----", "")
                .replaceAll("\\s", "");
            
            return stringToPrivateKey(cleanPem);
        } catch (Exception e) {
            throw new CriptografiaException("Erro ao converter PEM para chave privada", e);
        }
    }

    /**
     * Validates if a key pair is properly formatted and has the correct size.
     *
     * @param keyPair The key pair to validate
     * @return true if the key pair is valid, false otherwise
     */
    public boolean validateKeyPair(KeyPair keyPair) {
        try {
            PublicKey publicKey = keyPair.getPublic();
            PrivateKey privateKey = keyPair.getPrivate();

            // Check algorithm
            if (!ALGORITHM.equals(publicKey.getAlgorithm()) ||
                !ALGORITHM.equals(privateKey.getAlgorithm())) {
                return false;
            }

            // X.509/PKCS#8 encoded keys include metadata, so they're larger than 256 bytes.
            // Check that both keys have reasonable size (at least 256 bytes for RSA-2048)
            int minKeySize = 256; // 2048 bits minimum
            if (publicKey.getEncoded().length < minKeySize ||
                privateKey.getEncoded().length < minKeySize) {
                return false;
            }

            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
```
```java
package br.com.plataforma.conexaodigital.chave.infrastructure.scheduler;

import java.time.LocalDateTime;
import java.time.YearMonth;

import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import br.com.plataforma.conexaodigital.auditoria.domain.model.enums.TipoEventoAuditoria;
import br.com.plataforma.conexaodigital.auditoria.domain.service.AuditoriaService;
import br.com.plataforma.conexaodigital.chave.api.responses.ChaveResponse;
import br.com.plataforma.conexaodigital.chave.domain.model.TipoRotacao;
import br.com.plataforma.conexaodigital.chave.domain.repository.RotacaoChaveRepository;
import br.com.plataforma.conexaodigital.chave.domain.service.RotacaoChaveService;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Lazy;

@Component
@RequiredArgsConstructor
@Slf4j
public class RotacaoChaveScheduler {

    private final RotacaoChaveService rotacaoService;
    private final RealmRepository realmRepository;
    private final RotacaoChaveRepository rotacaoRepository;
    @Lazy
    private final AuditoriaService auditoriaService;

    @Scheduled(cron = "0 0 0 1 * ?")
    @Transactional
    public void rotacionarChavesAutomaticamente() {
        log.info("Iniciando rotação automática de chaves");

        realmRepository.findAll().forEach(realm -> {
            try {
                if (deveRotacionar(realm)) {
                    log.info("Iniciando rotação automática para realm: {}", realm.getNome());
                    ChaveResponse novaChave = rotacaoService.rotacionar(realm.getId(), TipoRotacao.AUTOMATICA);
                    log.info("Chaves rotacionadas automaticamente para realm: {} - Nova chave ID: {}",
                            realm.getNome(), novaChave.id());

                    auditoriaService.registrarEvento(
                            TipoEventoAuditoria.ROTACAO_CHAVE_AUTOMATICA,
                            "Rotação automática de chaves executada para realm: " + realm.getNome(),
                            realm.getId());
                } else {
                    log.info("Ignorando realm {}: já houve rotação automática este mês", realm.getNome());
                }
            } catch (Exception e) {
                log.error("Erro ao rotacionar chaves para realm: {}", realm.getNome(), e);
                auditoriaService.registrarEvento(
                        TipoEventoAuditoria.ROTACAO_CHAVE_AUTOMATICA,
                        "Erro na rotação automática de chaves para realm: " + realm.getNome() + " - Erro: "
                                + e.getMessage(),
                        realm.getId());
            }
        });

        log.info("Rotação automática de chaves concluída");
    }

    private boolean deveRotacionar(br.com.plataforma.conexaodigital.realm.domain.model.Realm realm) {
        YearMonth mesAtual = YearMonth.now();

        var ultimaRotacaoAutomatica = rotacaoRepository
                .findTopByRealmAndTipoOrderByDataRotacaoDesc(realm, TipoRotacao.AUTOMATICA);

        if (ultimaRotacaoAutomatica.isEmpty()) {
            log.debug("Não há rotações anteriores para realm: {}, deve rotacionar", realm.getNome());
            return true;
        }

        LocalDateTime dataUltimaRotacao = ultimaRotacaoAutomatica.get().getDataRotacao();
        YearMonth mesUltimaRotacao = YearMonth.from(dataUltimaRotacao);

        boolean deveRotacionar = !mesUltimaRotacao.equals(mesAtual);
        log.debug("Realm: {} - Última rotação: {} - Mês atual: {} - Deve rotacionar: {}",
                realm.getNome(), mesUltimaRotacao, mesAtual, deveRotacionar);

        return deveRotacionar;
    }
}

```
```java
package br.com.plataforma.conexaodigital.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.AuditorAware;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;

import java.util.Optional;

/**
 * Implementação do AuditorAware para JPA Auditing.
 * Retorna o usuário autenticado como responsável pelas alterações.
 */
@Slf4j
public class AuditorAwareImpl implements AuditorAware<String> {

    @Override
    public Optional<String> getCurrentAuditor() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

        if (authentication == null || !authentication.isAuthenticated()) {
            return Optional.of("system");
        }

        // Se for JWT, extrai o email ou sub
        if (authentication instanceof JwtAuthenticationToken jwtToken) {
            Jwt jwt = jwtToken.getToken();
            String email = jwt.getClaim("email");
            String sub = jwt.getClaim("sub");

            if (email != null) {
                return Optional.of(email);
            }
            if (sub != null) {
                return Optional.of(sub);
            }
        }

        // Se for autenticação padrão (username/password)
        if (authentication.getPrincipal() instanceof String principal) {
            return Optional.of(principal);
        }

        log.debug("Não foi possível determinar o auditor para auth: {}", authentication.getClass());

        return Optional.of("unknown");
    }
}

```
```java
package br.com.plataforma.conexaodigital.config;

import br.com.plataforma.conexaodigital.usuario.domain.model.Usuario;
import br.com.plataforma.conexaodigital.usuario.domain.repository.UsuarioRepository;
import br.com.plataforma.conexaodigital.usuario.domain.model.enums.StatusUsuario;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.Collections;

/**
 * Implementação customizada do UserDetailsService para carregar usuários do banco de dados.
 */
@Service
@Slf4j
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {

    private final UsuarioRepository usuarioRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        log.debug("Carregando usuário: {}", username);

        // Buscar usuário por email (username é o email neste caso)
        // TODO: Adicionar suporte a CPF quando campo for adicionado na entidade Usuario
        Usuario usuario = usuarioRepository.buscarPorEmailAtivo(username)
                .orElseThrow(() -> {
                    log.warn("Usuário não encontrado: {}", username);
                    return new UsernameNotFoundException("User not found: " + username);
                });

        log.debug("Usuário encontrado: {}, Status: {}", usuario.getEmail(), usuario.getStatus());

        // Valida se o usuário está bloqueado (embora a query já filtre ATIVO)
        if (StatusUsuario.BLOQUEADO.equals(usuario.getStatus())) {
            log.warn("Usuário bloqueado: {}", username);
            throw new UsernameNotFoundException("Usuário bloqueado: " + username);
        }

        // TODO: Carregar roles do banco quando a relação many-to-many for implementada
        // Por enquanto, usa ROLE_USER como padrão
        var authorities = Collections.singletonList(
                new SimpleGrantedAuthority("ROLE_USER")
        );

        return User.builder()
                .username(usuario.getEmail())
                .password(usuario.getSenha())
                .authorities(authorities)
                .accountLocked(StatusUsuario.BLOQUEADO.equals(usuario.getStatus()))
                .disabled(!StatusUsuario.ATIVO.equals(usuario.getStatus()))
                .build();
    }
}

```
```java
package br.com.plataforma.conexaodigital.config;

import org.springframework.boot.CommandLineRunner;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import br.com.plataforma.conexaodigital.bootstrap.domain.service.BootstrapService;
import br.com.plataforma.conexaodigital.bootstrap.domain.service.OAuth2ClientBootstrapService;
import br.com.plataforma.conexaodigital.bootstrap.domain.service.RealmBootstrapService;
import br.com.plataforma.conexaodigital.bootstrap.domain.service.RoleBootstrapService;
import br.com.plataforma.conexaodigital.bootstrap.domain.service.UsuarioBootstrapService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Componente de inicialização da aplicação.
 * Responsável por disparar o processo de bootstrap do sistema
 * apenas quando configurado e necessário.
 *
 * Esta classe segue o Princípio da Responsabilidade Única (SRP):
 * - Única responsabilidade: coordenar a inicialização do sistema
 * - Delega a criação de dados para serviços especializados
 * - Não mocka dados nem cria chaves manualmente
 */
@Slf4j
@Component
@RequiredArgsConstructor
@Order(Ordered.HIGHEST_PRECEDENCE)
public class DatabaseInitializationRunner implements CommandLineRunner {

    private final BootstrapService bootstrapService;
    private final RealmBootstrapService realmBootstrapService;
    private final RoleBootstrapService roleBootstrapService;
    private final UsuarioBootstrapService usuarioBootstrapService;
    private final OAuth2ClientBootstrapService oauth2ClientBootstrapService;

    @Value("${bootstrap.habilitado:true}")
    private boolean bootstrapHabilitado;

    @Override
    @Transactional
    public void run(String... args) throws Exception {
        if (!bootstrapHabilitado) {
            log.info("Bootstrap desabilitado via configuração. Pulando inicialização.");
            return;
        }

        // Verificar se o bootstrap já foi executado anteriormente
        if (bootstrapService.obterStatus().bootstrapConcluido()) {
            log.info("Bootstrap já foi executado anteriormente. Pulando inicialização.");
            return;
        }

        log.info("Iniciando bootstrap do sistema via DatabaseInitializationRunner...");

        try {
            bootstrapService.executarBootstrap();
            log.info("Bootstrap do sistema concluído com sucesso!");
        } catch (Exception e) {
            log.error("Falha crítica durante bootstrap do sistema", e);
            throw e; // Propaga para falhar a inicialização se necessário
        }
    }
}
```
```java
package br.com.plataforma.conexaodigital.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.domain.AuditorAware;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

/**
 * Configuração para JPA Auditing.
 * Habilita o preenchimento automático de campos de auditoria (createdDate, lastModifiedDate).
 */
@Configuration
@EnableJpaAuditing
public class JpaAuditingConfig {

    @Bean
    public AuditorAware<String> auditorAware() {
        return new AuditorAwareImpl();
    }
}

```
```java
package br.com.plataforma.conexaodigital.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import io.swagger.v3.oas.models.servers.Server;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;

/**
 * Configuration class for OpenAPI/Swagger documentation.
 *
 * <p>This class sets up the OpenAPI documentation for the Conexão Auth API,
 * including server configurations, security schemes (Bearer JWT), and API metadata.</p>
 *
 * <p>Access points:</p>
 * <ul>
 *   <li>Swagger UI: /swagger-ui.html</li>
 *   <li>OpenAPI JSON: /v3/api-docs</li>
 * </ul>
 */
@Configuration
public class OpenApiConfig {

    private static final String SECURITY_SCHEME_BEARER = "bearerAuth";
    private static final String SECURITY_SCHEME_BASIC = "basicAuth";

    @Value("${server.port:8080}")
    private int serverPort;

    @Value("${app.base-url:http://localhost}")
    private String baseUrl;

    /**
     * Creates and configures OpenAPI bean.
     *
     * @return configured OpenAPI instance with API metadata, servers, and security
     */
    @Bean
    public OpenAPI conexaoAuthOpenAPI() {
        String localServerUrl = baseUrl + ":" + serverPort;

        return new OpenAPI()
                .info(new Info()
                        .title("API de Autenticação e Autorização - Conexão Auth")
                        .description("API REST para microserviço de identidade e autorização (Authorization Server)")
                        .version("1.0.0")
                        .contact(new Contact()
                                .name("Equipe Conexão Auth")
                                .email("contato@conexaoauth.com")
                        )
                        .license(new License()
                                .name("MIT License")
                                .url("https://opensource.org/licenses/MIT")
                        )
                )
                 .servers(List.of(
                         new Server().url(localServerUrl).description("Local - Porta " + serverPort),
                         new Server().url("https://dev.api.conexaoauth.com").description("Homologação"),
                         new Server().url("https://api.conexaoauth.com").description("Produção")
                 ))
                .addSecurityItem(new SecurityRequirement().addList(SECURITY_SCHEME_BEARER))
                .components(new Components()
                        .addSecuritySchemes(SECURITY_SCHEME_BEARER,
                                new SecurityScheme()
                                        .type(SecurityScheme.Type.HTTP)
                                        .scheme("bearer")
                                        .bearerFormat("JWT")
                                        .description("Token JWT de autenticação para APIs protegidas (usado em /api/*)")
                        )
                        .addSecuritySchemes(SECURITY_SCHEME_BASIC,
                                new SecurityScheme()
                                        .type(SecurityScheme.Type.HTTP)
                                        .scheme("basic")
                                        .description("Autenticação HTTP Basic para endpoints OAuth2 (clientId:clientSecret em /oauth2/token)")
                        )
                );
    }
}

```
```java
package br.com.plataforma.conexaodigital.config;

import javax.sql.DataSource;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl;
import org.springframework.security.web.authentication.rememberme.PersistentTokenRepository;

import br.com.plataforma.conexaodigital.admin.security.CustomAuthenticationFailureHandler;
import br.com.plataforma.conexaodigital.admin.security.CustomAuthenticationSuccessHandler;
import lombok.extern.slf4j.Slf4j;

/**
 * Configuração de segurança da aplicação.
 * Define regras de autenticação, autorização, remember-me e sessão.
 * Unifica configurações de segurança do Admin Dashboard e OAuth2.
 */
@Configuration
@EnableWebSecurity
@Slf4j
public class SecurityConfig {

        private final DataSource dataSource;
        private final CustomUserDetailsService userDetailsService;
        private final CustomAuthenticationSuccessHandler successHandler;
        private final CustomAuthenticationFailureHandler failureHandler;

        public SecurityConfig(
                        DataSource dataSource,
                        CustomUserDetailsService userDetailsService,
                        CustomAuthenticationSuccessHandler successHandler,
                        CustomAuthenticationFailureHandler failureHandler) {
                this.dataSource = dataSource;
                this.userDetailsService = userDetailsService;
                this.successHandler = successHandler;
                this.failureHandler = failureHandler;
        }

        /**
         * Configura o repositório de tokens persistentes para remember-me.
         * Permite revogação de tokens e maior segurança.
         *
         * @return PersistentTokenRepository
         */
        @Bean
        public PersistentTokenRepository persistentTokenRepository() {
                JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl();
                tokenRepository.setDataSource(dataSource);

                // Criar tabela automaticamente se não existir
                // tokenRepository.setCreateTableOnStartup(true);

                return tokenRepository;
        }

        /**
         * Configura o encoder de senha usando BCrypt.
         * Este bean pode ser injetado como "passwordEncoder" ou
         * "oauth2PasswordEncoder".
         *
         * @return PasswordEncoder BCrypt com strength 12
         */
@Bean({ "passwordEncoder", "oauth2PasswordEncoder" })
        public PasswordEncoder passwordEncoder() {
                // Configurando PasswordEncoder BCrypt com strength 12
                return new BCryptPasswordEncoder(12);
        }

        /**
         * Configura o SecurityFilterChain com regras de autenticação e autorização.
         *
         * @param http            HttpSecurity para configuração
         * @param tokenRepository Repositório de tokens remember-me
         * @return SecurityFilterChain configurado
         * @throws Exception Exceção de configuração
         */
        @Bean
        public SecurityFilterChain securityFilterChain(
                        HttpSecurity http,
                        PersistentTokenRepository tokenRepository) throws Exception {
                http
                                // Autorização de requisições
                                .authorizeHttpRequests(auth -> auth
                                                // ROTAS PÚBLICAS - SEM AUTENTICAÇÃO (ordem importante!)
                                                .requestMatchers("/api/v1/usuarios/validar-codigo-recuperacao")
                                                .permitAll()
                                                .requestMatchers("/api/v1/auth/recuperar-senha/**").permitAll()
                                                .requestMatchers("/.well-known/**", "/oauth2/jwks/**", "/oauth2/token")
                                                .permitAll()
                                                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**",
                                                                "/swagger-ui.html")
                                                .permitAll()
                                                .requestMatchers("/actuator/**").permitAll()
                                                .requestMatchers("/api/v1/public/**").permitAll()
                                                .requestMatchers("/h2-console/**").permitAll()
                                                .requestMatchers("/webjars/**").permitAll()
                                                .requestMatchers("/css/**", "/js/**", "/images/**", "/plugins/**",
                                                                "/fonts/**")
                                                .permitAll()
                                                .requestMatchers("/admin/login", "/admin/cadastro",
                                                                "/admin/recuperar-senha")
                                                .permitAll()
                                                // Todas as outras requisições requerem autenticação
                                                .anyRequest().authenticated())
                                // Configuração de formulário de login
                                .formLogin(form -> form
                                                .loginPage("/admin/login")
                                                .loginProcessingUrl("/admin/login")
                                                .usernameParameter("username")
                                                .passwordParameter("password")
                                                .defaultSuccessUrl("/admin/dashboard", true)
                                                .successHandler(successHandler)
                                                .failureHandler(failureHandler)
                                                .permitAll())
                                // Configuração de logout
                                .logout(logout -> logout
                                                .logoutUrl("/admin/logout")
                                                .logoutSuccessUrl("/admin/login?logout=true")
                                                .invalidateHttpSession(true)
                                                .clearAuthentication(true)
                                                .deleteCookies("JSESSIONID", "remember-me"))
                                // Configuração CORS para permitir Swagger UI e aplicações externas
                                .cors(cors -> cors.configurationSource(request -> {
                                        var config = new org.springframework.web.cors.CorsConfiguration();
                                        config.setAllowedOriginPatterns(
                                                        java.util.List.of("http://localhost:*", "https://localhost:*"));
                                        config.setAllowedMethods(java.util.List.of("GET", "POST", "PUT", "DELETE",
                                                        "OPTIONS", "HEAD"));
                                        config.setAllowedHeaders(java.util.List.of("*"));
                                        config.setAllowCredentials(false);
                                        config.setMaxAge(3600L);
                                        return config;
                                }))
                                // Configuração de Remember-me
                                .rememberMe(remember -> remember
                                                .key("conexaoauth-remember-me-secret-key-change-in-production") // MUST
                                                                                                                // be
                                                                                                                // unique
                                                .tokenValiditySeconds(7 * 24 * 60 * 60) // 7 dias em segundos
                                                .rememberMeParameter("remember-me")
                                                .rememberMeCookieName("remember-me")
                                                .userDetailsService(userDetailsService)
                                                .tokenRepository(tokenRepository))
                                // Configuração de gestão de sessão
                                .sessionManagement(session -> session
                                                .sessionFixation().migrateSession()
                                                .maximumSessions(1)

                                                .maxSessionsPreventsLogin(false))
                                 // Configuração de CSRF
                                 // OAuth2 RFC 6749: o endpoint /oauth2/token não exige CSRF pois usa autenticação
                                 // HTTP Basic (client_id:client_secret) como proteção
                                 .csrf(csrf -> csrf
                                                 .ignoringRequestMatchers("/oauth2/token")
                                                 .ignoringRequestMatchers("/api/v1/public/**")
                                                 .ignoringRequestMatchers("/h2-console/**")
                                                 .ignoringRequestMatchers("/api/v1/auth/recuperar-senha/**")
                                                 .ignoringRequestMatchers("/api/v1/usuarios/validar-codigo-recuperacao")
                                                 .ignoringRequestMatchers("/admin/usuarios/*/bloquear")
                                                 .ignoringRequestMatchers("/admin/usuarios/*/desbloquear")
                                                 .ignoringRequestMatchers("/admin/usuarios/*/ativar")
                                                 .ignoringRequestMatchers("/admin/usuarios/*/reset-senha")
                                                 .ignoringRequestMatchers("/css/**", "/js/**", "/images/**",
                                                                 "/plugins/**", "/fonts/**"))
                                // Configuração de headers para H2 console
                                .headers(headers -> headers
                                                .frameOptions(frameOptions -> frameOptions.sameOrigin()));

                return http.build();
        }
}

```
```java
package br.com.plataforma.conexaodigital.config;

import jakarta.validation.Validator;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.validation.beanvalidation.MethodValidationPostProcessor;

import jakarta.validation.Validation;

@Configuration
public class ValidationConfig {

    @Bean
    public Validator validator() {
        return Validation.buildDefaultValidatorFactory().getValidator();
    }

    @Bean
    public MethodValidationPostProcessor methodValidationPostProcessor() {
        MethodValidationPostProcessor processor = new MethodValidationPostProcessor();
        processor.setValidator(validator());
        return processor;
    }
}

```
```java
package br.com.plataforma.conexaodigital.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.filter.HiddenHttpMethodFilter;

/**
 * Configuração do Web MVC.
 * Habilita o filtro para simular métodos HTTP PUT/DELETE em formulários HTML.
 */
@Configuration
public class WebMvcConfig {

    /**
     * Habilita o filtro que permite simular métodos HTTP PUT/DELETE
     * através do campo oculto _method em formulários HTML.
     * Navegadores suportam nativamente apenas GET e POST.
     *
     * @return HiddenHttpMethodFilter configurado
     */
    @Bean
    public HiddenHttpMethodFilter hiddenHttpMethodFilter() {
        return new HiddenHttpMethodFilter();
    }
}

```
```java
package br.com.plataforma.conexaodigital.email.config;

import java.util.Properties;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.JavaMailSenderImpl;

import lombok.Data;

/**
 * Configuração do serviço de email.
 */
@Data
@Configuration
@ConfigurationProperties(prefix = "email")
public class EmailConfig {

    private String host;
    private int port;
    private String username;
    private String password;
    private String from;
    private String fromName;
    private boolean auth = true;
    private boolean starttls = true;
    private int timeout = 5000;

    @Bean
    public JavaMailSender javaMailSender() {
        JavaMailSenderImpl mailSender = new JavaMailSenderImpl();
        mailSender.setHost(host);
        mailSender.setPort(port);
        mailSender.setUsername(username);
        mailSender.setPassword(password);

        Properties props = mailSender.getJavaMailProperties();
        props.put("mail.transport.protocol", "smtp");
        props.put("mail.smtp.auth", String.valueOf(auth));
        props.put("mail.smtp.starttls.enable", String.valueOf(starttls));
        props.put("mail.debug", "false");
        props.put("mail.smtp.connectiontimeout", timeout);
        props.put("mail.smtp.timeout", timeout);
        props.put("mail.smtp.writetimeout", timeout);

        return mailSender;
    }
}

```
```java
package br.com.plataforma.conexaodigital.email.domain.service;

/**
 * Serviço de envio de emails.
 */
public interface EmailService {

    /**
     * Envia email de recuperação de senha com código de 6 dígitos.
     *
     * @param email     Email do destinatário
     * @param codigo    Código de 6 dígitos
     * @param nomeUsuario Nome do usuário
     * @param minutosExpiracao Tempo de expiração em minutos
     */
    void enviarEmailRecuperacaoSenha(String email, String codigo, String nomeUsuario, int minutosExpiracao);

    /**
     * Envia email confirmando que a senha foi alterada.
     *
     * @param email         Email do destinatário
     * @param nomeUsuario  Nome do usuário
     * @param dataAlteracao Data/hora da alteração
     */
    void enviarEmailConfirmacaoAlteracaoSenha(String email, String nomeUsuario, String dataAlteracao);
}

```
```java
package br.com.plataforma.conexaodigital.email.domain.service.impl;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;
import org.thymeleaf.TemplateEngine;
import org.thymeleaf.context.Context;

import br.com.plataforma.conexaodigital.email.config.EmailConfig;
import br.com.plataforma.conexaodigital.email.domain.service.EmailService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Implementação do serviço de envio de emails.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class EmailServiceImpl implements EmailService {

    private final JavaMailSender mailSender;
    private final TemplateEngine templateEngine;
    private final EmailConfig emailConfig;

    @Value("${app.base-url:http://localhost:8090}")
    private String baseUrl;

    @Override
    public void enviarEmailRecuperacaoSenha(String email, String codigo, String nomeUsuario, int minutosExpiracao) {
        log.debug("Enviando email de recuperação de senha para: {}", email);

        Context context = new Context();
        context.setVariable("nome", nomeUsuario);
        context.setVariable("codigo", codigo);
        context.setVariable("minutosExpiracao", minutosExpiracao);
        context.setVariable("baseUrl", baseUrl);

        String htmlContent = templateEngine.process("email/recuperacao-senha", context);

        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(email);
        message.setSubject("Código de recuperação de senha");
        message.setText(String.format(
                "Olá %s,%n%nUse este código para redefinir sua senha: %s%n%nEste código expira em %d minutos.%n%n"
                        + "Se você não solicitou esta alteração, ignore este email.",
                nomeUsuario, codigo, minutosExpiracao));

        try {
            mailSender.send(message);
            log.info("Email de recuperação de senha enviado com sucesso para: {}", email);
        } catch (Exception e) {
            log.error("Erro ao enviar email de recuperação de senha para: {}", email, e);
            throw new RuntimeException("Erro ao enviar email de recuperação de senha", e);
        }
    }

    @Override
    public void enviarEmailConfirmacaoAlteracaoSenha(String email, String nomeUsuario, String dataAlteracao) {
        log.debug("Enviando email de confirmação de alteração de senha para: {}", email);

        SimpleMailMessage message = new SimpleMailMessage();
        message.setTo(email);
        message.setSubject("Senha alterada com sucesso");
        message.setText(String.format("Olá %s,%n%nSua senha foi alterada com sucesso em %s.%n%n"
                + "Se você não realizou esta alteração, entre em contato imediatamente com o suporte.",
                nomeUsuario, dataAlteracao));

        try {
            mailSender.send(message);
            log.info("Email de confirmação de alteração de senha enviado com sucesso para: {}", email);
        } catch (Exception e) {
            log.error("Erro ao enviar email de confirmação para: {}", email, e);
            // Não lança exceção para não impactar o fluxo principal
        }
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.api.controller;

import br.com.plataforma.conexaodigital.oauth2.api.responses.JwksResponse;
import br.com.plataforma.conexaodigital.oauth2.infrastructure.jwks.JwksProvider;
import br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmNotFoundException;
import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.UUID;

/**
 * Controller para o endpoint JWKS por realm.
 * Retorna as chaves públicas de um realm para validação de tokens JWT.
 */
@RestController
@RequestMapping("/oauth2/jwks")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "JWKS", description = "Endpoint JWKS (JSON Web Key Set) por realm")
public class JwksController {

    private final JwksProvider jwksProvider;
    private final RealmRepository realmRepository;

    /**
     * Obtém o JWKS de um realm.
     * Endpoint público que retorna as chaves públicas para validação de tokens.
     *
     * @param realmId O ID do realm
     * @return JwksResponse com as chaves públicas do realm
     */
    @GetMapping(value = "/{realmId}", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(
            summary = "Obter JWKS do realm",
            description = """
                    Retorna as chaves públicas (JWKS) de um realm para validação de tokens JWT.
                    Segue o padrão RFC 7517 (JSON Web Key Set).

                    O endpoint é público e não requer autenticação.
                    Retorna apenas chaves ativas que podem ser usadas para validação,
                    incluindo chaves anteriores que ainda não expiraram (grace period).
                    """
    )
    @ApiResponses({
            @ApiResponse(
                    responseCode = "200",
                    description = "JWKS retornado com sucesso",
                    content = @Content(schema = @Schema(implementation = JwksResponse.class))
            ),
            @ApiResponse(
                    responseCode = "404",
                    description = "Realm não encontrado",
                    content = @Content(schema = @Schema(implementation = Void.class))
            )
    })
    public ResponseEntity<JwksResponse> obterJwks(
            @Parameter(description = "ID do realm", required = true)
            @PathVariable UUID realmId) {

        log.info("Requisição JWKS para realm: {}", realmId);

        Realm realm = realmRepository.findById(realmId)
                .orElseThrow(() -> new RealmNotFoundException(realmId));

        log.debug("Realm encontrado: {}", realm.getNome());

        JwksResponse jwks = jwksProvider.obterJwks(realm.getId());

        log.info("JWKS retornado com {} chaves para realm: {}", jwks.getKeys().size(), realmId);

        return ResponseEntity.ok(jwks);
    }

    /**
     * Endpoint de teste para verificar se a aplicação está respondendo.
     *
     * @return Resposta simples de teste
     */
    @GetMapping("/test")
    public ResponseEntity<String> test() {
        log.info("Endpoint de teste chamado");
        return ResponseEntity.ok("JWKS endpoint está funcionando!");
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.api.controller;

import br.com.plataforma.conexaodigital.oauth2.web.handler.RefreshTokenCookieHandler;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;

/**
 * Controller para páginas de login e autenticação OAuth2 com suporte a remember-me.
 */
@Controller
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Autenticação", description = "Endpoints de login e autenticação")
public class LoginController {

    private final RefreshTokenCookieHandler refreshTokenCookieHandler;

    /**
     * Exibe a página de login - redireciona para /admin/login.
     *
     * @return ModelAndView com redirecionamento para login
     */
    @GetMapping("/login")
    @Operation(summary = "Página de Login", description = "Redireciona para a página de login do dashboard administrativo")
    public ModelAndView loginPage(@Parameter(description = "Indica erro de autenticação")
                                    @RequestParam(value = "error", required = false) String error,
                                    @Parameter(description = "Indica logout realizado")
                                    @RequestParam(value = "logout", required = false) String logout) {
        // Redireciona para a página de login administrativa
        String redirectUrl = "/admin/login";
        if (error != null) {
            redirectUrl += "?error";
        } else if (logout != null) {
            redirectUrl += "?logout=true";
        }
        return new ModelAndView("redirect:" + redirectUrl);
    }

    /**
     * Processa o login do usuário com suporte a remember-me (obsoleto - use /admin/login).
     * Registra a auditoria baseada na escolha do remember-me.
     *
     * @param username  Email do usuário
     * @param password  Senha do usuário
     * @param rememberMe Indica se o usuário optou por remember-me
     * @param response  HttpServletResponse para definir cookies
     * @return Redirect para o dashboard administrativo após login bem-sucedido
     * @deprecated Use {@link AdminController#processLogin} via {@code POST /admin/login}
     */
    @Deprecated
    @PostMapping("/login")
    @Operation(
            summary = "Processar Login (Obsoleto)",
            description = """
                    Processa o login do usuário e redireciona para o dashboard.
                    SE RECOMENDA usar /admin/login.
                    Se rememberMe=true, o refresh token expira em 90 dias.
                    Se rememberMe=false, o refresh token expira em 30 dias.
                    Auditoria registra LOGIN ou LOGIN_REMEMBER_ME.
                    """
    )
    public ModelAndView login(
            @Parameter(description = "Email do usuário", required = true)
            @RequestParam String username,
            @Parameter(description = "Senha do usuário", required = true)
            @RequestParam String password,
            @Parameter(description = "Se true, refresh token expira em 90 dias; se false, 30 dias")
            @RequestParam(required = false, defaultValue = "false") boolean rememberMe,
            HttpServletResponse response) {

        log.info("Processando login (legado) para usuário: {} com rememberMe={}", username, rememberMe);

        // Registrar auditoria (placeholder - implementação real usaria AuditoriaService)
        if (rememberMe) {
            log.info("AUDITORIA: LOGIN_REMEMBER_ME - Login com remember-me realizado por: {}", username);
        } else {
            log.info("AUDITORIA: LOGIN - Login padrão realizado por: {}", username);
        }

        // A autenticação real será feita pelo Spring Security
        // Este endpoint é para processar o formulário e redirecionar
        // para o dashboard administrativo após login bem-sucedido
        return new ModelAndView("redirect:/admin/dashboard");
    }

    /**
     * Página inicial após login.
     *
     * @return ModelAndView com a página inicial
     */
    @GetMapping("/home")
    @Operation(summary = "Página Inicial", description = "Página inicial após login")
    public ModelAndView homePage() {
        ModelAndView modelAndView = new ModelAndView("home");
        return modelAndView;
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.api.controller;

import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.plataforma.conexaodigital.oauth2.api.dto.OAuth2ErrorResponse;
import br.com.plataforma.conexaodigital.oauth2.api.dto.TokenRequest;
import br.com.plataforma.conexaodigital.oauth2.api.dto.TokenResponse;
import br.com.plataforma.conexaodigital.oauth2.domain.exception.ClientNotFoundException;
import br.com.plataforma.conexaodigital.oauth2.domain.exception.InvalidGrantTypeException;
import br.com.plataforma.conexaodigital.oauth2.domain.exception.InvalidTokenException;
import br.com.plataforma.conexaodigital.oauth2.domain.exception.TokenRevogadoException;
import br.com.plataforma.conexaodigital.oauth2.domain.service.TokenService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Controller para o endpoint de token OAuth2 (/oauth2/token).
 * Conforme especificação RFC 6749, emite tokens JWT para diferentes grant
 * types.
 */
@RestController
@RequestMapping("/oauth2")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "OAuth2 Token", description = "Endpoint para emissão de tokens OAuth2")
public class TokenController {

    private final TokenService tokenService;

    /**
     * Endpoint para emissão de tokens OAuth2.
     * Suporta os grant types: authorization_code, client_credentials,
     * refresh_token.
     *
     * <p>
     * Autenticação do cliente via clientId e clientSecret no corpo da requisição
     * (form data).
     * </p>
     *
     * @param request A requisição de token (URL encoded form data)
     * @return TokenResponse contendo access_token, refresh_token (quando
     *         aplicável), expires_in, token_type
     */
    @PostMapping(value = "/token", consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)
    @Operation(summary = "Obter token OAuth2", description = """
            **Endpoint Público** - Emite tokens JWT para diferentes tipos de grant.

            **Grant Types Suportados:**
            - **authorization_code**: Troca um authorization code por access e refresh token
            - **client_credentials**: Obtém access token para service-to-service (não emite refresh token)
            - **refresh_token**: Renova tokens usando um refresh token válido (com rotação de refresh token)

            **Credenciais do Cliente:**
            - clientId e clientSecret devem ser enviados via form data (x-www-form-urlencoded)
            - Exemplo: client_id=meu-client&client_secret=minha-chave&grant_type=client_credentials

            **Resposta (RFC 6749):**
            - access_token: Token JWT para acessar recursos protegidos
            - token_type: Sempre "Bearer"
            - expires_in: Tempo de expiração em segundos
            - refresh_token: Token para renovação (não emitido para client_credentials)
            - scope: Escopos concedidos (opcional)
            """)
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Tokens emitidos com sucesso", content = @Content(schema = @Schema(implementation = TokenResponse.class))),
            @ApiResponse(responseCode = "400", description = "Requisição inválida (grant_type inválido, parâmetros ausentes)", content = @Content(schema = @Schema(implementation = OAuth2ErrorResponse.class))),
            @ApiResponse(responseCode = "401", description = "Credenciais do cliente inválidas (client_id/client_secret incorretos)", content = @Content(schema = @Schema(implementation = OAuth2ErrorResponse.class)))
    })
    public ResponseEntity<?> emitirToken(@Valid TokenRequest request) {

        log.debug("Requisição /oauth2/token recebida, grant_type: {}, client_id: {}",
                request.getGrantType(), request.getClientId());

        try {
            // Emitir tokens (valida clientId e clientSecret no service)
            TokenResponse response = tokenService.emitirToken(request);

            log.info("Tokens emitidos com sucesso para grant_type: {}, client: {}",
                    request.getGrantType(), request.getClientId());

            return ResponseEntity.ok(response);

        } catch (InvalidGrantTypeException e) {
            log.warn("Grant type inválido: {}", e.getMessage());
            return ResponseEntity.badRequest().body(
                    OAuth2ErrorResponse.builder()
                            .error(OAuth2ErrorResponse.UNSUPPORTED_GRANT_TYPE)
                            .errorDescription(e.getMessage())
                            .build());

        } catch (InvalidTokenException | TokenRevogadoException e) {
            log.warn("Token inválido: {}", e.getMessage());
            return ResponseEntity.badRequest().body(
                    OAuth2ErrorResponse.builder()
                            .error(OAuth2ErrorResponse.INVALID_GRANT)
                            .errorDescription(e.getMessage())
                            .build());

        } catch (ClientNotFoundException e) {
            log.warn("Cliente não encontrado ou inválido: {}", e.getMessage());
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                    OAuth2ErrorResponse.builder()
                            .error(OAuth2ErrorResponse.INVALID_CLIENT)
                            .errorDescription("Credenciais de cliente inválidas")
                            .build());

        } catch (Exception e) {
            log.error("Erro interno ao emitir tokens", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    OAuth2ErrorResponse.builder()
                            .error(OAuth2ErrorResponse.SERVER_ERROR)
                            .errorDescription("Erro interno do servidor")
                            .build());
        }
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.api.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO para resposta de erro OAuth2.
 * Segue a especificação RFC 6749 para resposta de erro.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class OAuth2ErrorResponse {

    /**
     * Código do erro (invalid_request, invalid_client, invalid_grant, etc.).
     */
    @JsonProperty("error")
    private String error;

    /**
     * Descrição do erro (opcional).
     */
    @JsonProperty("error_description")
    private String errorDescription;

    /**
     * URI para mais informações (opcional).
     */
    @JsonProperty("error_uri")
    private String errorUri;

    // Códigos de erro padrão OAuth2
    public static final String INVALID_REQUEST = "invalid_request";
    public static final String UNAUTHORIZED_CLIENT = "unauthorized_client";
    public static final String ACCESS_DENIED = "access_denied";
    public static final String UNSUPPORTED_RESPONSE_TYPE = "unsupported_response_type";
    public static final String INVALID_SCOPE = "invalid_scope";
    public static final String SERVER_ERROR = "server_error";
    public static final String TEMPORARILY_UNAVAILABLE = "temporarily_unavailable";

    // Erros de token
    public static final String INVALID_CLIENT = "invalid_client";
    public static final String INVALID_GRANT = "invalid_grant";
    public static final String INVALID_TOKEN = "invalid_token";
    public static final String UNSUPPORTED_GRANT_TYPE = "unsupported_grant_type";
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.api.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO para requisição de token OAuth2.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TokenRequest {

    /**
     * Tipo de grant: client_credentials, refresh_token, etc.
     */
    @NotBlank(message = "grant_type é obrigatório")
    private String grantType;

    /**
     * Client ID para autenticação do cliente OAuth2.
     */
    @NotBlank(message = "client_id é obrigatório")
    private String clientId;

    /**
     * Client Secret para autenticação do cliente OAuth2.
     */
    @NotBlank(message = "client_secret é obrigatório")
    private String clientSecret;

    /**
     * Código de autorização (para grant_type=authorization_code).
     */
    private String code;

    /**
     * URI de redirecionamento (para grant_type=authorization_code).
     */
    private String redirectUri;

    /**
     * Refresh token (para grant_type=refresh_token).
     */
    private String refreshToken;

    /**
     * Username (para grant_type=password, se suportado).
     */
    private String username;

    /**
     * Password (para grant_type=password, se suportado).
     */
    private String password;

    /**
     * Scope solicitado.
     */
    private String scope;

    /**
     * Verifier PKCE (para clientes públicos com PKCE).
     */
    private String codeVerifier;
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.api.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO para resposta de token OAuth2.
 * Segue a especificação RFC 6749 para resposta de token.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TokenResponse {

    /**
     * Access token para acessar recursos protegidos.
     */
    @JsonProperty("access_token")
    private String accessToken;

    /**
     * Tipo do token (sempre "Bearer" para JWT).
     */
    @Builder.Default
    @JsonProperty("token_type")
    private String tokenType = "Bearer";

    /**
     * Tempo em segundos até expiração do access token.
     */
    @JsonProperty("expires_in")
    private Long expiresIn;

    /**
     * Refresh token (opcional).
     */
    @JsonProperty("refresh_token")
    private String refreshToken;

    /**
     * Scope concedido (opcional).
     */
    @JsonProperty("scope")
    private String scope;
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.api.responses;

import com.fasterxml.jackson.annotation.JsonProperty;
import io.swagger.v3.oas.annotations.media.Schema;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;
import java.util.Map;

/**
 * DTO para resposta JWKS (JSON Web Key Set) conforme RFC 7517.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Schema(description = "JSON Web Key Set (JWKS) - conjunto de chaves públicas para validação de tokens")
public class JwksResponse {

    @JsonProperty("keys")
    @Schema(description = "Lista de chaves públicas")
    private List<JsonWebKey> keys;

    /**
     * Representa uma chave JSON Web Key (JWK).
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    @Schema(description = "JSON Web Key (JWK) - chave pública individual")
    public static class JsonWebKey {

        @JsonProperty("kid")
        @Schema(description = "Key ID - identificador único da chave", example = "1")
        private String kid;

        @JsonProperty("kty")
        @Schema(description = "Key Type - tipo de chave criptográfica", example = "RSA")
        private String kty;

        @JsonProperty("use")
        @Schema(description = "Public Key Use - uso pretendido da chave", example = "sig")
        private String use;

        @JsonProperty("alg")
        @Schema(description = "Algorithm - algoritmo de assinatura", example = "RS256")
        private String alg;

        @JsonProperty("n")
        @Schema(description = "Modulus - módulo da chave RSA (Base64 URL-encoded)")
        private String n;

        @JsonProperty("e")
        @Schema(description = "Exponent - expoente público da chave RSA (Base64 URL-encoded)", example = "AQAB")
        private String e;
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtEncoder;

import java.util.UUID;

/**
 * Configuração JWT para geração e validação de tokens.
 */
@Configuration
@Slf4j
public class JwtConfig {

    @Value("${oauth2.authorization-server.issuer:http://localhost:8080}")
    private String issuer;

    @Value("${oauth2.authorization-server.access-token-time-to-live:3600}")
    private int accessTokenTimeToLiveSeconds;

    @Value("${oauth2.authorization-server.refresh-token-time-to-live:2592000}")
    private int refreshTokenTimeToLiveSeconds;

    /**
     * Gera uma chave RSA para assinatura de tokens.
     */
    public static com.nimbusds.jose.jwk.RSAKey generateRsaKey() {
        try {
            com.nimbusds.jose.jwk.gen.RSAKeyGenerator keyGenerator =
                    new com.nimbusds.jose.jwk.gen.RSAKeyGenerator(2048);
            return keyGenerator.keyID(UUID.randomUUID().toString()).generate();
        } catch (com.nimbusds.jose.JOSEException e) {
            throw new RuntimeException("Erro ao gerar chave RSA", e);
        }
    }

    /**
     * Configura a fonte de chaves JWK.
     */
    @Bean
    public com.nimbusds.jose.jwk.source.JWKSource<com.nimbusds.jose.proc.SecurityContext> jwkSource() {
        log.info("Configurando JWKSource com chave RSA");
        com.nimbusds.jose.jwk.RSAKey rsaKey = generateRsaKey();
        com.nimbusds.jose.jwk.JWKSet jwkSet = new com.nimbusds.jose.jwk.JWKSet(rsaKey);
        return new com.nimbusds.jose.jwk.source.ImmutableJWKSet<>(jwkSet);
    }

    /**
     * Configura o JwtDecoder para validar tokens.
     */
    @Bean
    public JwtDecoder jwtDecoder(
            com.nimbusds.jose.jwk.source.JWKSource<com.nimbusds.jose.proc.SecurityContext> jwkSource) {
        log.info("Configurando JwtDecoder");
        return org.springframework.security.oauth2.server.authorization.config.annotation
                .web.configuration.OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);
    }

    /**
     * Configura o JwtEncoder para gerar tokens.
     */
    @Bean
    public JwtEncoder jwtEncoder(
            com.nimbusds.jose.jwk.source.JWKSource<com.nimbusds.jose.proc.SecurityContext> jwkSource) {
        log.info("Configurando JwtEncoder");
        return new NimbusJwtEncoder(jwkSource);
    }

    public String getIssuer() {
        return issuer;
    }

    public int getAccessTokenTimeToLiveSeconds() {
        return accessTokenTimeToLiveSeconds;
    }

    public int getRefreshTokenTimeToLiveSeconds() {
        return refreshTokenTimeToLiveSeconds;
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;

/**
 * Configurações de remember-me para tokens OAuth2.
 * Define dois TTLs diferentes baseados na escolha do usuário.
 */
@Data
@Configuration
@ConfigurationProperties(prefix = "oauth2.remember-me")
public class RememberMeSettings {

    /**
     * Tempo de vida do refresh token em dias quando remember-me está ativado.
     */
    private int refreshTokenDays = 90;

    /**
     * Tempo de vida do refresh token em dias quando remember-me está desativado (padrão).
     */
    private int defaultRefreshTokenDays = 30;

    /**
     * Obtém o TTL do refresh token em segundos baseado no remember-me.
     *
     * @param rememberMe Se true, usa TTL estendido; se false, usa TTL padrão
     * @return Tempo em segundos
     */
    public int getRefreshTokenTtl(boolean rememberMe) {
        return rememberMe ? refreshTokenDays * 86400
                         : defaultRefreshTokenDays * 86400;
    }

    /**
     * Obtém a Duration do refresh token baseado no remember-me.
     *
     * @param rememberMe Se true, usa Duration estendida; se false, usa Duration padrão
     * @return Duration
     */
    public Duration getRefreshTokenDuration(boolean rememberMe) {
        return Duration.ofSeconds(getRefreshTokenTtl(rememberMe));
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

/**
 * Configurações de token OAuth2.
 */
@Data
@Configuration
@ConfigurationProperties(prefix = "oauth2.token")
public class TokenSettings {

    /**
     * Tempo de vida do access token em segundos.
     */
    private int accessTokenTimeToLive = 3600; // 1 hora

    /**
     * Tempo de vida do refresh token em segundos.
     */
    private int refreshTokenTimeToLive = 2592000; // 30 dias

    /**
     * Tempo de vida do authorization code em segundos.
     */
    private int authorizationCodeTimeToLive = 300; // 5 minutos

    /**
     * Se true, reutiliza o refresh token ao renovar.
     * Se false, gera novo refresh token a cada renovação (recomendado).
     */
    private boolean reuseRefreshTokens = false;

    /**
     * Se true, emite refresh token para fluxo client_credentials.
     * Se false, não emite refresh token para client_credentials (padrão OAuth2).
     */
    private boolean issueRefreshTokenForClientCredentials = false;
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.domain.exception;

/**
 * Exceção lançada quando um cliente não é encontrado.
 */
public class ClientNotFoundException extends RuntimeException {

    private static final String DEFAULT_MESSAGE = "Cliente não encontrado";

    public ClientNotFoundException() {
        super(DEFAULT_MESSAGE);
    }

    public ClientNotFoundException(String message) {
        super(message);
    }

    public ClientNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.domain.exception;

/**
 * Exceção lançada quando um tipo de grant inválido é solicitado.
 */
public class InvalidGrantTypeException extends RuntimeException {

    private static final String DEFAULT_MESSAGE = "Tipo de grant inválido";

    public InvalidGrantTypeException() {
        super(DEFAULT_MESSAGE);
    }

    public InvalidGrantTypeException(String message) {
        super(message);
    }

    public InvalidGrantTypeException(String message, Throwable cause) {
        super(message, cause);
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.domain.exception;

/**
 * Exceção lançada quando um token é inválido.
 */
public class InvalidTokenException extends RuntimeException {

    private static final String DEFAULT_MESSAGE = "Token inválido";

    public InvalidTokenException() {
        super(DEFAULT_MESSAGE);
    }

    public InvalidTokenException(String message) {
        super(message);
    }

    public InvalidTokenException(String message, Throwable cause) {
        super(message, cause);
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.domain.exception;

/**
 * Exceção lançada quando um refresh token está revogado.
 */
public class TokenRevogadoException extends RuntimeException {

    private static final String DEFAULT_MESSAGE = "Token revogado";

    public TokenRevogadoException() {
        super(DEFAULT_MESSAGE);
    }

    public TokenRevogadoException(String message) {
        super(message);
    }

    public TokenRevogadoException(String message, Throwable cause) {
        super(message, cause);
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.domain.exceptions;

import br.com.plataforma.conexaodigital.shared.exceptions.BusinessException;

/**
 * Exceção lançada quando um OAuth2 client não é encontrado.
 */
public class ClientNotFoundException extends BusinessException {

    public ClientNotFoundException(String clientId) {
        super("Client OAuth2 não encontrado com clientId: " + clientId);
    }

    public ClientNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.domain.exceptions;

import br.com.plataforma.conexaodigital.shared.exceptions.BusinessException;

/**
 * Exceção lançada quando há um grant inválido no fluxo OAuth2.
 */
public class InvalidGrantException extends BusinessException {

    public InvalidGrantException(String message) {
        super(message);
    }

    public InvalidGrantException(String message, Throwable cause) {
        super(message, cause);
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.domain.exceptions;

import br.com.plataforma.conexaodigital.shared.exceptions.BusinessException;

/**
 * Exceção lançada quando há uma requisição OAuth2 inválida.
 */
public class InvalidOAuth2RequestException extends BusinessException {

    public InvalidOAuth2RequestException(String message) {
        super(message);
    }

    public InvalidOAuth2RequestException(String message, Throwable cause) {
        super(message, cause);
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.domain.model;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import jakarta.persistence.Table;
import jakarta.persistence.Version;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * Entidade OAuth2 Client para autenticação service-to-service.
 * Utilizada no fluxo Client Credentials para representar clientes de serviço.
 */
@Entity
@Table(name = "oauth2_client")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class OAuth2Client {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", updatable = false, nullable = false)
    @EqualsAndHashCode.Include
    private UUID id;

    @Column(name = "client_id", unique = true, nullable = false, length = 100)
    private String clientId;

    @Column(name = "client_secret", nullable = false)
    private String clientSecret;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "realm_id", nullable = false)
    private br.com.plataforma.conexaodigital.realm.domain.model.Realm realm;

    @Column(name = "empresa_id", length = 50)
    private String empresaId;

    @Column(name = "tenant_id", length = 50)
    private String tenantId;

    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "oauth2_client_scope", joinColumns = @JoinColumn(name = "client_id"))
    @Column(name = "scope")
    @Builder.Default
    private Set<String> scopes = new HashSet<>();

    @Column(name = "ativo", nullable = false)
    private boolean ativo = true;

    @Column(name = "descricao", length = 500)
    private String descricao;

    @Column(name = "data_criacao", updatable = false, nullable = false)
    private LocalDateTime dataCriacao;

    @Column(name = "data_atualizacao", nullable = false)
    private LocalDateTime dataAtualizacao;

    @Version
    private Long versao;

    /**
     * Adiciona um scope ao cliente.
     */
    public void addScope(String scope) {
        this.scopes.add(scope);
        this.dataAtualizacao = LocalDateTime.now();
    }

    /**
     * Verifica se o cliente está ativo.
     */
    public boolean estaAtivo() {
        return this.ativo;
    }

    /**
     * Inicializa os campos de auditoria antes da persistência.
     */
    @PrePersist
    protected void onCreate() {
        if (this.dataCriacao == null) {
            this.dataCriacao = LocalDateTime.now();
        }
        if (this.dataAtualizacao == null) {
            this.dataAtualizacao = LocalDateTime.now();
        }
        if (this.versao == null) {
            this.versao = 0L;
        }
    }

    /**
     * Atualiza o campo dataAtualização antes de atualizar.
     */
    @PreUpdate
    protected void onUpdate() {
        this.dataAtualizacao = LocalDateTime.now();
    }

    @Override
    public String toString() {
        return "OAuth2Client{" +
                "id=" + id +
                ", clientId='" + clientId + '\'' +
                ", realm=" + (realm != null ? realm.getId() : "null") +
                ", empresaId='" + empresaId + '\'' +
                ", tenantId='" + tenantId + '\'' +
                ", scopes=" + scopes +
                ", ativo=" + ativo +
                '}';
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.domain.model;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Entidade para representar tokens OAuth2.
 * Utilizada para rastreamento e revogação de tokens.
 */
@Entity
@Table(name = "oauth2_token")
public class OAuth2Token {

    @Id
    @Column(name = "id", updatable = false, nullable = false)
    private UUID id;

    @Column(name = "token_value", unique = true, nullable = false, length = 2000)
    private String tokenValue;

    @Enumerated(EnumType.STRING)
    @Column(name = "token_type", nullable = false, length = 20)
    private OAuth2TokenType tokenType;

    @Column(name = "user_id", length = 100)
    private String userId;

    @Column(name = "client_id", nullable = false, length = 100)
    private String clientId;

    @Column(name = "realm_id", nullable = false)
    private UUID realmId;

    @Column(name = "empresa_id", length = 50)
    private String empresaId;

    @Column(name = "tenant_id", length = 50)
    private String tenantId;

    @Column(name = "expires_at", nullable = false)
    private LocalDateTime expiresAt;

    @Column(name = "issued_at", nullable = false)
    private LocalDateTime issuedAt;

    @Column(name = "revogado", nullable = false)
    private boolean revogado = false;

    @Column(name = "data_revogacao")
    private LocalDateTime dataRevogacao;

    @Column(name = "motivo_revogacao", length = 255)
    private String motivoRevogacao;

    @Column(name = "parent_token_id", length = 100)
    private String parentTokenId;

    @Column(name = "data_criacao", updatable = false, nullable = false)
    private LocalDateTime dataCriacao;

    @Column(name = "data_atualizacao", nullable = false)
    private LocalDateTime dataAtualizacao;

    @Version
    private Long versao;

    /**
     * Construtor padrão requerido pelo JPA.
     */
    protected OAuth2Token() {
    }

    /**
     * Cria um novo OAuth2Token.
     */
    public OAuth2Token(String tokenValue, OAuth2TokenType tokenType, String userId,
                       String clientId, UUID realmId, String empresaId, String tenantId,
                       LocalDateTime expiresAt, LocalDateTime issuedAt, String parentTokenId) {
        this.id = UUID.randomUUID();
        this.tokenValue = tokenValue;
        this.tokenType = tokenType;
        this.userId = userId;
        this.clientId = clientId;
        this.realmId = realmId;
        this.empresaId = empresaId;
        this.tenantId = tenantId;
        this.expiresAt = expiresAt;
        this.issuedAt = issuedAt;
        this.parentTokenId = parentTokenId;
        this.dataCriacao = LocalDateTime.now();
        this.dataAtualizacao = LocalDateTime.now();
        this.versao = 0L;
    }

    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public String getTokenValue() {
        return tokenValue;
    }

    public void setTokenValue(String tokenValue) {
        this.tokenValue = tokenValue;
    }

    public OAuth2TokenType getTokenType() {
        return tokenType;
    }

    public void setTokenType(OAuth2TokenType tokenType) {
        this.tokenType = tokenType;
    }

    public String getUserId() {
        return userId;
    }

    public void setUserId(String userId) {
        this.userId = userId;
    }

    public String getClientId() {
        return clientId;
    }

    public void setClientId(String clientId) {
        this.clientId = clientId;
    }

    public UUID getRealmId() {
        return realmId;
    }

    public void setRealmId(UUID realmId) {
        this.realmId = realmId;
    }

    public String getEmpresaId() {
        return empresaId;
    }

    public void setEmpresaId(String empresaId) {
        this.empresaId = empresaId;
    }

    public String getTenantId() {
        return tenantId;
    }

    public void setTenantId(String tenantId) {
        this.tenantId = tenantId;
    }

    public LocalDateTime getExpiresAt() {
        return expiresAt;
    }

    public void setExpiresAt(LocalDateTime expiresAt) {
        this.expiresAt = expiresAt;
    }

    public LocalDateTime getIssuedAt() {
        return issuedAt;
    }

    public void setIssuedAt(LocalDateTime issuedAt) {
        this.issuedAt = issuedAt;
    }

    public boolean isRevogado() {
        return revogado;
    }

    public void setRevogado(boolean revogado) {
        this.revogado = revogado;
        if (revogado) {
            this.dataRevogacao = LocalDateTime.now();
        }
    }

    public LocalDateTime getDataRevogacao() {
        return dataRevogacao;
    }

    public void setDataRevogacao(LocalDateTime dataRevogacao) {
        this.dataRevogacao = dataRevogacao;
    }

    public String getMotivoRevogacao() {
        return motivoRevogacao;
    }

    public void setMotivoRevogacao(String motivoRevogacao) {
        this.motivoRevogacao = motivoRevogacao;
    }

    public String getParentTokenId() {
        return parentTokenId;
    }

    public void setParentTokenId(String parentTokenId) {
        this.parentTokenId = parentTokenId;
    }

    public LocalDateTime getDataCriacao() {
        return dataCriacao;
    }

    public void setDataCriacao(LocalDateTime dataCriacao) {
        this.dataCriacao = dataCriacao;
    }

    public LocalDateTime getDataAtualizacao() {
        return dataAtualizacao;
    }

    public void setDataAtualizacao(LocalDateTime dataAtualizacao) {
        this.dataAtualizacao = dataAtualizacao;
    }

    public Long getVersao() {
        return versao;
    }

    public void setVersao(Long versao) {
        this.versao = versao;
    }

    /**
     * Verifica se o token está expirado.
     */
    public boolean estaExpirado() {
        return LocalDateTime.now().isAfter(expiresAt);
    }

    /**
     * Verifica se o token é válido (não expirado e não revogado).
     */
    public boolean eValido() {
        return !estaExpirado() && !revogado;
    }

    /**
     * Revoga o token com um motivo.
     */
    public void revogar(String motivo) {
        this.revogado = true;
        this.motivoRevogacao = motivo;
        this.dataRevogacao = LocalDateTime.now();
        this.dataAtualizacao = LocalDateTime.now();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        OAuth2Token that = (OAuth2Token) o;
        return id != null && id.equals(that.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }

    @Override
    public String toString() {
        return "OAuth2Token{" +
                "id=" + id +
                ", tokenType=" + tokenType +
                ", userId='" + userId + '\'' +
                ", clientId='" + clientId + '\'' +
                ", realmId=" + realmId +
                ", expiresAt=" + expiresAt +
                ", revogado=" + revogado +
                '}';
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.domain.model;

/**
 * Enumeração para tipos de token OAuth2.
 */
public enum OAuth2TokenType {
    /**
     * Token de acesso utilizado para autenticar requisições a recursos protegidos.
     */
    ACCESS_TOKEN,

    /**
     * Token utilizado para obter novos access tokens sem necessidade de reautenticação.
     */
    REFRESH_TOKEN
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.domain.repository;

import br.com.plataforma.conexaodigital.oauth2.domain.model.OAuth2Client;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

/**
 * Repository para entidade OAuth2Client.
 */
@Repository
public interface OAuth2ClientRepository extends JpaRepository<OAuth2Client, UUID> {

    /**
     * Busca um cliente pelo clientId.
     *
     * @param clientId O identificador do cliente
     * @return Optional contendo o cliente, se encontrado
     */
    Optional<OAuth2Client> findByClientId(String clientId);

    /**
     * Verifica se existe um cliente com o clientId informado.
     *
     * @param clientId O identificador do cliente
     * @return true se existir, false caso contrário
     */
    boolean existsByClientId(String clientId);
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.domain.repository;

import br.com.plataforma.conexaodigital.oauth2.domain.model.OAuth2Token;
import br.com.plataforma.conexaodigital.oauth2.domain.model.OAuth2TokenType;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Repository para entidade OAuth2Token.
 */
@Repository
public interface OAuth2TokenRepository extends JpaRepository<OAuth2Token, UUID> {

    /**
     * Busca um token pelo seu valor (hash ou ID).
     *
     * @param tokenValue O valor do token
     * @return Optional contendo o token, se encontrado
     */
    Optional<OAuth2Token> findByTokenValue(String tokenValue);

    /**
     * Busca todos os tokens revogados.
     *
     * @return Lista de tokens revogados
     */
    List<OAuth2Token> findByRevogadoTrue();

    /**
     * Busca todos os tokens expirados.
     *
     * @param dataAtual A data atual para comparação
     * @return Lista de tokens expirados
     */
    List<OAuth2Token> findByExpiresAtBefore(LocalDateTime dataAtual);

    /**
     * Busca tokens do tipo especificado para um usuário.
     *
     * @param tokenType O tipo de token
     * @param userId    O ID do usuário
     * @return Lista de tokens
     */
    List<OAuth2Token> findByTokenTypeAndUserId(OAuth2TokenType tokenType, String userId);

    /**
     * Busca tokens do tipo especificado para um cliente.
     *
     * @param tokenType O tipo de token
     * @param clientId  O ID do cliente
     * @return Lista de tokens
     */
    List<OAuth2Token> findByTokenTypeAndClientId(OAuth2TokenType tokenType, String clientId);

    /**
     * Busca um refresh token pelo valor e verifica se não está revogado.
     *
     * @param tokenValue O valor do token
     * @return Optional contendo o token, se encontrado e válido
     */
    default Optional<OAuth2Token> findValidRefreshToken(String tokenValue) {
        Optional<OAuth2Token> token = findByTokenValue(tokenValue);
        if (token.isPresent() && token.get().getTokenType() == OAuth2TokenType.REFRESH_TOKEN
                && token.get().eValido()) {
            return token;
        }
        return Optional.empty();
    }

    /**
     * Verifica se existe um token não revogado para o usuário.
     *
     * @param userId    O ID do usuário
     * @param tokenType O tipo de token
     * @return true se existir, false caso contrário
     */
    boolean existsByUserIdAndTokenTypeAndRevogadoFalse(String userId, OAuth2TokenType tokenType);

    /**
     * Busca tokens pelo parentTokenId.
     *
     * @param parentTokenId O ID do token pai
     * @return Lista de tokens filhos
     */
    List<OAuth2Token> findByParentTokenId(String parentTokenId);
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.domain.service;

/**
 * Interface para serviço de revogação de tokens OAuth2.
 */
public interface TokenRevogacaoService {

    /**
     * Revoga um token (access token ou refresh token).
     * Ao revogar um access token, o refresh token associado também é invalidado.
     * Ao revogar um refresh token, o access token associado também é invalidado.
     * A revogação é idempotente (token já revogado não retorna erro).
     *
     * @param token O valor do token a ser revogado
     * @throws InvalidTokenException se o token for inválido
     */
    void revogar(String token);
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.domain.service;

import br.com.plataforma.conexaodigital.oauth2.api.dto.TokenRequest;
import br.com.plataforma.conexaodigital.oauth2.api.dto.TokenResponse;

/**
 * Interface para serviço de tokens OAuth2.
 * Responsável por gerenciar a emissão de tokens JWT para diferentes grant types.
 */
public interface TokenService {

    /**
     * Emite tokens com base no tipo de grant solicitado.
     * Suporta os grant types: authorization_code, client_credentials, refresh_token.
     *
     * @param request  A requisição de token (contém clientId e clientSecret)
     * @return TokenResponse contendo access_token, refresh_token (quando aplicável), expires_in, token_type
     * @throws br.com.plataforma.conexaodigital.oauth2.domain.exception.InvalidGrantTypeException Se o grant_type for inválido
     * @throws br.com.plataforma.conexaodigital.oauth2.domain.exception.ClientNotFoundException    Se o cliente não for encontrado ou credenciais inválidas
     * @throws br.com.plataforma.conexaodigital.oauth2.domain.exception.InvalidTokenException     Se o token for inválido (para refresh_token)
     * @throws br.com.plataforma.conexaodigital.oauth2.domain.exception.TokenRevogadoException    Se o token estiver revogado (para refresh_token)
     */
    TokenResponse emitirToken(TokenRequest request);

    /**
     * Valida credenciais de cliente (client_id e client_secret).
     *
     * @param clientId     O ID do cliente
     * @param clientSecret O secret do cliente
     * @return true se as credenciais forem válidas, false caso contrário
     */
    boolean validarCredenciaisCliente(String clientId, String clientSecret);
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.domain.service.impl;

import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.jwt.JwtClaimsSet;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.security.oauth2.jwt.JwtEncoderParameters;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.plataforma.conexaodigital.auditoria.domain.model.enums.TipoEventoAuditoria;
import br.com.plataforma.conexaodigital.auditoria.domain.service.AuditoriaService;
import br.com.plataforma.conexaodigital.oauth2.api.dto.TokenRequest;
import br.com.plataforma.conexaodigital.oauth2.api.dto.TokenResponse;
import br.com.plataforma.conexaodigital.oauth2.config.TokenSettings;
import br.com.plataforma.conexaodigital.oauth2.domain.exception.ClientNotFoundException;
import br.com.plataforma.conexaodigital.oauth2.domain.exception.InvalidGrantTypeException;
import br.com.plataforma.conexaodigital.oauth2.domain.exception.InvalidTokenException;
import br.com.plataforma.conexaodigital.oauth2.domain.model.OAuth2Client;
import br.com.plataforma.conexaodigital.oauth2.domain.model.OAuth2Token;
import br.com.plataforma.conexaodigital.oauth2.domain.model.OAuth2TokenType;
import br.com.plataforma.conexaodigital.oauth2.domain.repository.OAuth2ClientRepository;
import br.com.plataforma.conexaodigital.oauth2.domain.repository.OAuth2TokenRepository;
import br.com.plataforma.conexaodigital.oauth2.domain.service.TokenService;
import br.com.plataforma.conexaodigital.oauth2.domain.validator.RefreshTokenValidator;
import br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmNotFoundException;
import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import br.com.plataforma.conexaodigital.usuario.domain.model.Usuario;
import br.com.plataforma.conexaodigital.usuario.domain.repository.UsuarioRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Implementação do serviço de tokens OAuth2.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class TokenServiceImpl implements TokenService {

        private final JwtEncoder jwtEncoder;
        private final OAuth2ClientRepository clientRepository;
        private final OAuth2TokenRepository tokenRepository;
        private final UsuarioRepository usuarioRepository;
        private final RealmRepository realmRepository;
        private final PasswordEncoder passwordEncoder;
        private final TokenSettings tokenSettings;
        private final RefreshTokenValidator refreshTokenValidator;
        private final AuditoriaService auditoriaService;

        private static final String GRANT_TYPE_AUTHORIZATION_CODE = "authorization_code";
        private static final String GRANT_TYPE_CLIENT_CREDENTIALS = "client_credentials";
        private static final String GRANT_TYPE_REFRESH_TOKEN = "refresh_token";
        private static final String GRANT_TYPE_PASSWORD = "password";

        @Override
        @Transactional
        public TokenResponse emitirToken(TokenRequest request) {
                log.debug("Requisição de token para client: {}, grant_type: {}", request.getClientId(), request.getGrantType());

                // Validar credenciais do cliente
                if (!validarCredenciaisCliente(request.getClientId(), request.getClientSecret())) {
                        log.warn("Credenciais inválidas para client: {}", request.getClientId());
                        throw new ClientNotFoundException("Credenciais de cliente inválidas");
                }

                OAuth2Client client = buscarCliente(request.getClientId());

                return switch (request.getGrantType()) {
                        case GRANT_TYPE_CLIENT_CREDENTIALS -> emitirTokenClientCredentials(request, client);
                        case GRANT_TYPE_REFRESH_TOKEN -> emitirTokenRefresh(request, client);
                        case GRANT_TYPE_AUTHORIZATION_CODE -> emitirTokenAuthorizationCode(request, client);
                        default -> throw new InvalidGrantTypeException(
                                        "Grant type não suportado: " + request.getGrantType());
                };
        }

        @Override
        public boolean validarCredenciaisCliente(String clientId, String clientSecret) {
                log.debug("Validando credenciais do cliente: {}", clientId);

                return clientRepository.findByClientId(clientId)
                                .map(client -> {
                                        log.debug("Cliente encontrado: {}, ativo: {}, secret armazenado: {}",
                                                client.getClientId(), client.estaAtivo(), client.getClientSecret().substring(0, Math.min(10, client.getClientSecret().length())));

                                        if (!client.estaAtivo()) {
                                                log.warn("Cliente encontrado mas está inativo: {}", clientId);
                                                return false;
                                        }

                                        boolean matches = passwordEncoder.matches(clientSecret, client.getClientSecret());
                                        log.debug("Senha match para client {}: {}", clientId, matches);
                                        return matches;
                                })
                                .orElse(false);
        }

        /**
         * Busca um cliente e verifica se está ativo.
         */
        private OAuth2Client buscarCliente(String clientId) {
                OAuth2Client client = clientRepository.findByClientId(clientId)
                                .orElseThrow(() -> {
                                        log.warn("Cliente não encontrado: {}", clientId);
                                        return new ClientNotFoundException(clientId);
                                });

                if (!client.estaAtivo()) {
                        log.warn("Cliente inativo: {}", clientId);
                        throw new ClientNotFoundException("Cliente está inativo: " + clientId);
                }

                return client;
        }

        /**
         * Emite token para grant_type=client_credentials.
         * Usado para autenticação service-to-service.
         */
        private TokenResponse emitirTokenClientCredentials(TokenRequest request, OAuth2Client client) {
                log.info("Emitindo token client_credentials para client: {}", client.getClientId());

                // JWT claims para client credentials
                Map<String, Object> claims = new HashMap<>();
                claims.put("sub", client.getClientId());
                claims.put("realm", client.getRealm().getId().toString());
                claims.put("roles", List.of("SERVICE"));
                claims.put("empresaId", client.getEmpresaId());
                claims.put("tenantId", client.getTenantId());
                claims.put("client_id", client.getClientId());

                // Gerar access token
                String accessToken = gerarJwt(claims, tokenSettings.getAccessTokenTimeToLive());
                Instant expiresAt = Instant.now().plusSeconds(tokenSettings.getAccessTokenTimeToLive());

                // Salvar token no banco
                OAuth2Token tokenEntity = new OAuth2Token(
                                accessToken,
                                OAuth2TokenType.ACCESS_TOKEN,
                                null, // userId null para client credentials
                                client.getClientId(),
                                client.getRealm().getId(),
                                client.getEmpresaId(),
                                client.getTenantId(),
                                LocalDateTime.ofInstant(expiresAt, ZoneId.systemDefault()),
                                LocalDateTime.now(),
                                null);
                tokenRepository.save(tokenEntity);

                // Registrar auditoria
                auditoriaService.registrarEvento(
                                TipoEventoAuditoria.AUTENTICACAO_CLIENT,
                                "Client autenticado via client_credentials: " + client.getClientId(),
                                client.getRealm().getId());

                auditoriaService.registrarEvento(
                                TipoEventoAuditoria.EMISSAO_TOKEN,
                                "Token emitido para client: " + client.getClientId(),
                                client.getRealm().getId());

                log.info("Token emitido com sucesso para client: {}", client.getClientId());

                // Não emite refresh token para client_credentials
                return TokenResponse.builder()
                                .accessToken(accessToken)
                                .tokenType("Bearer")
                                .expiresIn((long) tokenSettings.getAccessTokenTimeToLive())
                                .scope(request.getScope())
                                .build();
        }

        /**
         * Emite tokens para grant_type=refresh_token.
         * Realiza rotação de refresh token.
         */
        @Transactional
        private TokenResponse emitirTokenRefresh(TokenRequest request, OAuth2Client client) {
                log.info("Emitindo tokens via refresh_token para client: {}", client.getClientId());

                // Validar refresh token
                OAuth2Token oldRefreshToken = refreshTokenValidator.validate(request.getRefreshToken());

                // Verificar se o refresh token pertence ao cliente
                if (!client.getClientId().equals(oldRefreshToken.getClientId())) {
                        log.warn("Refresh token não pertence ao client: {}", client.getClientId());
                        throw new InvalidTokenException("Refresh token inválido");
                }

                // Verificar se o realm corresponde
                if (!client.getRealm().getId().equals(oldRefreshToken.getRealmId())) {
                        log.warn("Refresh token não pertence ao realm do client");
                        throw new InvalidTokenException("Refresh token inválido");
                }

                // Revogar refresh token anterior (rotação)
                oldRefreshToken.revogar("Rotação de refresh token");
                tokenRepository.save(oldRefreshToken);

                // Obter informações do token anterior
                String userId = oldRefreshToken.getUserId();
                String empresaId = oldRefreshToken.getEmpresaId();
                String tenantId = oldRefreshToken.getTenantId();
                UUID realmId = oldRefreshToken.getRealmId();

                // Buscar usuário se existir
                List<String> roles = List.of("SERVICE");
                if (userId != null) {
                        Usuario usuario = usuarioRepository.findById(UUID.fromString(userId))
                                        .orElseThrow(() -> new InvalidTokenException("Usuário não encontrado"));

                        // NOTA: Carga de roles do usuário ainda não implementada (aguarda entidade UsuarioRole)
                        // Atualmente utiliza role padrão "USER" para simplificação inicial
                        // Futura implementação: carregar roles da tabela de associação usuario_role
                        roles = List.of("USER");
                }

                // JWT claims
                Map<String, Object> claims = new HashMap<>();
                claims.put("sub", userId != null ? userId : client.getClientId());
                claims.put("realm", realmId.toString());
                claims.put("roles", roles);
                claims.put("empresaId", empresaId);
                claims.put("tenantId", tenantId);
                claims.put("client_id", client.getClientId());

                // Gerar novos tokens
                String accessToken = gerarJwt(claims, tokenSettings.getAccessTokenTimeToLive());
                String refreshToken = gerarJwt(claims, tokenSettings.getRefreshTokenTimeToLive());

                Instant accessExpiresAt = Instant.now().plusSeconds(tokenSettings.getAccessTokenTimeToLive());
                Instant refreshExpiresAt = Instant.now().plusSeconds(tokenSettings.getRefreshTokenTimeToLive());

                // Salvar access token no banco
                OAuth2Token accessTokenEntity = new OAuth2Token(
                                accessToken,
                                OAuth2TokenType.ACCESS_TOKEN,
                                userId,
                                client.getClientId(),
                                realmId,
                                empresaId,
                                tenantId,
                                LocalDateTime.ofInstant(accessExpiresAt, ZoneId.systemDefault()),
                                LocalDateTime.now(),
                                refreshToken);
                tokenRepository.save(accessTokenEntity);

                // Salvar refresh token no banco
                OAuth2Token refreshTokenEntity = new OAuth2Token(
                                refreshToken,
                                OAuth2TokenType.REFRESH_TOKEN,
                                userId,
                                client.getClientId(),
                                realmId,
                                empresaId,
                                tenantId,
                                LocalDateTime.ofInstant(refreshExpiresAt, ZoneId.systemDefault()),
                                LocalDateTime.now(),
                                null);
                tokenRepository.save(refreshTokenEntity);

                // Registrar auditoria
                auditoriaService.registrarEvento(
                                TipoEventoAuditoria.REFRESH_TOKEN,
                                "Refresh token utilizado por client: " + client.getClientId(),
                                userId != null ? UUID.fromString(userId) : null,
                                null,
                                realmId,
                                Map.of("client_id", client.getClientId()));

                auditoriaService.registrarEvento(
                                TipoEventoAuditoria.EMISSAO_TOKEN,
                                "Novos tokens emitidos via refresh para client: " + client.getClientId(),
                                userId != null ? UUID.fromString(userId) : null,
                                null,
                                realmId, Map.of("client_id", client.getClientId()));

                log.info("Tokens renovados com sucesso para client: {}", client.getClientId());

                return TokenResponse.builder()
                                .accessToken(accessToken)
                                .refreshToken(refreshToken)
                                .tokenType("Bearer")
                                .expiresIn((long) tokenSettings.getAccessTokenTimeToLive())
                                .scope(request.getScope())
                                .build();
        }

        /**
         * Emite tokens para grant_type=authorization_code.
         * NOTA: Esta é uma implementação simplificada para fins de MVP.
         * Implementação futura necessária: tabela AuthorizationCode com validação de tempo expiração, nonce, PKCE.
         */
        private TokenResponse emitirTokenAuthorizationCode(TokenRequest request, OAuth2Client client) {
                log.info("Emitindo tokens via authorization_code para client: {}", client.getClientId());

                // NOTA: Validação de authorization code simplificada para MVP
                // Futura implementação: criar entidade AuthorizationCode com expiração, validação de PKCE
                // e associação com usuário e client OAuth2
                if (request.getCode() == null || request.getCode().isEmpty()) {
                        throw new InvalidTokenException("Authorization code é obrigatório");
                }

                // Abordagem simplificada: code é interpretado como userId para fins de desenvolvimento
                // Em produção: code deve ser uma entidade gerada com tempo de expiração curto (~5 min)
                String userId = null;
                try {
                        UUID codeId = UUID.fromString(request.getCode());
                        userId = codeId.toString();
                } catch (IllegalArgumentException e) {
                        log.warn("Authorization code inválido: {}", request.getCode());
                        throw new InvalidTokenException("Authorization code inválido");
                }

                // Buscar usuário
                Usuario usuario = usuarioRepository.findById(UUID.fromString(userId))
                                .orElseThrow(() -> new InvalidTokenException("Usuário não encontrado"));

                Realm realm = realmRepository.findById(usuario.getRealmId())
                                .orElseThrow(() -> new RealmNotFoundException(usuario.getRealmId()));

                // NOTA: Carga de roles do usuário ainda não implementada (aguarda entidade UsuarioRole)
                // Atualmente utiliza role padrão "USER" para simplificação inicial
                // Futura implementação: carregar roles da tabela de associação usuario_role
                List<String> roles = List.of("USER");

                // JWT claims
                Map<String, Object> claims = new HashMap<>();
                claims.put("sub", usuario.getId().toString());
                claims.put("realm", realm.getId().toString());
                claims.put("roles", roles);
                claims.put("empresaId", usuario.getEmpresaId());
                claims.put("tenantId", usuario.getTenantId());
                claims.put("email", usuario.getEmail());
                claims.put("client_id", client.getClientId());

                // Gerar tokens
                String accessToken = gerarJwt(claims, tokenSettings.getAccessTokenTimeToLive());
                String refreshToken = gerarJwt(claims, tokenSettings.getRefreshTokenTimeToLive());

                Instant accessExpiresAt = Instant.now().plusSeconds(tokenSettings.getAccessTokenTimeToLive());
                Instant refreshExpiresAt = Instant.now().plusSeconds(tokenSettings.getRefreshTokenTimeToLive());

                // Salvar access token no banco
                OAuth2Token accessTokenEntity = new OAuth2Token(
                                accessToken,
                                OAuth2TokenType.ACCESS_TOKEN,
                                usuario.getId().toString(),
                                client.getClientId(),
                                realm.getId(),
                                usuario.getEmpresaId(),
                                usuario.getTenantId(),
                                LocalDateTime.ofInstant(accessExpiresAt, ZoneId.systemDefault()),
                                LocalDateTime.now(),
                                refreshToken);
                tokenRepository.save(accessTokenEntity);

                // Salvar refresh token no banco
                OAuth2Token refreshTokenEntity = new OAuth2Token(
                                refreshToken,
                                OAuth2TokenType.REFRESH_TOKEN,
                                usuario.getId().toString(),
                                client.getClientId(),
                                realm.getId(),
                                usuario.getEmpresaId(),
                                usuario.getTenantId(),
                                LocalDateTime.ofInstant(refreshExpiresAt, ZoneId.systemDefault()),
                                LocalDateTime.now(),
                                null);
                tokenRepository.save(refreshTokenEntity);

                // Registrar auditoria
                auditoriaService.registrarEvento(
                                TipoEventoAuditoria.EMISSAO_TOKEN,
                                "Token emitido via authorization_code para usuário: " + usuario.getEmail(),
                                usuario.getId(),
                                usuario.getEmail(),
                                realm.getId(),
                                Map.of("client_id", client.getClientId(), "grant_type", "authorization_code"));

                log.info("Tokens emitidos com sucesso para usuário: {} via client: {}", usuario.getEmail(),
                                client.getClientId());

                return TokenResponse.builder()
                                .accessToken(accessToken)
                                .refreshToken(refreshToken)
                                .tokenType("Bearer")
                                .expiresIn((long) tokenSettings.getAccessTokenTimeToLive())
                                .scope(request.getScope())
                                .build();
        }

        /**
         * Gera um JWT com as claims especificadas.
         *
         * @param claims            As claims do JWT
         * @param timeToLiveSeconds Tempo de vida em segundos
         * @return O JWT gerado
         */
        private String gerarJwt(Map<String, Object> claims, int timeToLiveSeconds) {
                Instant now = Instant.now();
                Instant expiresAt = now.plusSeconds(timeToLiveSeconds);

                JwtClaimsSet.Builder claimsBuilder = JwtClaimsSet.builder()
                                .issuer("http://localhost:8080")
                                .issuedAt(now)
                                .expiresAt(expiresAt)
                                .id(UUID.randomUUID().toString());

                claims.forEach(claimsBuilder::claim);

                JwtClaimsSet jwtClaimsSet = claimsBuilder.build();
                return jwtEncoder.encode(JwtEncoderParameters.from(jwtClaimsSet)).getTokenValue();
        }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.domain.validator;

import java.util.Optional;

import org.springframework.stereotype.Component;

import br.com.plataforma.conexaodigital.oauth2.domain.exception.InvalidTokenException;
import br.com.plataforma.conexaodigital.oauth2.domain.exception.TokenRevogadoException;
import br.com.plataforma.conexaodigital.oauth2.domain.model.OAuth2Token;
import br.com.plataforma.conexaodigital.oauth2.domain.repository.OAuth2TokenRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Validador de refresh tokens.
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class RefreshTokenValidator {

    private final OAuth2TokenRepository tokenRepository;

    /**
     * Valida um refresh token.
     *
     * @param refreshTokenValue O valor do refresh token
     * @return O OAuth2Token se válido
     * @throws InvalidTokenException  Se o token estiver expirado
     * @throws TokenRevogadoException Se o token estiver revogado
     * @throws InvalidTokenException  Se o token não existir
     */
    public OAuth2Token validate(String refreshTokenValue) {
        log.debug("Validando refresh token");

        Optional<OAuth2Token> tokenOpt = tokenRepository.findValidRefreshToken(refreshTokenValue);

        if (tokenOpt.isEmpty()) {
            log.warn("Refresh token não encontrado ou inválido");

            // Verificar se o token existe e está revogado
            tokenRepository.findByTokenValue(refreshTokenValue).ifPresent(token -> {
                if (token.isRevogado()) {
                    log.debug("Refresh token está revogado");
                    throw new TokenRevogadoException("Refresh token foi revogado");
                }
                if (token.estaExpirado()) {
                    log.debug("Refresh token está expirado");
                    throw new InvalidTokenException("Refresh token expirado");
                }
            });

            throw new InvalidTokenException("Refresh token inválido");
        }

        OAuth2Token token = tokenOpt.get();

        if (token.isRevogado()) {
            log.warn("Refresh token está revogado: {}", token.getId());
            throw new TokenRevogadoException("Refresh token foi revogado");
        }

        if (token.estaExpirado()) {
            log.warn("Refresh token está expirado: {}", token.getId());
            throw new InvalidTokenException("Refresh token expirado");
        }

        log.debug("Refresh token válido: {}", token.getId());
        return token;
    }

    /**
     * Verifica se um refresh token é válido sem lançar exceção.
     *
     * @param refreshTokenValue O valor do refresh token
     * @return true se válido, false caso contrário
     */
    public boolean isValid(String refreshTokenValue) {
        try {
            validate(refreshTokenValue);
            return true;
        } catch (Exception e) {
            log.debug("Refresh token inválido: {}", e.getMessage());
            return false;
        }
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.infrastructure.jwks;

import br.com.plataforma.conexaodigital.oauth2.api.responses.JwksResponse;
import br.com.plataforma.conexaodigital.chave.domain.model.ChaveCriptografica;
import br.com.plataforma.conexaodigital.chave.domain.model.StatusChave;
import br.com.plataforma.conexaodigital.chave.domain.repository.ChaveCriptograficaRepository;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.jwk.JWK;
import com.nimbusds.jose.jwk.JWKSet;
import com.nimbusds.jose.jwk.RSAKey;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.X509EncodedKeySpec;
import java.time.LocalDateTime;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Provider para gerar JWKS (JSON Web Key Set) por realm.
 * Converte chaves criptográficas armazenadas no banco para o formato JWK.
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class JwksProvider {

    private final ChaveCriptograficaRepository chaveRepository;

    /**
     * Obtém o JWKS de um realm.
     * Retorna apenas chaves ativas que podem ser usadas para validação (grace period).
     *
     * @param realmId O ID do realm
     * @return JwksResponse com as chaves públicas do realm
     */
    public JwksResponse obterJwks(UUID realmId) {
        log.debug("Buscando JWKS para realm: {}", realmId);

        List<ChaveCriptografica> chaves = chaveRepository.findByRealmIdAndStatusInOrderByDataCriacaoDesc(
            realmId, List.of(StatusChave.ATIVA, StatusChave.INATIVA));

        log.debug("Encontradas {} chaves ativas para realm: {}", chaves.size(), realmId);

        List<JwksResponse.JsonWebKey> keys = chaves.stream()
                .map(this::convertToJwk)
                .collect(Collectors.toList());

        log.debug("JWKS gerado com {} chaves convertidas para realm: {}", keys.size(), realmId);

        if (keys.isEmpty()) {
            log.warn("Nenhuma chave encontrada para realm: {}. Retornando JWKS vazio.", realmId);
        }

        return new JwksResponse(keys);
    }

    /**
     * Obtém o JWKSet de um realm no formato padrão do NimbusDS.
     *
     * @param realmId O ID do realm
     * @return JWKSet com as chaves públicas
     */
    public JWKSet obterJwkSet(UUID realmId) {
        log.debug("Buscando JWKSet para realm: {}", realmId);

        List<ChaveCriptografica> chaves = chaveRepository.findByRealmIdAndStatusInOrderByDataCriacaoDesc(
            realmId, List.of(StatusChave.ATIVA, StatusChave.INATIVA));

        List<JWK> keys = chaves.stream()
                .map(this::convertToRsaKey)
                .collect(Collectors.toList());

        return new JWKSet(keys);
    }

    /**
     * Converte uma ChaveCriptografica para JsonWebKey.
     *
     * @param chave A chave criptográfica
     * @return JsonWebKey
     */
    private JwksResponse.JsonWebKey convertToJwk(ChaveCriptografica chave) {
        log.debug("Convertendo chave {} para JWK", chave.getVersao());

        RSAPublicKey publicKey = parsePublicKey(chave.getPublicKey());

        log.debug("Chave pública parseada com sucesso para versão {}", chave.getVersao());

        JwksResponse.JsonWebKey jwk = JwksResponse.JsonWebKey.builder()
                .kid(chave.getVersao().toString())
                .kty("RSA")
                .use("sig")
                .alg("RS256")
                .n(Base64.getUrlEncoder().withoutPadding()
                        .encodeToString(publicKey.getModulus().toByteArray()))
                .e(Base64.getUrlEncoder().withoutPadding()
                        .encodeToString(publicKey.getPublicExponent().toByteArray()))
                .build();

        log.debug("JWK criado com sucesso para chave {}", chave.getVersao());

        return jwk;
    }

    /**
     * Converte uma ChaveCriptografica para RSAKey do NimbusDS.
     *
     * @param chave A chave criptográfica
     * @return RSAKey
     */
    private RSAKey convertToRsaKey(ChaveCriptografica chave) {
        RSAPublicKey publicKey = parsePublicKey(chave.getPublicKey());

        return new RSAKey.Builder(publicKey)
                .keyID(chave.getVersao().toString())
                .algorithm(new com.nimbusds.jose.JWSAlgorithm(com.nimbusds.jose.JWSAlgorithm.RS256.getName()))
                .keyUse(com.nimbusds.jose.jwk.KeyUse.SIGNATURE)
                .build();
    }

    /**
     * Converte uma chave pública em formato PEM para RSAPublicKey.
     *
     * @param publicKeyPem A chave pública em formato PEM
     * @return RSAPublicKey
     */
    private RSAPublicKey parsePublicKey(String publicKeyPem) {
        try {
            // Remove cabeçalho e rodapé PEM
            String publicKeyContent = publicKeyPem
                    .replace("-----BEGIN PUBLIC KEY-----", "")
                    .replace("-----END PUBLIC KEY-----", "")
                    .replaceAll("\\s", "");

            // Decodifica Base64
            byte[] keyBytes = Base64.getDecoder().decode(publicKeyContent);

            // Cria a especificação X509EncodedKeySpec
            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");

            return (RSAPublicKey) keyFactory.generatePublic(keySpec);
        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
            throw new IllegalArgumentException("Erro ao converter chave pública PEM para RSAPublicKey", e);
        }
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.web.handler;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

/**
 * Handler para gerenciar o cookie de refresh token.
 * Implementa remember-me com TTL configurável.
 */
@Component
@Slf4j
public class RefreshTokenCookieHandler {

    private static final int SECONDS_PER_DAY = 86400;
    private static final int DEFAULT_REFRESH_DAYS = 30;
    private static final int REMEMBER_ME_REFRESH_DAYS = 90;

    /**
     * Adiciona o cookie de refresh token à resposta.
     *
     * @param response     HttpServletResponse
     * @param refreshToken Valor do refresh token
     * @param rememberMe   Se true, cookie expira em 90 dias; se false, 30 dias
     */
    public void addRefreshTokenCookie(HttpServletResponse response, String refreshToken, boolean rememberMe) {
        log.debug("Adicionando cookie refresh_token com rememberMe={}", rememberMe);

        int maxAge = rememberMe ? REMEMBER_ME_REFRESH_DAYS * SECONDS_PER_DAY
                                : DEFAULT_REFRESH_DAYS * SECONDS_PER_DAY;

        Cookie cookie = new Cookie("refresh_token", refreshToken);
        cookie.setHttpOnly(true);
        cookie.setSecure(true);
        cookie.setPath("/");
        cookie.setMaxAge(maxAge);

        response.addCookie(cookie);

        log.info("Cookie refresh_token adicionado com MaxAge={} segundos (rememberMe={})", maxAge, rememberMe);
    }

    /**
     * Remove o cookie de refresh token definindo MaxAge=0.
     *
     * @param response HttpServletResponse
     */
    public void clearRefreshTokenCookie(HttpServletResponse response) {
        log.debug("Removendo cookie refresh_token");

        Cookie cookie = new Cookie("refresh_token", "");
        cookie.setHttpOnly(true);
        cookie.setSecure(true);
        cookie.setPath("/");
        cookie.setMaxAge(0);

        response.addCookie(cookie);

        log.info("Cookie refresh_token removido");
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.web.handler;

import br.com.plataforma.conexaodigital.auditoria.domain.model.enums.TipoEventoAuditoria;
import br.com.plataforma.conexaodigital.auditoria.domain.service.AuditoriaService;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.Authentication;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class RememberMeAuthenticationSuccessHandler implements AuthenticationSuccessHandler {

    private final RefreshTokenCookieHandler refreshTokenCookieHandler;
    private final AuditoriaService auditoriaService;

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request,
                                    HttpServletResponse response,
                                    Authentication authentication) throws IOException {
        String username = authentication.getName();
        log.info("Login realizado com sucesso para usuário: {}", username);

        String rememberMeParam = request.getParameter("rememberMe");
        boolean rememberMe = "true".equalsIgnoreCase(rememberMeParam);

        log.debug("Definindo cookie de remember-me: rememberMe={}", rememberMe);

        String email = username;
        TipoEventoAuditoria tipoEvento = rememberMe ? TipoEventoAuditoria.LOGIN_REMEMBER_ME : TipoEventoAuditoria.LOGIN;
        auditoriaService.registrarEvento(tipoEvento, "Login realizado por: " + email, null, email);

        response.sendRedirect("/admin/dashboard");
    }
}

```
```java
package br.com.plataforma.conexaodigital.oauth2.web.handler;

import br.com.plataforma.conexaodigital.auditoria.domain.model.enums.TipoEventoAuditoria;
import br.com.plataforma.conexaodigital.auditoria.domain.service.AuditoriaService;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.Authentication;
import org.springframework.security.web.authentication.logout.LogoutHandler;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class RememberMeLogoutHandler implements LogoutHandler {

    private final RefreshTokenCookieHandler refreshTokenCookieHandler;
    private final AuditoriaService auditoriaService;

    @Override
    public void logout(HttpServletRequest request,
                    HttpServletResponse response,
                    Authentication authentication) {
        String username = authentication != null ? authentication.getName() : "anônimo";
        log.info("Logout realizado para usuário: {}", username);

        refreshTokenCookieHandler.clearRefreshTokenCookie(response);

        if (authentication != null) {
            String email = authentication.getName();
            auditoriaService.registrarEvento(TipoEventoAuditoria.LOGOUT, "Logout realizado por: " + email, null, email);
        }
    }
}

```
```java
package br.com.plataforma.conexaodigital.realm.api.controller;

import java.time.LocalDateTime;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import br.com.plataforma.conexaodigital.realm.api.requests.AtualizarRealmRequest;
import br.com.plataforma.conexaodigital.realm.api.requests.CriarRealmRequest;
import br.com.plataforma.conexaodigital.realm.api.responses.RealmResponse;
import br.com.plataforma.conexaodigital.realm.domain.model.StatusRealm;
import br.com.plataforma.conexaodigital.realm.domain.service.RealmService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;

/**
 * REST controller for managing realms.
 * Provides endpoints for CRUD operations on realms.
 */
@RestController
@RequestMapping("/api/v1/realms")
@Tag(name = "Gestão de Realms", description = "Operações de gestão de realms")
public class RealmController {

    private final RealmService realmService;

    /**
     * Constructor with dependency injection.
     *
     * @param realmService The realm service
     */
    public RealmController(RealmService realmService) {
        this.realmService = realmService;
    }

    /**
     * Creates a new realm.
     *
     * @param request The request containing realm name
     * @return ResponseEntity with created realm and HTTP status 201
     */
    @PostMapping
    @Operation(summary = "Criar novo realm", description = "Cria um novo realm com status ATIVO por padrão. O nome do realm deve ser único no sistema.")
    @ApiResponses({
            @ApiResponse(responseCode = "201", description = "Realm criado com sucesso", content = @Content(schema = @Schema(implementation = RealmResponse.class))),
            @ApiResponse(responseCode = "400", description = "Dados inválidos"),
            @ApiResponse(responseCode = "409", description = "Nome de realm já existe")
    })
    public ResponseEntity<RealmResponse> criar(@Valid @RequestBody CriarRealmRequest request) {
        RealmResponse realmResponse = realmService.criar(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(realmResponse);
    }

    /**
     * Updates an existing realm.
     *
     * @param id      The UUID of realm to update
     * @param request The request containing the new realm name and status
     * @return ResponseEntity with the updated realm and HTTP status 200
     */
    @PutMapping("/{id}")
    @Operation(summary = "Atualizar realm", description = "Atualiza nome e status de um realm existente. O nome deve manter as regras de validação.")
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Realm atualizado com sucesso", content = @Content(schema = @Schema(implementation = RealmResponse.class))),
            @ApiResponse(responseCode = "400", description = "Dados inválidos"),
            @ApiResponse(responseCode = "404", description = "Realm não encontrado"),
            @ApiResponse(responseCode = "409", description = "Nome de realm já existe em outro realm")
    })
    public ResponseEntity<RealmResponse> atualizar(
            @PathVariable UUID id,
            @Valid @RequestBody AtualizarRealmRequest request) {
        RealmResponse realmResponse = realmService.atualizar(id, request);
        return ResponseEntity.ok(realmResponse);
    }

    /**
     * Deactivates a realm (soft delete).
     *
     * @param id The UUID of realm to deactivate
     * @return ResponseEntity with HTTP status 204
     */
    @DeleteMapping("/{id}")
    @Operation(summary = "Desativar realm", description = "Desativa um realm (soft delete), mantendo todos os dados relacionados. Realm Master não pode ser desativado.")
    @ApiResponses({
            @ApiResponse(responseCode = "204", description = "Realm desativado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Realm já está inativo ou é Realm Master"),
            @ApiResponse(responseCode = "404", description = "Realm não encontrado")
    })
    public ResponseEntity<Void> desativar(@PathVariable UUID id) {
        realmService.desativar(id);
        return ResponseEntity.noContent().build();
    }

    /**
     * Reactivates a realm that was previously deactivated.
     *
     * @param id The UUID of realm to reactivate
     * @return ResponseEntity with the reactivated realm and HTTP status 200
     */
    @PatchMapping("/{id}/reativar")
    @Operation(summary = "Reativar realm", description = "Reativa um realm desativado, restaurando o funcionamento normal")
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Realm reativado com sucesso", content = @Content(schema = @Schema(implementation = RealmResponse.class))),
            @ApiResponse(responseCode = "400", description = "Realm já está ativo"),
            @ApiResponse(responseCode = "404", description = "Realm não encontrado")
    })
    public ResponseEntity<RealmResponse> reativar(@PathVariable UUID id) {
        RealmResponse realmResponse = realmService.reativar(id);
        return ResponseEntity.ok(realmResponse);
    }

    /**
     * Lists realms with optional filtering and pagination.
     *
     * @param nome              Optional name filter (partial match,
     *                          case-insensitive)
     * @param status            Optional status filter
     * @param dataCriacaoInicio Optional creation date start filter (ISO format)
     * @param dataCriacaoFim    Optional creation date end filter (ISO format)
     * @param pageable          Pagination and sorting parameters
     * @return ResponseEntity with page of realms and HTTP status 200
     */
    @GetMapping
    @Operation(summary = "Listar realms", description = "Lista realms com paginação e filtros opcionais. Permite filtrar por nome (busca parcial), status e período de criação.")
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Lista de realms retornada com sucesso", content = @Content(schema = @Schema(implementation = Page.class)))
    })
    public ResponseEntity<Page<RealmResponse>> listar(
            @Parameter(description = "Filtro opcional por nome (busca parcial, case-insensitive)") @RequestParam(required = false) String nome,
            @Parameter(description = "Filtro opcional por status (ATIVO ou INATIVO)") @RequestParam(required = false) StatusRealm status,
            @Parameter(description = "Filtro opcional por data de criação inicial (formato ISO)") @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime dataCriacaoInicio,
            @Parameter(description = "Filtro opcional por data de criação final (formato ISO)") @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime dataCriacaoFim,
            @Parameter(description = "Parâmetros de paginação e ordenação (page, size, sort)") Pageable pageable) {
        Page<RealmResponse> realms = realmService.listar(nome, status, dataCriacaoInicio, dataCriacaoFim, pageable);
        return ResponseEntity.ok(realms);
    }

    /**
     * Finds a realm by its ID.
     *
     * @param id The UUID of the realm to find
     * @return ResponseEntity with the realm and HTTP status 200
     */
    @GetMapping("/{id}")
    @Operation(summary = "Buscar realm por ID", description = "Retorna os detalhes completos de um realm específico pelo seu identificador único")
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Realm encontrado com sucesso", content = @Content(schema = @Schema(implementation = RealmResponse.class))),
            @ApiResponse(responseCode = "404", description = "Realm não encontrado", content = @Content(schema = @Schema(implementation = String.class)))
    })
    public ResponseEntity<RealmResponse> buscarPorId(@PathVariable UUID id) {
        RealmResponse realmResponse = realmService.buscarPorId(id);
        return ResponseEntity.ok(realmResponse);
    }
}

```
```java
package br.com.plataforma.conexaodigital.realm.api.requests;

import br.com.plataforma.conexaodigital.realm.domain.model.StatusRealm;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

/**
 * Request DTO for updating an existing Realm.
 * Contains validation annotations to ensure data integrity.
 */
@Schema(description = "DTO de requisição para atualização de Realm existente")
public record AtualizarRealmRequest(

                @NotBlank(message = "Nome do realm é obrigatório") @Size(min = 3, max = 50, message = "Nome deve ter entre 3 e 50 caracteres") @Pattern(regexp = "^[a-z][a-z0-9_-]*$", message = "Nome deve começar com letra e conter apenas letras, números, hífens e underscores em minúsculas") @Schema(description = "Nome único do realm (3-50 caracteres, minúsculas)", example = "empresa-a", required = true) String nome,

                @NotNull(message = "Status é obrigatório") @Schema(description = "Status do realm", example = "ATIVO", required = true) StatusRealm status) {
}

```
```java
package br.com.plataforma.conexaodigital.realm.api.requests;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

/**
 * Request DTO for creating a new Realm.
 * Contains validation annotations to ensure data integrity.
 */
@Schema(description = "DTO de requisição para criação de um novo Realm")
public record CriarRealmRequest(

                @NotBlank(message = "Nome do realm é obrigatório") @Size(min = 3, max = 50, message = "Nome deve ter entre 3 e 50 caracteres") @Pattern(regexp = "^[a-z][a-z0-9_-]*$", message = "Nome deve começar com letra e conter apenas letras, números, hífens e underscores em minúsculas") @Schema(description = "Nome único do realm (3-50 caracteres, minúsculas)", example = "empresa-a", required = true) String nome) {
}

```
```java
package br.com.plataforma.conexaodigital.realm.api.responses;

import java.time.LocalDateTime;
import java.util.UUID;

import br.com.plataforma.conexaodigital.realm.domain.model.StatusRealm;
import io.swagger.v3.oas.annotations.media.Schema;

/**
 * Response DTO for Realm data.
 * Represents a realm with all its fields.
 */
@Schema(description = "DTO de resposta para dados de Realm")
public record RealmResponse(

                @Schema(description = "Identificador único do realm (UUID)", example = "550e8400-e29b-41d4-a716-446655440000") UUID id,

                @Schema(description = "Nome do realm", example = "empresa-a") String nome,

                @Schema(description = "Status do realm", example = "ATIVO") StatusRealm status,

                @Schema(description = "Data de criação do realm", example = "2024-01-15T10:30:00") LocalDateTime dataCriacao,

                @Schema(description = "Data da última atualização do realm", example = "2024-01-15T10:30:00") LocalDateTime dataAtualizacao) {
}

```
```java
package br.com.plataforma.conexaodigital.realm.domain.exceptions;

import br.com.plataforma.conexaodigital.shared.exceptions.BusinessException;

/**
 * Exception thrown when attempting to create a realm with a name that already exists.
 */
public class NomeRealmJaExisteException extends BusinessException {

    /**
     * Constructs a new NomeRealmJaExisteException for a specific realm name.
     *
     * @param nome The name of realm that already exists
     */
    public NomeRealmJaExisteException(String nome) {
        super(String.format("Já existe um realm com o nome '%s'", nome));
    }

    /**
     * Constructs a new NomeRealmJaExisteException with the specified detail message and cause.
     *
     * @param message The detail message
     * @param cause   The cause of the exception
     */
    public NomeRealmJaExisteException(String message, Throwable cause) {
        super(message, cause);
    }
}

```
```java
package br.com.plataforma.conexaodigital.realm.domain.exceptions;

import br.com.plataforma.conexaodigital.shared.exceptions.BusinessException;

/**
 * Exception thrown when attempting to reactivate a realm that is already active.
 */
public class RealmJaAtivoException extends BusinessException {

    /**
     * Constructs a new RealmJaAtivoException for a realm that is already active.
     *
     * @param nome The name of the realm
     */
    public RealmJaAtivoException(String nome) {
        super(String.format("Realm '%s' já está ativo", nome));
    }
}
```
```java
package br.com.plataforma.conexaodigital.realm.domain.exceptions;

import br.com.plataforma.conexaodigital.shared.exceptions.BusinessException;

/**
 * Exception thrown when attempting to deactivate a realm that is already inactive.
 * Or when attempting to deactivate Realm Master.
 */
public class RealmJaInativoException extends BusinessException {

    /**
     * Constructs a new RealmJaInativoException for a realm that is already inactive.
     *
     * @param nome The name of realm
     */
    public RealmJaInativoException(String nome) {
        super(String.format("Realm '%s' já está inativo", nome));
    }

    /**
     * Constructs a new RealmJaInativoException for Realm Master.
     */
    public RealmJaInativoException() {
        super("Realm Master não pode ser desativado");
    }
}

```
```java
package br.com.plataforma.conexaodigital.realm.domain.exceptions;

import br.com.plataforma.conexaodigital.shared.exceptions.BusinessException;

import java.util.UUID;

/**
 * Exception thrown when a Realm with a specific ID cannot be found.
 */
public class RealmNotFoundException extends BusinessException {

    /**
     * Constructs a new RealmNotFoundException for a specific ID.
     *
     * @param id The ID of the realm that was not found
     */
    public RealmNotFoundException(UUID id) {
        super(String.format("Realm não encontrado com ID: %s", id));
    }

    /**
     * Constructs a new RealmNotFoundException with a custom message.
     *
     * @param message The detail message
     */
    public RealmNotFoundException(String message) {
        super(message);
    }
}

```
```java
package br.com.plataforma.conexaodigital.realm.domain.model;

import java.time.LocalDateTime;
import java.util.UUID;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import jakarta.persistence.Version;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

/**
 * Represents a Realm in authorization server.
 * A Realm is a logical isolation domain for authentication and authorization,
 * containing users, roles, OAuth2 clients, cryptographic keys, and audit
 * events.
 */
@Entity
@Table(name = "realms")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Realm {

    @Id
    @Column(name = "id", updatable = false, nullable = false)
    private UUID id;

    @NotBlank(message = "Nome do realm é obrigatório")
    @Size(min = 3, max = 50, message = "Nome deve ter entre 3 e 50 caracteres")
    @Column(name = "nome", unique = true, nullable = false, length = 50)
    private String nome;

    @NotNull(message = "Status do realm é obrigatório")
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private StatusRealm status;

    @Size(max = 500, message = "Descrição deve ter no máximo 500 caracteres")
    @Column(name = "descricao", length = 500)
    private String descricao;

    @Column(name = "empresa_id", length = 100)
    private String empresaId;

    @Column(name = "tenant_id", length = 100)
    private String tenantId;

    @Column(name = "master", nullable = false)
    private Boolean master = false;

    @Column(name = "data_criacao", updatable = false, nullable = false)
    private LocalDateTime dataCriacao;

    @Column(name = "data_atualizacao", nullable = false)
    private LocalDateTime dataAtualizacao;

    @Column(name = "data_desativacao")
    private LocalDateTime dataDesativacao;

    @Column(name = "data_reativacao")
    private LocalDateTime dataReativacao;

    @Version
    @Column(name = "versao")
    private Long versao;

    /**
     * Creates a new Realm with the specified name and status.
     *
     * @param nome   The unique name of the realm
     * @param status The status of the realm (ATIVO or INATIVO)
     */
    public Realm(String nome, StatusRealm status) {
        this.id = UUID.randomUUID();
        this.nome = nome.toLowerCase();
        this.status = status;
        this.dataCriacao = LocalDateTime.now();
        this.dataAtualizacao = LocalDateTime.now();
        this.versao = 0L;
    }

    // Getters

    public UUID getId() {
        return id;
    }

    public String getNome() {
        return nome;
    }

    public StatusRealm getStatus() {
        return status;
    }

    public LocalDateTime getDataCriacao() {
        return dataCriacao;
    }

    public LocalDateTime getDataAtualizacao() {
        return dataAtualizacao;
    }

    public Long getVersao() {
        return versao;
    }

    public String getDescricao() {
        return descricao;
    }

    public String getEmpresaId() {
        return empresaId;
    }

    public String getTenantId() {
        return tenantId;
    }

    public Boolean getMaster() {
        return master;
    }

    public LocalDateTime getDataDesativacao() {
        return dataDesativacao;
    }

    public LocalDateTime getDataReativacao() {
        return dataReativacao;
    }

    // Setters (only for business logic use)

    public void setId(UUID id) {
        this.id = id;
    }

    public void setNome(String nome) {
        this.nome = nome.toLowerCase();
        this.dataAtualizacao = LocalDateTime.now();
    }

    public void setStatus(StatusRealm status) {
        this.status = status;
        this.dataAtualizacao = LocalDateTime.now();
    }

    public void setDataCriacao(LocalDateTime dataCriacao) {
        this.dataCriacao = dataCriacao;
    }

    public void setDataAtualizacao(LocalDateTime dataAtualizacao) {
        this.dataAtualizacao = dataAtualizacao;
    }

    public void setVersao(Long versao) {
        this.versao = versao;
    }

    public void setDescricao(String descricao) {
        this.descricao = descricao;
        this.dataAtualizacao = LocalDateTime.now();
    }

    public void setEmpresaId(String empresaId) {
        this.empresaId = empresaId;
        this.dataAtualizacao = LocalDateTime.now();
    }

    public void setTenantId(String tenantId) {
        this.tenantId = tenantId;
        this.dataAtualizacao = LocalDateTime.now();
    }

    public void setMaster(Boolean master) {
        this.master = master;
        this.dataAtualizacao = LocalDateTime.now();
    }

    public void setDataDesativacao(LocalDateTime dataDesativacao) {
        this.dataDesativacao = dataDesativacao;
        this.dataAtualizacao = LocalDateTime.now();
    }

    public void setDataReativacao(LocalDateTime dataReativacao) {
        this.dataReativacao = dataReativacao;
        this.dataAtualizacao = LocalDateTime.now();
    }

    /**
     * Marks realm as updated with current timestamp.
     */
    public void markAsUpdated() {
        this.dataAtualizacao = LocalDateTime.now();
    }

    /**
     * Activates the realm.
     */
    public void ativar() {
        this.status = StatusRealm.ATIVO;
        this.dataAtualizacao = LocalDateTime.now();
    }

    /**
     * Deactivates the realm.
     */
    public void desativar() {
        this.status = StatusRealm.INATIVO;
        this.dataAtualizacao = LocalDateTime.now();
    }

    /**
     * Checks if realm is active.
     *
     * @return true if realm is ATIVO, false otherwise
     */
    public boolean isAtivo() {
        return StatusRealm.ATIVO.equals(this.status);
    }

    /**
     * Checks if realm is inactive.
     *
     * @return true if realm is INATIVO, false otherwise
     */
    public boolean isInativo() {
        return StatusRealm.INATIVO.equals(this.status);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Realm realm = (Realm) o;
        return id != null && id.equals(realm.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }

    @Override
    public String toString() {
        return "Realm{" +
                "id=" + id +
                ", nome='" + nome + '\'' +
                ", descricao='" + descricao + '\'' +
                ", status=" + status +
                ", empresaId='" + empresaId + '\'' +
                ", tenantId='" + tenantId + '\'' +
                ", master=" + master +
                ", dataCriacao=" + dataCriacao +
                ", dataAtualizacao=" + dataAtualizacao +
                ", dataDesativacao=" + dataDesativacao +
                ", dataReativacao=" + dataReativacao +
                ", versao=" + versao +
                '}';
    }
}

```
```java
package br.com.plataforma.conexaodigital.realm.domain.model;

/**
 * Enum representing the status of a Realm.
 * A Realm can be either ATIVO (active) or INATIVO (inactive).
 */
public enum StatusRealm {

    /**
     * Realm is active and operational.
     */
    ATIVO("Ativo"),

    /**
     * Realm is inactive and not operational.
     */
    INATIVO("Inativo");

    private final String descricao;

    StatusRealm(String descricao) {
        this.descricao = descricao;
    }

    public String getDescricao() {
        return descricao;
    }
}

```
```java
package br.com.plataforma.conexaodigital.realm.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import br.com.plataforma.conexaodigital.realm.domain.model.StatusRealm;

/**
 * Repository interface for Realm entity operations.
 * Extends JpaRepository for standard CRUD operations and
 * JpaSpecificationExecutor
 * for complex query support.
 */
@Repository
public interface RealmRepository extends JpaRepository<Realm, UUID>, JpaSpecificationExecutor<Realm> {

    /**
     * Finds a realm by its name (case-insensitive).
     *
     * @param nome The name of realm
     * @return Optional containing realm if found
     */
    Optional<Realm> findByNomeIgnoreCase(String nome);

    /**
     * Checks if a realm with given name exists (case-insensitive).
     *
     * @param nome The name to check
     * @return true if a realm with name exists, false otherwise
     */
    boolean existsByNomeIgnoreCase(String nome);

    /**
     * Finds a realm by its ID.
     *
     * @param id The UUID of realm
     * @return Optional containing realm if found
     */
    Optional<Realm> findById(UUID id);

    /**
     * Finds realms by name containing (case-insensitive) with pagination.
     *
     * @param nome The name to search for
     * @param pageable Pagination information
     * @return Page of realms matching the criteria
     */
    Page<Realm> findByNomeContainingIgnoreCase(String nome, Pageable pageable);

    /**
     * Finds realms by status with pagination.
     *
     * @param status The status to filter by
     * @param pageable Pagination information
     * @return Page of realms with the given status
     */
    Page<Realm> findByStatus(StatusRealm status, Pageable pageable);

    /**
     * Finds realms by name containing and status with pagination.
     *
     * @param nome The name to search for
     * @param status The status to filter by
     * @param pageable Pagination information
     * @return Page of realms matching both criteria
     */
    Page<Realm> findByNomeContainingIgnoreCaseAndStatus(String nome, StatusRealm status, Pageable pageable);

    /**
     * Returns all realm IDs for bootstrap operations.
     *
     * @return List of all realm UUIDs
     */
    @Query("SELECT r.id FROM Realm r")
    List<UUID> findAllIds();
}


```
```java
package br.com.plataforma.conexaodigital.realm.domain.service;

import java.time.LocalDateTime;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import br.com.plataforma.conexaodigital.realm.api.requests.AtualizarRealmRequest;
import br.com.plataforma.conexaodigital.realm.api.requests.CriarRealmRequest;
import br.com.plataforma.conexaodigital.realm.api.responses.RealmResponse;
import br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmJaAtivoException;
import br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmJaInativoException;
import br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmNotFoundException;
import br.com.plataforma.conexaodigital.realm.domain.model.StatusRealm;

/**
 * Service interface for Realm business operations.
 * Defines the contract for realm management operations.
 */
public interface RealmService {

    /**
     * Creates a new realm with the provided data.
     *
     * @param request The request containing the realm name
     * @return The created realm response
     */
    RealmResponse criar(CriarRealmRequest request);

    /**
     * Updates an existing realm with provided data.
     *
     * @param id      The UUID of realm to update
     * @param request The request containing new realm name and status
     * @return The updated realm response
     */
    RealmResponse atualizar(UUID id, AtualizarRealmRequest request);

    /**
     * Deactivates a realm (soft delete).
     *
     * @param id The UUID of realm to deactivate
     * @throws RealmNotFoundException  if realm not found
     * @throws RealmJaInativoException if realm is already inactive or is Realm
     *                                 Master
     */
    void desativar(UUID id);

    /**
     * Reactivates a realm that was previously deactivated.
     *
     * @param id The UUID of realm to reactivate
     * @return The reactivated realm response
     * @throws RealmNotFoundException if realm not found
     * @throws RealmJaAtivoException  if realm is already active
     */
    RealmResponse reativar(UUID id);

    /**
     * Lists realms with optional filtering and pagination.
     *
     * @param nome              Optional name filter (partial match,
     *                          case-insensitive)
     * @param status            Optional status filter
     * @param dataCriacaoInicio Optional creation date start filter
     * @param dataCriacaoFim    Optional creation date end filter
     * @param pageable          Pagination and sorting parameters
     * @return Page of realm responses
     */
    Page<RealmResponse> listar(String nome, StatusRealm status, LocalDateTime dataCriacaoInicio,
            LocalDateTime dataCriacaoFim, Pageable pageable);

    /**
     * Finds a realm by its ID.
     *
     * @param id The UUID of the realm to find
     * @return The realm response
     * @throws RealmNotFoundException if realm with given ID doesn't exist
     */
    RealmResponse buscarPorId(UUID id);
}

```
```java
package br.com.plataforma.conexaodigital.realm.domain.service;

import java.time.LocalDateTime;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.plataforma.conexaodigital.auditoria.domain.service.AuditoriaService;
import br.com.plataforma.conexaodigital.auditoria.domain.model.enums.TipoEventoAuditoria;
import br.com.plataforma.conexaodigital.realm.api.requests.AtualizarRealmRequest;
import br.com.plataforma.conexaodigital.realm.api.requests.CriarRealmRequest;
import br.com.plataforma.conexaodigital.realm.api.responses.RealmResponse;
import br.com.plataforma.conexaodigital.realm.domain.exceptions.NomeRealmJaExisteException;
import br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmJaAtivoException;
import br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmJaInativoException;
import br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmNotFoundException;
import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import br.com.plataforma.conexaodigital.realm.domain.model.StatusRealm;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import br.com.plataforma.conexaodigital.realm.infrastructure.persistence.RealmSpecification;
import lombok.RequiredArgsConstructor;

/**
 * Implementation of RealmService.
 * Contains business logic for realm operations.
 */
@Service
@Transactional
@RequiredArgsConstructor
public class RealmServiceImpl implements RealmService {

    private final RealmRepository realmRepository;
    private final AuditoriaService auditoriaService;

    /**
     * Creates a new realm with the provided data.
     *
     * @param request The request containing the realm name
     * @return The created realm response
     * @throws NomeRealmJaExisteException if a realm with the same name already
     *                                    exists
     */
    @Override
    public RealmResponse criar(CriarRealmRequest request) {
        String nomeNormalizado = request.nome().toLowerCase();

        // Verificar se já existe um realm com o mesmo nome
        if (realmRepository.existsByNomeIgnoreCase(nomeNormalizado)) {
            throw new NomeRealmJaExisteException(nomeNormalizado);
        }

        // Criar novo realm com status ATIVO por padrão
        Realm realm = new Realm(nomeNormalizado, StatusRealm.ATIVO);

        // Salvar no banco de dados
        Realm realmSalvo = realmRepository.save(realm);

        // Registrar evento de auditoria
        auditoriaService.registrarEvento(
            TipoEventoAuditoria.CRIACAO_REALM,
            String.format("Realm criado: %s (ID: %s)", nomeNormalizado, realmSalvo.getId()),
            realmSalvo.getId()
        );

        // Retornar response DTO
        return mapearParaResponse(realmSalvo);
    }

    /**
     * Updates an existing realm with the provided data.
     *
     * @param id      The UUID of realm to update
     * @param request The request containing the new realm name and status
     * @return The updated realm response
     * @throws RealmNotFoundException     if realm with given ID doesn't exist
     * @throws NomeRealmJaExisteException if new name already exists in another
     *                                    realm
     */
    @Override
    public RealmResponse atualizar(UUID id, AtualizarRealmRequest request) {
        String nomeNormalizado = request.nome().toLowerCase();

        // Buscar realm existente
        Realm realm = realmRepository.findById(id)
                .orElseThrow(() -> new RealmNotFoundException(id));

        // Verificar se o novo nome já existe em outro realm
        if (!realm.getNome().equalsIgnoreCase(nomeNormalizado)) {
            if (realmRepository.existsByNomeIgnoreCase(nomeNormalizado)) {
                throw new NomeRealmJaExisteException(nomeNormalizado);
            }
        }

        // Atualizar campos
        realm.setNome(nomeNormalizado);
        realm.setStatus(request.status());

        // Salvar no banco de dados
        Realm realmAtualizado = realmRepository.save(realm);

        // Registrar evento de auditoria
        auditoriaService.registrarEvento(
            TipoEventoAuditoria.ATUALIZACAO_REALM,
            String.format("Realm atualizado: %s (ID: %s)", nomeNormalizado, id),
            id
        );

        // Retornar response DTO
        return mapearParaResponse(realmAtualizado);
    }

    /**
     * Deactivates a realm (soft delete).
     *
     * @param id The UUID of realm to deactivate
     * @throws RealmNotFoundException  if realm not found
     * @throws RealmJaInativoException if realm is already inactive
     */
    @Override
    public void desativar(UUID id) {
        // Buscar realm existente
        Realm realm = realmRepository.findById(id)
                .orElseThrow(() -> new RealmNotFoundException(id));

        // Verificar se já está inativo
        if (StatusRealm.INATIVO.equals(realm.getStatus())) {
            throw new RealmJaInativoException(realm.getNome());
        }

        // TODO: Realm Master validation - implement in Epic 8
        // Atualmente não há campo para identificar Realm Master,
        // então não podemos validar se é Realm Master aqui.

        // Desativar realm (soft delete)
        realm.desativar();

        // Salvar no banco de dados
        realmRepository.save(realm);

        // Registrar evento de auditoria
        auditoriaService.registrarEvento(
            TipoEventoAuditoria.DESATIVACAO_REALM,
            String.format("Realm desativado: %s (ID: %s)", realm.getNome(), id),
            id
        );
    }

    /**
     * Reactivates a realm that was previously deactivated.
     *
     * @param id The UUID of realm to reactivate
     * @return The reactivated realm response
     * @throws RealmNotFoundException if realm not found
     * @throws RealmJaAtivoException  if realm is already active
     */
    @Override
    public RealmResponse reativar(UUID id) {
        // Buscar realm existente
        Realm realm = realmRepository.findById(id)
                .orElseThrow(() -> new RealmNotFoundException(id));

        // Verificar se já está ativo
        if (StatusRealm.ATIVO.equals(realm.getStatus())) {
            throw new RealmJaAtivoException(realm.getNome());
        }

        // Reativar realm
        realm.ativar();

        // Salvar no banco de dados
        Realm realmReativado = realmRepository.save(realm);

        // Registrar evento de auditoria
        auditoriaService.registrarEvento(
            TipoEventoAuditoria.REATIVACAO_REALM,
            String.format("Realm reativado: %s (ID: %s)", realmReativado.getNome(), id),
            id
        );

        // Retornar response DTO
        return mapearParaResponse(realmReativado);
    }

    /**
     * Lists realms with optional filtering and pagination.
     *
     * @param nome              Optional name filter (partial match,
     *                          case-insensitive)
     * @param status            Optional status filter
     * @param dataCriacaoInicio Optional creation date start filter
     * @param dataCriacaoFim    Optional creation date end filter
     * @param pageable          Pagination and sorting parameters
     * @return Page of realm responses
     */
    @Override
    @Transactional(readOnly = true)
    public Page<RealmResponse> listar(String nome, StatusRealm status, LocalDateTime dataCriacaoInicio,
            LocalDateTime dataCriacaoFim, Pageable pageable) {
        // Combinar especificações de filtro
        Specification<Realm> spec = Specification.where(RealmSpecification.comNome(nome))
                .and(RealmSpecification.comStatus(status))
                .and(RealmSpecification.comDataCriacaoEntre(dataCriacaoInicio, dataCriacaoFim));

        // Buscar realms com filtros e paginação
        Page<Realm> realms = realmRepository.findAll(spec, pageable);

        // Mapear para DTOs de resposta
        return realms.map(this::mapearParaResponse);
    }

    /**
     * Finds a realm by its ID.
     *
     * @param id The UUID of the realm to find
     * @return The realm response
     * @throws RealmNotFoundException if realm with given ID doesn't exist
     */
    @Override
    @Transactional(readOnly = true)
    public RealmResponse buscarPorId(UUID id) {
        // Buscar realm por ID
        Realm realm = realmRepository.findById(id)
                .orElseThrow(() -> new RealmNotFoundException(id));

        // Mapear para DTO de resposta
        return mapearParaResponse(realm);
    }

    /**
     * Maps a Realm entity to RealmResponse DTO.
     *
     * @param realm The realm entity
     * @return The realm response DTO
     */
    private RealmResponse mapearParaResponse(Realm realm) {
        return new RealmResponse(
                realm.getId(),
                realm.getNome(),
                realm.getStatus(),
                realm.getDataCriacao(),
                realm.getDataAtualizacao());
    }
}

```
```java
package br.com.plataforma.conexaodigital.realm.infrastructure.persistence;

import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import br.com.plataforma.conexaodigital.realm.domain.model.StatusRealm;
import org.springframework.data.jpa.domain.Specification;

import java.time.LocalDateTime;

public class RealmSpecification {

    public static Specification<Realm> comNome(String nome) {
        return (root, query, cb) ->
            nome == null ? null : cb.like(cb.lower(root.get("nome")), "%" + nome.toLowerCase() + "%");
    }

    public static Specification<Realm> comStatus(StatusRealm status) {
        return (root, query, cb) ->
            status == null ? null : cb.equal(root.get("status"), status);
    }

    public static Specification<Realm> comDataCriacaoEntre(LocalDateTime inicio, LocalDateTime fim) {
        return (root, query, cb) -> {
            if (inicio == null && fim == null) return null;
            if (inicio == null) return cb.lessThanOrEqualTo(root.get("dataCriacao"), fim);
            if (fim == null) return cb.greaterThanOrEqualTo(root.get("dataCriacao"), inicio);
            return cb.between(root.get("dataCriacao"), inicio, fim);
        };
    }
}
```
```java
package br.com.plataforma.conexaodigital.recuperacaoSenha.api.controller;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.plataforma.conexaodigital.recuperacaoSenha.api.dto.RecuperacaoSenhaResponse;
import br.com.plataforma.conexaodigital.recuperacaoSenha.api.dto.SolicitarRecuperacaoRequest;
import br.com.plataforma.conexaodigital.recuperacaoSenha.api.dto.ValidarSenhaRequest;
import br.com.plataforma.conexaodigital.recuperacaoSenha.domain.exception.CodigoExpiradoException;
import br.com.plataforma.conexaodigital.recuperacaoSenha.domain.exception.CodigoInvalidoException;
import br.com.plataforma.conexaodigital.recuperacaoSenha.domain.service.ResetSenhaService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Controller para endpoints de recuperação de senha.
 */
@RestController
@RequestMapping("/api/v1/auth/recuperar-senha")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Recuperação de Senha", description = "Endpoints para recuperação de senha por email")
public class ResetSenhaController {

    private final ResetSenhaService resetSenhaService;

    /**
     * Solicita envio de código de recuperação de senha por email.
     *
     * @param request Requisição contendo email
     * @return Resposta com mensagem de sucesso
     */
    @PostMapping("/solicitar")
    @Operation(summary = "Solicitar código de recuperação", description = """
            **Endpoint Público** - Envia um código de 6 dígitos por email para recuperação de senha.

            **Regras:**
            - Código expira em 30 minutos
            - Apenas um código ativo por email (anterior é invalidado)
            - Usuário deve estar ativo
            - Auditoria é registrada

            **Fluxo:**
            1. Usuário fornece email
            2. Sistema gera código de 6 dígitos
            3. Email é enviado com o código
            4. Usuário usa o código para definir nova senha
            """)
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Código enviado com sucesso", content = @Content(schema = @Schema(implementation = RecuperacaoSenhaResponse.class))),
            @ApiResponse(responseCode = "400", description = "Email inválido ou usuário inativo", content = @Content),
            @ApiResponse(responseCode = "404", description = "Usuário não encontrado", content = @Content)
    })
    public ResponseEntity<?> solicitarRecuperacao(@Valid @RequestBody SolicitarRecuperacaoRequest request) {
        log.debug("Solicitação de recuperação de senha para email: {}", request.getEmail());

        try {
            resetSenhaService.solicitarRecuperacao(request.getEmail());

            log.info("Código de recuperação de senha enviado para email: {}", request.getEmail());

            return ResponseEntity.ok(RecuperacaoSenhaResponse.builder()
                    .mensagem("Código de recuperação de senha enviado para o email: " + request.getEmail())
                    .build());

        } catch (CodigoInvalidoException e) {
            log.warn("Erro ao solicitar recuperação: {}", e.getMessage());
            return ResponseEntity.badRequest().body(RecuperacaoSenhaResponse.builder()
                    .mensagem(e.getMessage())
                    .build());

        } catch (Exception e) {
            log.error("Erro interno ao solicitar recuperação de senha", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    RecuperacaoSenhaResponse.builder()
                            .mensagem("Erro interno do servidor")
                            .build());
        }
    }

    /**
     * Valida o código e atualiza a senha do usuário.
     *
     * @param request Requisição contendo email, código e nova senha
     * @return Resposta com mensagem de sucesso
     */
    @PostMapping("/validar")
    @Operation(summary = "Validar código e atualizar senha", description = """
            **Endpoint Público** - Valida o código de 6 dígitos e atualiza a senha do usuário.

            **Regras:**
            - Código deve ter 6 dígitos
            - Código deve estar ativo (não usado)
            - Código não pode estar expirado (30 minutos)
            - Senha deve ter entre 8 e 100 caracteres
            - Auditoria é registrada

            **Após sucesso:**
            - Senha é atualizada
            - Token de recuperação é marcado como usado
            - Email de confirmação é enviado
            - Outros tokens do mesmo email são invalidados
            """)
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Senha atualizada com sucesso", content = @Content(schema = @Schema(implementation = RecuperacaoSenhaResponse.class))),
            @ApiResponse(responseCode = "400", description = "Código inválido, expirado ou dados inválidos", content = @Content),
            @ApiResponse(responseCode = "404", description = "Usuário não encontrado", content = @Content)
    })
    public ResponseEntity<?> validarECriarNovaSenha(@Valid @RequestBody ValidarSenhaRequest request) {
        log.debug("Validação de código e atualização de senha para email: {}", request.getEmail());

        try {
            resetSenhaService.validarECriarNovaSenha(request.getEmail(), request.getCodigo(), request.getNovaSenha());

            log.info("Senha atualizada com sucesso para email: {}", request.getEmail());

            return ResponseEntity.ok(RecuperacaoSenhaResponse.builder()
                    .mensagem("Senha atualizada com sucesso")
                    .build());

        } catch (CodigoInvalidoException e) {
            log.warn("Erro ao validar código: {}", e.getMessage());
            return ResponseEntity.badRequest().body(RecuperacaoSenhaResponse.builder()
                    .mensagem(e.getMessage())
                    .build());

        } catch (CodigoExpiradoException e) {
            log.warn("Código expirado: {}", e.getMessage());
            return ResponseEntity.badRequest().body(RecuperacaoSenhaResponse.builder()
                    .mensagem(e.getMessage())
                    .build());

        } catch (Exception e) {
            log.error("Erro interno ao atualizar senha", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    RecuperacaoSenhaResponse.builder()
                            .mensagem("Erro interno do servidor")
                            .build());
        }
    }
}

```
```java
package br.com.plataforma.conexaodigital.recuperacaoSenha.api.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO para resposta de recuperação de senha.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RecuperacaoSenhaResponse {

    /**
     * Mensagem de sucesso.
     */
    private String mensagem;
}

```
```java
package br.com.plataforma.conexaodigital.recuperacaoSenha.api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO para solicitação de recuperação de senha.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SolicitarRecuperacaoRequest {

    /**
     * Email do usuário.
     */
    @NotBlank(message = "Email é obrigatório")
    @Email(message = "Email inválido")
    private String email;
}

```
```java
package br.com.plataforma.conexaodigital.recuperacaoSenha.api.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO para validação de código e atualização de senha.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ValidarSenhaRequest {

    /**
     * Email do usuário.
     */
    @NotBlank(message = "Email é obrigatório")
    @Email(message = "Email inválido")
    private String email;

    /**
     * Código de 6 dígitos recebido por email.
     */
    @NotBlank(message = "Código é obrigatório")
    @Size(min = 6, max = 6, message = "Código deve ter 6 dígitos")
    private String codigo;

    /**
     * Nova senha.
     */
    @NotBlank(message = "Nova senha é obrigatória")
    @Size(min = 8, max = 100, message = "Senha deve ter entre 8 e 100 caracteres")
    private String novaSenha;
}

```
```java
package br.com.plataforma.conexaodigital.recuperacaoSenha.domain.exception;

/**
 * Exceção lançada quando o código de recuperação de senha expirou.
 */
public class CodigoExpiradoException extends RuntimeException {

    public CodigoExpiradoException(String message) {
        super(message);
    }
}

```
```java
package br.com.plataforma.conexaodigital.recuperacaoSenha.domain.exception;

/**
 * Exceção lançada quando o código de recuperação de senha é inválido.
 */
public class CodigoInvalidoException extends RuntimeException {

    public CodigoInvalidoException(String message) {
        super(message);
    }

    public CodigoInvalidoException(String message, Throwable cause) {
        super(message, cause);
    }
}

```
```java
package br.com.plataforma.conexaodigital.recuperacaoSenha.domain.model;

import java.time.LocalDateTime;
import java.util.UUID;

import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import br.com.plataforma.conexaodigital.recuperacaoSenha.domain.model.enums.StatusTokenRecuperacao;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Token de recuperação de senha com código de 6 dígitos.
 */
@Entity
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "tokens_recuperacao_senha")
@EntityListeners(AuditingEntityListener.class)
public class TokenRecuperacaoSenha {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(nullable = false, length = 255)
    private String email;

    @Column(nullable = false, length = 6)
    private String codigo;

    @Column(nullable = false)
    private LocalDateTime expiracao;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private StatusTokenRecuperacao status;

    @Column(nullable = false)
    @CreatedDate
    private LocalDateTime dataCriacao;

    @Column(nullable = false)
    private LocalDateTime dataUso;

    @Column(name = "realm_id", nullable = false)
    private UUID realmId;

    /**
     * Verifica se o token está expirado.
     */
    public boolean estaExpirado() {
        return LocalDateTime.now().isAfter(expiracao);
    }

    /**
     * Verifica se o token pode ser usado.
     */
    public boolean podeSerUsado() {
        return StatusTokenRecuperacao.ATIVO.equals(status) && !estaExpirado();
    }

    /**
     * Marca o token como usado.
     */
    public void marcarComoUsado() {
        this.status = StatusTokenRecuperacao.USADO;
        this.dataUso = LocalDateTime.now();
    }
}

```
```java
package br.com.plataforma.conexaodigital.recuperacaoSenha.domain.model.enums;

import lombok.AllArgsConstructor;
import lombok.Getter;

/**
 * Status do token de recuperação de senha.
 */
@Getter
@AllArgsConstructor
public enum StatusTokenRecuperacao {

    /**
     * Token gerado e não utilizado.
     */
    ATIVO("Ativo"),

    /**
     * Token já utilizado para reset de senha.
     */
    USADO("Usado"),

    /**
     * Token expirado.
     */
    EXPIRADO("Expirado");

    private final String descricao;
}

```
```java
package br.com.plataforma.conexaodigital.recuperacaoSenha.domain.repository;

import java.time.LocalDateTime;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import br.com.plataforma.conexaodigital.recuperacaoSenha.domain.model.TokenRecuperacaoSenha;
import br.com.plataforma.conexaodigital.recuperacaoSenha.domain.model.enums.StatusTokenRecuperacao;

/**
 * Repository para tokens de recuperação de senha.
 */
@Repository
public interface TokenRecuperacaoSenhaRepository extends JpaRepository<TokenRecuperacaoSenha, UUID> {

    /**
     * Busca um token ativo pelo email e código.
     */
    @Query("SELECT t FROM TokenRecuperacaoSenha t WHERE t.email = :email AND t.codigo = :codigo "
            + "AND t.status = :status AND t.expiracao > :agora")
    Optional<TokenRecuperacaoSenha> findByEmailAndCodigoAtivo(@Param("email") String email,
            @Param("codigo") String codigo, @Param("status") StatusTokenRecuperacao status,
            @Param("agora") LocalDateTime agora);

    /**
     * Marca todos os tokens expirados como EXPIRADO.
     */
    @Modifying
    @Query("UPDATE TokenRecuperacaoSenha t SET t.status = 'EXPIRADO' WHERE t.expiracao < :agora AND t.status = 'ATIVO'")
    int marcarTokensExpirados(@Param("agora") LocalDateTime agora);

    /**
     * Invalida tokens anteriores de um email (marca como EXPIRADO ao gerar novo token).
     */
    @Modifying
    @Query("UPDATE TokenRecuperacaoSenha t SET t.status = 'EXPIRADO' WHERE t.email = :email AND t.status = 'ATIVO'")
    int invalidarTokensAnteriores(@Param("email") String email);
}

```
```java
package br.com.plataforma.conexaodigital.recuperacaoSenha.domain.service;

import br.com.plataforma.conexaodigital.recuperacaoSenha.domain.exception.CodigoExpiradoException;
import br.com.plataforma.conexaodigital.recuperacaoSenha.domain.exception.CodigoInvalidoException;

/**
 * Serviço de recuperação de senha.
 */
public interface ResetSenhaService {

    /**
     * Solicita envio de código de recuperação de senha por email.
     *
     * @param email Email do usuário
     */
    void solicitarRecuperacao(String email);

    /**
     * Valida o código e atualiza a senha do usuário.
     *
     * @param email     Email do usuário
     * @param codigo    Código de 6 dígitos
     * @param novaSenha Nova senha
     * @throws CodigoInvalidoException  Se o código for inválido
     * @throws CodigoExpiradoException  Se o código estiver expirado
     */
    void validarECriarNovaSenha(String email, String codigo, String novaSenha);
}

```
```java
package br.com.plataforma.conexaodigital.recuperacaoSenha.domain.service.impl;

import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.plataforma.conexaodigital.auditoria.domain.model.enums.TipoEventoAuditoria;
import br.com.plataforma.conexaodigital.auditoria.domain.service.AuditoriaService;
import br.com.plataforma.conexaodigital.email.domain.service.EmailService;
import br.com.plataforma.conexaodigital.recuperacaoSenha.domain.exception.CodigoExpiradoException;
import br.com.plataforma.conexaodigital.recuperacaoSenha.domain.exception.CodigoInvalidoException;
import br.com.plataforma.conexaodigital.recuperacaoSenha.domain.model.TokenRecuperacaoSenha;
import br.com.plataforma.conexaodigital.recuperacaoSenha.domain.model.enums.StatusTokenRecuperacao;
import br.com.plataforma.conexaodigital.recuperacaoSenha.domain.repository.TokenRecuperacaoSenhaRepository;
import br.com.plataforma.conexaodigital.recuperacaoSenha.domain.service.ResetSenhaService;
import br.com.plataforma.conexaodigital.usuario.domain.model.Usuario;
import br.com.plataforma.conexaodigital.usuario.domain.model.enums.StatusUsuario;
import br.com.plataforma.conexaodigital.usuario.domain.repository.UsuarioRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Implementação do serviço de recuperação de senha.
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class ResetSenhaServiceImpl implements ResetSenhaService {

    private final TokenRecuperacaoSenhaRepository tokenRepository;
    private final UsuarioRepository usuarioRepository;
    private final EmailService emailService;
    private final PasswordEncoder passwordEncoder;
    private final AuditoriaService auditoriaService;

    private static final int TEMPO_EXPIRACAO_MINUTOS = 30;
    private static final int TAMANHO_CODIGO = 6;

    @Override
    @Transactional
    public void solicitarRecuperacao(String email) {
        log.info("Solicitação de recuperação de senha para email: {}", email);

        // Buscar usuário
        Usuario usuario = usuarioRepository.findByEmail(email)
                .orElseThrow(() -> {
                    log.warn("Usuário não encontrado: {}", email);
                    return new CodigoInvalidoException("Usuário não encontrado");
                });

        // Validar usuário ativo
        if (!StatusUsuario.ATIVO.equals(usuario.getStatus())) {
            log.warn("Usuário inativo: {}", email);
            throw new CodigoInvalidoException("Usuário inativo");
        }

        // Invalidar tokens anteriores
        tokenRepository.invalidarTokensAnteriores(email);

        // Gerar código de 6 dígitos
        String codigo = gerarCodigo6Digitos();

        // Criar token
        TokenRecuperacaoSenha token = TokenRecuperacaoSenha.builder()
                .email(email)
                .codigo(codigo)
                .expiracao(LocalDateTime.now().plusMinutes(TEMPO_EXPIRACAO_MINUTOS))
                .status(StatusTokenRecuperacao.ATIVO)
                .realmId(usuario.getRealmId())
                .build();

        tokenRepository.save(token);

        // Enviar email
        emailService.enviarEmailRecuperacaoSenha(email, codigo, usuario.getNome(),
                TEMPO_EXPIRACAO_MINUTOS);

        // Registrar auditoria
        Map<String, Object> detalhes = new HashMap<>();
        detalhes.put("email", email);
        detalhes.put("tipo", "recuperacao_senha_email");
        auditoriaService.registrarEvento(
                TipoEventoAuditoria.SOLICITACAO_RECUPERACAO_SENHA,
                "Solicitação de recuperação de senha para email: " + email,
                usuario.getId(),
                email,
                usuario.getRealmId(),
                detalhes);

        log.info("Código de recuperação de senha gerado para email: {}", email);
    }

    @Override
    @Transactional
    public void validarECriarNovaSenha(String email, String codigo, String novaSenha) {
        log.info("Validação de código e atualização de senha para email: {}", email);

        // Buscar usuário
        Usuario usuario = usuarioRepository.findByEmail(email)
                .orElseThrow(() -> {
                    log.warn("Usuário não encontrado: {}", email);
                    return new CodigoInvalidoException("Usuário não encontrado");
                });

        // Buscar token ativo
        TokenRecuperacaoSenha token = tokenRepository
                .findByEmailAndCodigoAtivo(email, codigo, StatusTokenRecuperacao.ATIVO, LocalDateTime.now())
                .orElseThrow(() -> {
                    log.warn("Código inválido ou expirado para email: {}", email);
                    return new CodigoInvalidoException("Código inválido ou expirado");
                });

        // Verificar expiração
        if (token.estaExpirado()) {
            log.warn("Código expirado para email: {}", email);
            token.setStatus(StatusTokenRecuperacao.EXPIRADO);
            tokenRepository.save(token);
            throw new CodigoExpiradoException("Código expirado");
        }

        // Validar código
        if (!token.getCodigo().equals(codigo)) {
            log.warn("Código inválido para email: {}", email);
            throw new CodigoInvalidoException("Código inválido");
        }

        // Atualizar senha
        usuario.setSenha(passwordEncoder.encode(novaSenha));
        usuario.setDataAtualizacao(LocalDateTime.now());
        usuarioRepository.save(usuario);

        // Marcar token como usado
        token.marcarComoUsado();
        tokenRepository.save(token);

        // Invalidar outros tokens do mesmo email
        tokenRepository.invalidarTokensAnteriores(email);

        // Registrar auditoria de sucesso
        Map<String, Object> detalhes = new HashMap<>();
        detalhes.put("email", email);
        detalhes.put("tipo", "recuperacao_senha_sucesso");
        auditoriaService.registrarEvento(
                TipoEventoAuditoria.REDEFINICAO_SENHA,
                "Senha atualizada com sucesso via recuperação para email: " + email,
                usuario.getId(),
                email,
                usuario.getRealmId(),
                detalhes);

        // Enviar email de confirmação
        emailService.enviarEmailConfirmacaoAlteracaoSenha(email, usuario.getNome(),
                LocalDateTime.now().toString());

        log.info("Senha atualizada com sucesso para email: {}", email);
    }

    /**
     * Gera um código numérico de 6 dígitos.
     */
    private String gerarCodigo6Digitos() {
        SecureRandom random = new SecureRandom();
        int codigo = 100_000 + random.nextInt(900_000);
        return String.valueOf(codigo);
    }
}

```
```java
package br.com.plataforma.conexaodigital.role.api.controller;

import java.util.List;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import br.com.plataforma.conexaodigital.role.api.requests.AtualizarRoleRequest;
import br.com.plataforma.conexaodigital.role.api.requests.CriarRoleRequest;
import br.com.plataforma.conexaodigital.role.api.responses.RoleResponse;
import br.com.plataforma.conexaodigital.role.domain.service.RoleService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;

/**
 * REST controller for managing roles.
 * Provides endpoints for creating and updating roles.
 */
@RestController
@RequestMapping("/api/v1/roles")
@Tag(name = "Gestão de Roles", description = "Operações de gestão de roles")
public class RoleController {

    private final RoleService roleService;

    /**
     * Constructor with dependency injection.
     *
     * @param roleService The role service
     */
    public RoleController(RoleService roleService) {
        this.roleService = roleService;
    }

    /**
     * Creates a new role in the specified realm.
     *
     * @param request The request containing role data
     * @return ResponseEntity with created role and HTTP status 201
     */
    @PostMapping
    @Operation(summary = "Criar role", description = "Cria uma nova role em um realm específico. O nome da role deve ser único dentro do realm.")
    @ApiResponses({
            @ApiResponse(responseCode = "201", description = "Role criada com sucesso", content = @Content(schema = @Schema(implementation = RoleResponse.class))),
            @ApiResponse(responseCode = "400", description = "Dados inválidos"),
            @ApiResponse(responseCode = "404", description = "Realm não encontrado"),
            @ApiResponse(responseCode = "409", description = "Nome de role já existe no realm")
    })
    public ResponseEntity<RoleResponse> criar(@Valid @RequestBody CriarRoleRequest request) {
        RoleResponse roleResponse = roleService.criar(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(roleResponse);
    }

    /**
     * Updates an existing role's description.
     * Only the description field can be updated; name and realm are immutable.
     *
     * @param id      The UUID of role to update
     * @param request The request containing the new description
     * @return ResponseEntity with the updated role and HTTP status 200
     */
    @PutMapping("/{id}")
    @Operation(summary = "Atualizar role", description = "Atualiza a descrição de uma role existente. Nome e realm são imutáveis e não podem ser alterados.")
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Role atualizada com sucesso", content = @Content(schema = @Schema(implementation = RoleResponse.class))),
            @ApiResponse(responseCode = "400", description = "Dados inválidos"),
            @ApiResponse(responseCode = "404", description = "Role não encontrada")
    })
    public ResponseEntity<RoleResponse> atualizar(
            @PathVariable UUID id,
            @Valid @RequestBody AtualizarRoleRequest request) {
        RoleResponse roleResponse = roleService.atualizar(id, request);
        return ResponseEntity.ok(roleResponse);
    }

    /**
     * Removes a role from the system.
     * The role cannot be removed if it has associated users or is a default role.
     *
     * @param id The UUID of role to remove
     * @return ResponseEntity with HTTP status 204 on success
     */
    @DeleteMapping("/{id}")
    @Operation(summary = "Remover role", description = "Remove uma role do sistema. Não é possível remover roles que possuem usuários associados ou roles padrão (ADMIN, USER, SERVICE).")
    @ApiResponses({
            @ApiResponse(responseCode = "204", description = "Role removida com sucesso"),
            @ApiResponse(responseCode = "400", description = "Role está em uso por usuários ou é uma role padrão"),
            @ApiResponse(responseCode = "404", description = "Role não encontrada")
    })
    public ResponseEntity<Void> remover(@PathVariable UUID id) {
        roleService.remover(id);
        return ResponseEntity.noContent().build();
    }

    /**
     * Gets a role by its ID.
     *
     * @param id The UUID of role to get
     * @return ResponseEntity with role details and HTTP status 200 on success
     */
    @GetMapping("/{id}")
    @Operation(summary = "Buscar role por ID", description = "Retorna os detalhes de uma role específica pelo seu ID.")
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Role encontrada", content = @Content(schema = @Schema(implementation = RoleResponse.class))),
            @ApiResponse(responseCode = "404", description = "Role não encontrada")
    })
    public ResponseEntity<RoleResponse> buscarPorId(@PathVariable UUID id) {
        RoleResponse roleResponse = roleService.buscarPorId(id);
        return ResponseEntity.ok(roleResponse);
    }

    /**
     * Lists roles with pagination and optional filters.
     * Supports filtering by realm ID, name (partial match, case-insensitive),
     * and default flag.
     *
     * @param realmId Filter by realm ID (optional)
     * @param nome Filter by name (partial, case-insensitive, optional)
     * @param padrao Filter by default flag (true=default only, false=non-default only, optional)
     * @param pageable Pagination parameters (default: page=0, size=20, sort=nome,asc)
     * @return ResponseEntity with paginated list of roles
     */
    @GetMapping(produces = "application/json")
    @Operation(summary = "Listar roles", description = "Lista roles com paginação e filtros opcionais por realm, nome (busca parcial) e flag de padrão.")
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Lista de roles retornada com sucesso")
    })
    public ResponseEntity<Page<RoleResponse>> listar(
            @RequestParam(required = false) UUID realmId,
            @RequestParam(required = false) String nome,
            @RequestParam(required = false) Boolean padrao,
            @PageableDefault(size = 20, sort = "nome") Pageable pageable) {

        // Validate page size limit (max 100 as per business rule)
        if (pageable.getPageSize() > 100) {
            throw new IllegalArgumentException("Tamanho da página não pode exceder 100 registros");
        }

        Page<RoleResponse> rolesPage = roleService.listar(realmId, nome, padrao, pageable);
        return ResponseEntity.ok(rolesPage);
    }

    /**
     * Lists all roles for a specific realm without pagination.
     *
     * @param realmId The ID of the realm
     * @return ResponseEntity with list of all roles in the realm
     */
    @GetMapping("/realms/{realmId}")
    @Operation(summary = "Listar roles por realm", description = "Lista todas as roles de um realm específico sem paginação.")
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Lista de roles do realm retornada com sucesso"),
            @ApiResponse(responseCode = "404", description = "Realm não encontrado")
    })
    public ResponseEntity<List<RoleResponse>> listarPorRealm(@PathVariable UUID realmId) {
        List<RoleResponse> roles = roleService.listarPorRealm(realmId);
        return ResponseEntity.ok(roles);
    }
}

```
```java
package br.com.plataforma.conexaodigital.role.api.requests;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Size;

/**
 * Request DTO for updating an existing Role.
 * Only allows updating the description, as name and realm are immutable.
 */
@Schema(description = "DTO de requisicao para atualizacao de uma Role existente")
public record AtualizarRoleRequest(

                @Size(max = 500, message = "Descricao deve ter no maximo 500 caracteres")
                @Schema(description = "Nova descricao da role (nao pode ser vazio se fornecido)", example = "Gerente senior de departamento")
                String descricao) {
}

```
```java
package br.com.plataforma.conexaodigital.role.api.requests;

import java.util.UUID;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

/**
 * Request DTO for creating a new Role.
 * Contains validation annotations to ensure data integrity.
 */
@Schema(description = "DTO de requisicao para criacao de uma nova Role")
public record CriarRoleRequest(

                @NotBlank(message = "Nome da role e obrigatorio")
                @Size(min = 3, max = 50, message = "Nome deve ter entre 3 e 50 caracteres")
                @Pattern(regexp = "^[A-Z][A-Z0-9_-]*$", message = "Nome deve comecar com letra maiuscula e conter apenas letras maiusculas, numeros, hifens e underscores")
                @Schema(description = "Nome unico da role dentro do realm (3-50 caracteres, letras maiusculas)", example = "GERENTE", required = true)
                String nome,

                @Size(max = 500, message = "Descricao deve ter no maximo 500 caracteres")
                @Schema(description = "Descricao opcional da role", example = "Gerente de departamento")
                String descricao,

                @NotNull(message = "Realm ID e obrigatorio")
                @Schema(description = "ID do realm onde a role sera criada", example = "550e8400-e29b-41d4-a716-4466554400000", required = true)
                UUID realmId) {
}

```
```java
package br.com.plataforma.conexaodigital.role.api.responses;

import java.time.LocalDateTime;
import java.util.UUID;

import io.swagger.v3.oas.annotations.media.Schema;

/**
 * Response DTO for Role data.
 * Represents a role with all its fields including realm information.
 */
@Schema(description = "DTO de resposta para dados de Role")
public record RoleResponse(

        @Schema(description = "Identificador único da role (UUID)", example = "550e8400-e29b-41d4-a716-446655440000")
        UUID id,

        @Schema(description = "Nome da role", example = "GERENTE")
        String nome,

        @Schema(description = "Descrição da role", example = "Gerente de departamento")
        String descricao,

        @Schema(description = "ID do realm ao qual a role pertence", example = "550e8400-e29b-41d4-a716-446655440000")
        UUID realmId,

        @Schema(description = "Nome do realm ao qual a role pertence", example = "empresa-a")
        String realmNome,

        @Schema(description = "Indica se é uma role padrão do sistema", example = "false")
        boolean padrao,

        @Schema(description = "Data de criação da role", example = "2024-01-15T10:30:00")
        LocalDateTime dataCriacao,

        @Schema(description = "Data da última atualização da role", example = "2024-01-15T10:30:00")
        LocalDateTime dataAtualizacao) {
}

```
```java
package br.com.plataforma.conexaodigital.role.domain.exception;

/**
 * Exceção lançada quando uma role possui usuários associados e não pode ser removida.
 */
public class RoleEmUsoException extends RuntimeException {
    public RoleEmUsoException(String message) {
        super(message);
    }
}

```
```java
package br.com.plataforma.conexaodigital.role.domain.exception;

/**
 * Exceção lançada quando já existe uma role com o mesmo nome no realm.
 */
public class RoleJaExisteException extends RuntimeException {
    public RoleJaExisteException(String message) {
        super(message);
    }
}

```
```java
package br.com.plataforma.conexaodigital.role.domain.exception;

/**
 * Exceção lançada quando uma role não é encontrada pelo ID.
 */
public class RoleNaoEncontradaException extends RuntimeException {
    public RoleNaoEncontradaException(String message) {
        super(message);
    }
}

```
```java
package br.com.plataforma.conexaodigital.role.domain.exception;

/**
 * Exceção lançada quando se tenta remover uma role padrão.
 */
public class RolePadraoNaoPodeRemoverException extends RuntimeException {
    public RolePadraoNaoPodeRemoverException(String message) {
        super(message);
    }
}

```
```java
package br.com.plataforma.conexaodigital.role.domain.exceptions;

import java.util.UUID;

import br.com.plataforma.conexaodigital.shared.exceptions.BusinessException;

/**
 * Exception thrown when attempting to create or update a role
 * with a name that already exists in the same realm.
 */
public class NomeRoleJaExisteException extends BusinessException {

    /**
     * Constructs a new NomeRoleJaExisteException with the specified role name and realm ID.
     *
     * @param nome    The name of the role that already exists
     * @param realmId The ID of the realm where the conflict exists
     */
    public NomeRoleJaExisteException(String nome, UUID realmId) {
        super(String.format("Nome de role '%s' já existe no realm com ID %s", nome, realmId));
    }
}

```
```java
package br.com.plataforma.conexaodigital.role.domain.exceptions;

import br.com.plataforma.conexaodigital.shared.exceptions.BusinessException;

/**
 * Exception thrown when attempting to remove a role that is in use.
 * A role cannot be removed if it has associated users.
 */
public class RoleEmUsoException extends BusinessException {

    /**
     * Constructs a new RoleEmUsoException with the specified role ID.
     *
     * @param id The ID of the role that is in use
     */
    public RoleEmUsoException(String id) {
        super(String.format("Role não pode ser removida pois está em uso por usuários: %s", id));
    }
}

```
```java
package br.com.plataforma.conexaodigital.role.domain.exceptions;

import java.util.UUID;

import br.com.plataforma.conexaodigital.shared.exceptions.BusinessException;

/**
 * Exception thrown when a role with the given ID cannot be found.
 */
public class RoleNotFoundException extends BusinessException {

    /**
     * Constructs a new RoleNotFoundException with the specified role ID.
     *
     * @param id The ID of the role that was not found
     */
    public RoleNotFoundException(UUID id) {
        super(String.format("Role não encontrada com ID: %s", id));
    }
}

```
```java
package br.com.plataforma.conexaodigital.role.domain.exceptions;

import br.com.plataforma.conexaodigital.shared.exceptions.BusinessException;

/**
 * Exception thrown when attempting to remove a default role.
 * Default roles (ADMIN, USER, SERVICE) cannot be removed from the system.
 */
public class RolePadraoNaoPodeSerRemovidaException extends BusinessException {

    /**
     * Constructs a new RolePadraoNaoPodeSerRemovidaException.
     */
    public RolePadraoNaoPodeSerRemovidaException() {
        super("Roles padrão (ADMIN, USER, SERVICE) não podem ser removidas");
    }
}

```
```java
package br.com.plataforma.conexaodigital.role.domain.model;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import jakarta.persistence.Version;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
import lombok.Builder;

import br.com.plataforma.conexaodigital.realm.domain.model.Realm;
import br.com.plataforma.conexaodigital.usuario.domain.model.Usuario;

/**
 * Represents a Role in authorization server.
 * A Role defines a set of permissions for users within a specific realm.
 */
@Entity
@Table(name = "roles")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Role {

    @Id
    @Column(name = "id", updatable = false, nullable = false)
    private UUID id;

    @NotBlank(message = "Nome da role é obrigatório")
    @Size(min = 3, max = 50, message = "Nome deve ter entre 3 e 50 caracteres")
    @Column(name = "nome", nullable = false, length = 50)
    private String nome;

    @Size(max = 500, message = "Descrição deve ter no máximo 500 caracteres")
    @Column(name = "descricao", length = 500)
    private String descricao;

    @NotNull(message = "Realm da role é obrigatório")
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "realm_id", nullable = false, updatable = false)
    private Realm realm;

    @Column(name = "padrao", nullable = false)
    private boolean padrao;

    @Column(name = "data_criacao", updatable = false, nullable = false)
    private LocalDateTime dataCriacao;

    @Column(name = "data_atualizacao", nullable = false)
    private LocalDateTime dataAtualizacao;

    @Version
    @Column(name = "versao")
    private Long versao;

    @ManyToMany(mappedBy = "roles", fetch = FetchType.LAZY)
    @Builder.Default
    private Set<Usuario> usuarios = new HashSet<>();

    /**
     * Creates a new Role with the specified name and realm.
     *
     * @param nome     The unique name of the role within the realm
     * @param descricao The description of the role (optional)
     * @param realm    The realm this role belongs to
     * @param padrao   Whether this is a default role
     */
    public Role(String nome, String descricao, Realm realm, boolean padrao) {
        this.id = UUID.randomUUID();
        this.nome = nome;
        this.descricao = descricao;
        this.realm = realm;
        this.padrao = padrao;
        this.dataCriacao = LocalDateTime.now();
        this.dataAtualizacao = LocalDateTime.now();
        this.versao = 0L;
    }

    // Getters

    public UUID getId() {
        return id;
    }

    public String getNome() {
        return nome;
    }

    public String getDescricao() {
        return descricao;
    }

    public Realm getRealm() {
        return realm;
    }

    public boolean isPadrao() {
        return padrao;
    }

    public LocalDateTime getDataCriacao() {
        return dataCriacao;
    }

    public LocalDateTime getDataAtualizacao() {
        return dataAtualizacao;
    }

    public Long getVersao() {
        return versao;
    }

    // Setters (only for business logic use)

    public void setId(UUID id) {
        this.id = id;
    }

    public void setNome(String nome) {
        this.nome = nome;
        this.dataAtualizacao = LocalDateTime.now();
    }

    public void setDescricao(String descricao) {
        this.descricao = descricao;
        this.dataAtualizacao = LocalDateTime.now();
    }

    public void setRealm(Realm realm) {
        this.realm = realm;
        this.dataAtualizacao = LocalDateTime.now();
    }

    public void setPadrao(boolean padrao) {
        this.padrao = padrao;
        this.dataAtualizacao = LocalDateTime.now();
    }

    public void setDataCriacao(LocalDateTime dataCriacao) {
        this.dataCriacao = dataCriacao;
    }

    public void setDataAtualizacao(LocalDateTime dataAtualizacao) {
        this.dataAtualizacao = dataAtualizacao;
    }

    public void setVersao(Long versao) {
        this.versao = versao;
    }

    /**
     * Marks the role as updated with the current timestamp.
     */
    public void markAsUpdated() {
        this.dataAtualizacao = LocalDateTime.now();
    }

    /**
     * Updates the description of this role.
     *
     * @param descricao The new description
     */
    public void atualizarDescricao(String descricao) {
        this.descricao = descricao;
        this.dataAtualizacao = LocalDateTime.now();
    }

    /**
     * Checks if this is a default role.
     *
     * @return true if this is a default role
     */
    public boolean ePadrao() {
        return this.padrao;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Role role = (Role) o;
        return id != null && id.equals(role.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }

    @Override
    public String toString() {
        return "Role{" +
                "id=" + id +
                ", nome='" + nome + '\'' +
                ", descricao='" + descricao + '\'' +
                ", realm=" + (realm != null ? realm.getId() : "null") +
                ", padrao=" + padrao +
                ", dataCriacao=" + dataCriacao +
                ", dataAtualizacao=" + dataAtualizacao +
                ", versao=" + versao +
                '}';
    }
}

```
```java
package br.com.plataforma.conexaodigital.role.domain.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import br.com.plataforma.conexaodigital.role.domain.model.Role;

/**
 * Repository interface for Role entities.
 * Provides CRUD operations and custom queries.
 */
public interface RoleRepository extends JpaRepository<Role, UUID>, JpaSpecificationExecutor<Role> {

  /**
   * Checks if a role with the given name exists in the specified realm.
   *
   * @param nome    The name of the role
   * @param realmId The ID of the realm
   * @return true if a role exists, false otherwise
   */
  boolean existsByNomeAndRealmId(String nome, UUID realmId);

  /**
   * Finds a role by name and realm ID.
   *
   * @param nome    The name of the role
   * @param realmId The ID of the realm
   * @return Optional containing the role if found
   */
  Optional<Role> findByNomeAndRealmId(String nome, UUID realmId);

  /**
   * Finds roles by realm ID with pagination.
   *
   * @param realmId  The ID of the realm
   * @param pageable Pagination parameters
   * @return Page of roles in the realm
   */
  Page<Role> findByRealmId(UUID realmId, Pageable pageable);

  /**
   * Finds all roles by realm ID without pagination.
   *
   * @param realmId The ID of the realm
   * @return List of roles in the realm
   */
  java.util.List<Role> findAllByRealmId(UUID realmId);

  /**
   * Checks if a role exists by its ID.
   *
   * @param id The ID of the role
   * @return true if role exists, false otherwise
   */
  boolean existsById(UUID id);

  /**
   * Counts users associated with a role.
   *
   * @param roleId The ID of the role
   * @return Number of users with this role
   */
  @Query("SELECT COUNT(u) FROM br.com.plataforma.conexaodigital.usuario.domain.model.Usuario u JOIN u.roles r WHERE r.id = :roleId")
  Long countUsuariosByRole(@Param("roleId") UUID roleId);

  /**
   * Finds user names associated with a role.
   *
   * @param roleId The ID of the role
   * @return List of user names with this role
   */
  @Query("SELECT u.nome FROM br.com.plataforma.conexaodigital.usuario.domain.model.Usuario u JOIN u.roles r WHERE r.id = :roleId")
  java.util.List<String> findUsuariosNomesByRole(@Param("roleId") UUID roleId);

  /**
   * Searches roles with filters (name, realm).
   *
   * @param nome     Optional name filter
   * @param realmId  Optional realm ID filter
   * @param pageable Pagination parameters
   * @return Page of filtered roles
   */
  @Query("SELECT r FROM br.com.plataforma.conexaodigital.role.domain.model.Role r WHERE " +
      "(:nome IS NULL OR LOWER(r.nome) LIKE LOWER(CONCAT('%', :nome, '%'))) AND " +
      "(:realmId IS NULL OR :realmId = 'All' OR r.realm.id = CAST(:realmId AS org.hibernate.type.UUIDBinaryType))")
  Page<Role> buscarComFiltros(
      @Param("nome") String nome,
      @Param("realmId") String realmId,
      Pageable pageable);

  /**
   * Checks if role exists by name in realm excluding specific ID.
   *
   * @param nome    Role name
   * @param realmId Realm ID
   * @param id      Role ID to exclude
   * @return true if role exists, false otherwise
   */
  boolean existsByNomeAndRealm_IdAndIdNot(String nome, UUID realmId, UUID id);

}

```
```java
package br.com.plataforma.conexaodigital.role.domain.service;

import java.util.List;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import br.com.plataforma.conexaodigital.role.api.requests.AtualizarRoleRequest;
import br.com.plataforma.conexaodigital.role.api.requests.CriarRoleRequest;
import br.com.plataforma.conexaodigital.role.api.responses.RoleResponse;

/**
 * Service interface for Role domain operations.
 * Provides business logic for managing roles.
 */
public interface RoleService {

    /**
     * Creates a new role in the specified realm.
     *
     * @param request The request containing role data
     * @return The created role response
     * @throws br.com.plataforma.conexaodigital.role.domain.exceptions.NomeRoleJaExisteException if
     *                                                                                           role
     *                                                                                           name
     *                                                                                           already
     *                                                                                           exists
     *                                                                                           in
     *                                                                                           the
     *                                                                                           realm
     * @throws br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmNotFoundException   if
     *                                                                                           realm
     *                                                                                           doesn't
     *                                                                                           exist
     */
    RoleResponse criar(CriarRoleRequest request);

    /**
     * Updates an existing role's description.
     * Only the description field can be updated; name and realm are immutable.
     *
     * @param id      The ID of the role to update
     * @param request The request containing the new description
     * @return The updated role response
     * @throws br.com.plataforma.conexaodigital.role.domain.exceptions.RoleNotFoundException if
     *                                                                                       role
     *                                                                                       doesn't
     *                                                                                       exist
     */
    RoleResponse atualizar(UUID id, AtualizarRoleRequest request);

    /**
     * Removes a role from the system.
     * The role cannot be removed if it has associated users or is a default role.
     *
     * @param id The ID of the role to remove
     * @throws br.com.plataforma.conexaodigital.role.domain.exceptions.RoleNotFoundException                 if
     *                                                                                                       role
     *                                                                                                       doesn't
     *                                                                                                       exist
     * @throws br.com.plataforma.conexaodigital.role.domain.exceptions.RoleEmUsoException                    if
     *                                                                                                       role
     *                                                                                                       has
     *                                                                                                       associated
     *                                                                                                       users
     * @throws br.com.plataforma.conexaodigital.role.domain.exceptions.RolePadraoNaoPodeSerRemovidaException if
     *                                                                                                       role
     *                                                                                                       is
     *                                                                                                       a
     *                                                                                                       default
     *                                                                                                       role
     */
    void remover(UUID id);

    /**
     * Lists roles with pagination and optional filters.
     *
     * @param realmId  Filter by realm ID (optional)
     * @param nome     Filter by name (partial, case-insensitive)
     * @param padrao   Filter by default flag (true=default only, false=non-default
     *                 only)
     * @param pageable Pagination parameters
     * @return Page with filtered role results
     */
    Page<RoleResponse> listar(UUID realmId, String nome, Boolean padrao, Pageable pageable);

    /**
     * Lists all roles for a specific realm without pagination.
     *
     * @param realmId The ID of the realm
     * @return List of roles in the realm
     */
    List<RoleResponse> listarPorRealm(UUID realmId);

    /**
     * Gets a role by its ID.
     *
     * @param id The ID of the role
     * @return The role response
     * @throws br.com.plataforma.conexaodigital.role.domain.exceptions.RoleNotFoundException if
     *                                                                                       role
     *                                                                                       doesn't
     *                                                                                       exist
     */
    RoleResponse buscarPorId(UUID id);
}

```
```java
package br.com.plataforma.conexaodigital.role.domain.service.impl;

import java.util.List;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.plataforma.conexaodigital.auditoria.domain.model.enums.TipoEventoAuditoria;
import br.com.plataforma.conexaodigital.auditoria.domain.service.AuditoriaService;
import br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmNotFoundException;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import br.com.plataforma.conexaodigital.role.api.requests.AtualizarRoleRequest;
import br.com.plataforma.conexaodigital.role.api.requests.CriarRoleRequest;
import br.com.plataforma.conexaodigital.role.api.responses.RoleResponse;
import br.com.plataforma.conexaodigital.role.domain.exceptions.NomeRoleJaExisteException;
import br.com.plataforma.conexaodigital.role.domain.exceptions.RoleNotFoundException;
import br.com.plataforma.conexaodigital.role.domain.exceptions.RolePadraoNaoPodeSerRemovidaException;
import br.com.plataforma.conexaodigital.role.domain.model.Role;
import br.com.plataforma.conexaodigital.role.domain.repository.RoleRepository;
import br.com.plataforma.conexaodigital.role.domain.service.RoleService;
import br.com.plataforma.conexaodigital.role.infrastructure.persistence.RoleSpecification;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Implementation of RoleService interface.
 * Provides business logic for managing roles.
 */
@Service
@Slf4j
@RequiredArgsConstructor
public class RoleServiceImpl implements RoleService {

    // Default roles that cannot be removed
    private static final List<String> ROLES_PADRAO = List.of("ADMIN", "USER", "SERVICE");

    private final RoleRepository roleRepository;
    private final RealmRepository realmRepository;
    private final AuditoriaService auditoriaService;

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional
    public RoleResponse criar(CriarRoleRequest request) {
        // Validate realm exists
        var realm = realmRepository.findById(request.realmId())
                .orElseThrow(() -> new RealmNotFoundException(request.realmId()));

        // Validate unique role name within realm
        if (roleRepository.existsByNomeAndRealmId(request.nome(), request.realmId())) {
            throw new NomeRoleJaExisteException(request.nome(), request.realmId());
        }

        // Create and save the role
        Role role = new Role(
                request.nome(),
                request.descricao(),
                realm,
                false);

        Role savedRole = roleRepository.save(role);

        // Registrar evento de auditoria
        auditoriaService.registrarEvento(
                TipoEventoAuditoria.CRIACAO_ROLE,
                String.format("Role criada: %s (ID: %s)", savedRole.getNome(), savedRole.getId()),
                null,
                null,
                savedRole.getRealm().getId(),
                null);

        return toResponse(savedRole);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional
    public RoleResponse atualizar(UUID id, AtualizarRoleRequest request) {
        // Find role by ID
        Role role = roleRepository.findById(id)
                .orElseThrow(() -> new RoleNotFoundException(id));

        // Update description (name and realm are immutable)
        role.atualizarDescricao(request.descricao());

        Role savedRole = roleRepository.save(role);

        // Registrar evento de auditoria
        auditoriaService.registrarEvento(
                TipoEventoAuditoria.ATUALIZACAO_ROLE,
                String.format("Role atualizada: %s (ID: %s)", savedRole.getNome(), id),
                null,
                null,
                savedRole.getRealm().getId(),
                null);

        return toResponse(savedRole);
    }

    /**
     * Converts a Role entity to RoleResponse DTO.
     *
     * @param role The role entity
     * @return The role response DTO
     */
    private RoleResponse toResponse(Role role) {
        return new RoleResponse(
                role.getId(),
                role.getNome(),
                role.getDescricao(),
                role.getRealm().getId(),
                role.getRealm().getNome(),
                role.isPadrao(),
                role.getDataCriacao(),
                role.getDataAtualizacao());
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional
    public void remover(UUID id) {
        // Find role by ID
        Role role = roleRepository.findById(id)
                .orElseThrow(() -> new RoleNotFoundException(id));

        // Check if role has associated users
        // TODO: Uncomment when user-role relationship is implemented
        // if (roleRepository.existsByIdAndUsuariosNotEmpty(id)) {
        // throw new RoleEmUsoException(id);
        // }

        // Check if role is a default role (ADMIN, USER, SERVICE)
        if (ROLES_PADRAO.contains(role.getNome())) {
            throw new RolePadraoNaoPodeSerRemovidaException();
        }

        // Remove the role
        roleRepository.delete(role);

        // Registrar evento de auditoria
        auditoriaService.registrarEvento(
                TipoEventoAuditoria.EXCLUSAO_ROLE,
                String.format("Role removida: %s (ID: %s)", role.getNome(), id),
                null,
                null,
                role.getRealm().getId(),
                null);

        log.info("Role removida com sucesso: ID={}, Nome={}", id, role.getNome());
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional
    public Page<RoleResponse> listar(UUID realmId, String nome, Boolean padrao, Pageable pageable) {
        // Build specifications dynamically
        Specification<Role> spec = RoleSpecification.comFiltros(
                RoleSpecification.comRealmId(realmId),
                RoleSpecification.comNome(nome),
                RoleSpecification.comPadrao(padrao));

        // Execute paginated search
        Page<Role> roles = roleRepository.findAll(spec, pageable);

        // Map to RoleResponse
        return roles.map(this::toResponse);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional(readOnly = true)
    public List<RoleResponse> listarPorRealm(UUID realmId) {
        // Validate realm exists
        if (!realmRepository.existsById(realmId)) {
            throw new RealmNotFoundException(realmId);
        }

        // Find all roles for the realm
        List<Role> roles = roleRepository.findAllByRealmId(realmId);

        // Map to RoleResponse
        return roles.stream()
                .map(this::toResponse)
                .toList();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Transactional(readOnly = true)
    public RoleResponse buscarPorId(UUID id) {
        // Find role by ID or throw if not found
        Role role = roleRepository.findById(id)
                .orElseThrow(() -> new RoleNotFoundException(id));

        return toResponse(role);
    }
}

```
```java
package br.com.plataforma.conexaodigital.role.infrastructure.persistence;

import org.springframework.data.jpa.domain.Specification;

import br.com.plataforma.conexaodigital.role.domain.model.Role;

import java.util.UUID;

/**
 * JPA Specification for Role entity queries.
 * Provides reusable specifications for complex filtering operations.
 */
public class RoleSpecification {

    /**
     * Creates a specification to filter roles by realm ID.
     *
     * @param realmId the realm ID to filter
     * @return Specification for filtering by realm ID
     */
    public static Specification<Role> comRealmId(UUID realmId) {
        return (root, query, cb) ->
            realmId == null ? null : cb.equal(root.get("realm").get("id"), realmId);
    }

    /**
     * Creates a specification to filter roles by name (case-insensitive partial match).
     *
     * @param nome the name to filter (partial match, case-insensitive)
     * @return Specification for filtering by name
     */
    public static Specification<Role> comNome(String nome) {
        return (root, query, cb) ->
            nome == null ? null : cb.like(cb.lower(root.get("nome")), "%" + nome.toLowerCase() + "%");
    }

    /**
     * Creates a specification to filter roles by default flag.
     *
     * @param padrao the padrao flag to filter (true=default roles only, false=non-default roles only)
     * @return Specification for filtering by padrao flag
     */
    public static Specification<Role> comPadrao(Boolean padrao) {
        return (root, query, cb) ->
            padrao == null ? null : cb.equal(root.get("padrao"), padrao);
    }

    /**
     * Creates a specification to combine multiple filters using AND logic.
     *
     * @param specifications list of specifications to combine with AND
     * @return combined Specification
     */
    @SafeVarargs
    public static Specification<Role> comFiltros(Specification<Role>... specifications) {
        return (root, query, cb) -> {
            jakarta.persistence.criteria.Predicate[] predicates = java.util.Arrays.stream(specifications)
                    .map(spec -> spec.toPredicate(root, query, cb))
                    .filter(predicate -> predicate != null)
                    .toArray(jakarta.persistence.criteria.Predicate[]::new);

            return predicates.length > 0 ? cb.and(predicates) : cb.conjunction();
        };
    }
}

```
```java
package br.com.plataforma.conexaodigital.shared.domain;

import jakarta.persistence.Column;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.MappedSuperclass;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Base entity class with common audit fields.
 * All entities in the system should extend this class to inherit
 * automatic timestamp and user auditing capabilities.
 */
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @CreatedDate
    @Column(name = "data_criacao", nullable = false, updatable = false)
    private LocalDateTime dataCriacao;

    @LastModifiedDate
    @Column(name = "data_atualizacao")
    private LocalDateTime dataAtualizacao;

    @CreatedBy
    @Column(name = "criado_por", length = 255)
    private String criadoPor;

    /**
     * Default constructor required by JPA.
     */
    protected BaseEntity() {
    }

    // Getters

    public UUID getId() {
        return id;
    }

    public LocalDateTime getDataCriacao() {
        return dataCriacao;
    }

    public LocalDateTime getDataAtualizacao() {
        return dataAtualizacao;
    }

    public String getCriadoPor() {
        return criadoPor;
    }

    // Setters (only for JPA/Hibernate use)

    public void setId(UUID id) {
        this.id = id;
    }

    public void setDataCriacao(LocalDateTime dataCriacao) {
        this.dataCriacao = dataCriacao;
    }

    public void setDataAtualizacao(LocalDateTime dataAtualizacao) {
        this.dataAtualizacao = dataAtualizacao;
    }

    public void setCriadoPor(String criadoPor) {
        this.criadoPor = criadoPor;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        BaseEntity that = (BaseEntity) o;
        return id != null && id.equals(that.id);
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }

    @Override
    public String toString() {
        return getClass().getSimpleName() + "{" +
                "id=" + id +
                ", dataCriacao=" + dataCriacao +
                ", dataAtualizacao=" + dataAtualizacao +
                ", criadoPor='" + criadoPor + '\'' +
                '}';
    }
}
```
```java
package br.com.plataforma.conexaodigital.shared.email;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Component;

/**
 * Email service for sending password recovery codes.
 * Uses JavaMail to send real emails.
 */
@Component
public class EmailService {

    private static final Logger logger = LoggerFactory.getLogger(EmailService.class);

    private final JavaMailSender mailSender;

    @Value("${spring.mail.username:}")
    private String fromEmail;

    @Value("${spring.mail.properties.mail.smtp.from:noreply@conexaoauth.local}")
    private String defaultFromEmail;

    public EmailService(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    /**
     * Sends a password recovery code to the user's email.
     *
     * @param email the recipient's email address
     * @param codigo the 6-digit recovery code
     */
    public void enviarCodigoRecuperacaoSenha(String email, String codigo) {
        try {
            SimpleMailMessage message = new SimpleMailMessage();

            // Usar o email configurado ou o padrão
            String fromAddress = (fromEmail != null && !fromEmail.isEmpty()) ? fromEmail : defaultFromEmail;
            message.setFrom(fromAddress);
            message.setTo(email);
            message.setSubject("Recuperação de Senha - ConexaoAuth");
            message.setText(buildEmailBody(codigo));

            mailSender.send(message);

            logger.info("Código de recuperação enviado com sucesso para: {} (de: {})", email, fromAddress);
        } catch (Exception e) {
            logger.error("Erro ao enviar email de recuperação de senha para: {}", email, e);
            throw new RuntimeException("Falha ao enviar email de recuperação de senha", e);
        }
    }

    private String buildEmailBody(String codigo) {
        return String.format(
            "Olá,\n\n" +
            "Você solicitou a recuperação de senha da sua conta.\n" +
            "Use o código abaixo para redefinir sua senha:\n\n" +
            "CÓDIGO: %s\n\n" +
            "Este código é válido por 30 minutos.\n" +
            "Se você não solicitou esta recuperação, ignore este e-mail.\n\n" +
            "Atenciosamente,\n" +
            "Equipe ConexaoAuth",
            codigo
        );
    }
}

```
```java
package br.com.plataforma.conexaodigital.shared.exceptions;

/**
 * Base exception class for application business exceptions.
 */
public abstract class BusinessException extends RuntimeException {

    /**
     * Constructs a new BusinessException with the specified detail message.
     *
     * @param message The detail message
     */
    protected BusinessException(String message) {
        super(message);
    }

    /**
     * Constructs a new BusinessException with the specified detail message and
     * cause.
     *
     * @param message The detail message
     * @param cause   The cause of the exception
     */
    protected BusinessException(String message, Throwable cause) {
        super(message, cause);
    }
}

```
```java
package br.com.plataforma.conexaodigital.shared.exceptions;

/**
 * Exception thrown when an entity is not found.
 * Used for common "not found" scenarios across the application.
 */
public class EntityNotFoundException extends RuntimeException {

    /**
     * Constructs a new EntityNotFoundException with the specified detail message.
     *
     * @param message The detail message
     */
    public EntityNotFoundException(String message) {
        super(message);
    }

    /**
     * Constructs a new EntityNotFoundException with entity type and id.
     *
     * @param entity The entity type name
     * @param id The entity id
     */
    public EntityNotFoundException(String entity, String id) {
        super(String.format("%s não encontrado com id: %s", entity, id));
    }

    /**
     * Constructs a new EntityNotFoundException with entity type and id.
     *
     * @param entity The entity type name
     * @param id The entity id
     */
    public EntityNotFoundException(String entity, Long id) {
        super(String.format("%s não encontrado com id: %d", entity, id));
    }
}

```
```java
 package br.com.plataforma.conexaodigital.shared.exceptions;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

import jakarta.persistence.EntityNotFoundException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.ConstraintViolationException;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.AuthenticationException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

/**
 * Global exception handler for application.
 * Catches and handles exceptions in a centralized manner, returning consistent
 * error responses with proper HTTP status codes and messages in Portuguese.
 */
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    private final HttpServletRequest request;

    /**
     * Constructor with HttpServletRequest injection.
     *
     * @param request the HTTP request
     */
    public GlobalExceptionHandler(HttpServletRequest request) {
        this.request = request;
    }

    /**
     * Handles validation errors from @Valid annotations.
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleMethodArgumentNotValid(MethodArgumentNotValidException ex) {
        List<String> errors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .map(fieldError -> fieldError.getField() + ": " + fieldError.getDefaultMessage())
                .collect(Collectors.toList());

        ErrorResponse errorResponse = new ErrorResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Erro de validação",
                errors,
                LocalDateTime.now(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }

    /**
     * Handles ConstraintViolationException.
     */
    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity<ErrorResponse> handleConstraintViolation(ConstraintViolationException ex) {
        List<String> errors = ex.getConstraintViolations()
                .stream()
                .map(ConstraintViolation::getMessage)
                .collect(Collectors.toList());

        ErrorResponse errorResponse = new ErrorResponse(
                HttpStatus.BAD_REQUEST.value(),
                "Erro de validação",
                errors,
                LocalDateTime.now(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }

    /**
     * Handles EntityNotFoundException.
     */
    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleEntityNotFound(EntityNotFoundException ex) {
        ErrorResponse errorResponse = new ErrorResponse(
                HttpStatus.NOT_FOUND.value(),
                "Recurso não encontrado",
                List.of(ex.getMessage()),
                LocalDateTime.now(),
                request.getRequestURI()
        );

        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
    }

        /**
         * Handles NomeRealmJaExisteException.
         */
        @ExceptionHandler(br.com.plataforma.conexaodigital.realm.domain.exceptions.NomeRealmJaExisteException.class)
        public ResponseEntity<ErrorResponse> handleNomeRealmJaExisteException(
                br.com.plataforma.conexaodigital.realm.domain.exceptions.NomeRealmJaExisteException ex) {

            ErrorResponse errorResponse = new ErrorResponse(
                    HttpStatus.CONFLICT.value(),
                    "Conflito de dados",
                    List.of(ex.getMessage()),
                    LocalDateTime.now(),
                    request.getRequestURI()
            );

            return ResponseEntity.status(HttpStatus.CONFLICT).body(errorResponse);
        }

        /**
         * Handles RealmJaInativoException.
         */
        @ExceptionHandler(br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmJaInativoException.class)
        public ResponseEntity<ErrorResponse> handleRealmJaInativoException(
                br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmJaInativoException ex) {

            ErrorResponse errorResponse = new ErrorResponse(
                    HttpStatus.BAD_REQUEST.value(),
                    "Erro de negócio",
                    List.of(ex.getMessage()),
                    LocalDateTime.now(),
                    request.getRequestURI()
            );

            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
        }

        /**
         * Handles RealmJaAtivoException.
         */
        @ExceptionHandler(br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmJaAtivoException.class)
        public ResponseEntity<ErrorResponse> handleRealmJaAtivoException(
                br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmJaAtivoException ex) {

            ErrorResponse errorResponse = new ErrorResponse(
                    HttpStatus.BAD_REQUEST.value(),
                    "Erro de negócio",
                    List.of(ex.getMessage()),
                    LocalDateTime.now(),
                    request.getRequestURI()
            );

            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
        }

        /**
         * Handles RealmNotFoundException.
         */
        @ExceptionHandler(br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmNotFoundException.class)
        public ResponseEntity<ErrorResponse> handleRealmNotFoundException(
                br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmNotFoundException ex) {

            ErrorResponse errorResponse = new ErrorResponse(
                    HttpStatus.NOT_FOUND.value(),
                    "Recurso não encontrado",
                    List.of(ex.getMessage()),
                    LocalDateTime.now(),
                    request.getRequestURI()
            );

            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
        }

        /**
         * Handles EmailJaExisteException specifically.
         */
        @ExceptionHandler(br.com.plataforma.conexaodigital.usuario.domain.exceptions.EmailJaExisteException.class)
        public ResponseEntity<ErrorResponse> handleEmailJaExisteException(
                br.com.plataforma.conexaodigital.usuario.domain.exceptions.EmailJaExisteException ex) {
            ErrorResponse errorResponse = new ErrorResponse(
                    HttpStatus.CONFLICT.value(),
                    "Conflito de dados",
                    List.of(ex.getMessage()),
                    LocalDateTime.now(),
                    request.getRequestURI()
            );

            return ResponseEntity.status(HttpStatus.CONFLICT).body(errorResponse);
        }

        /**
         * Handles UsuarioNotFoundException specifically.
         */
        @ExceptionHandler(br.com.plataforma.conexaodigital.usuario.domain.exceptions.UsuarioNotFoundException.class)
        public ResponseEntity<ErrorResponse> handleUsuarioNotFoundException(
                br.com.plataforma.conexaodigital.usuario.domain.exceptions.UsuarioNotFoundException ex) {
            ErrorResponse errorResponse = new ErrorResponse(
                    HttpStatus.NOT_FOUND.value(),
                    "Recurso não encontrado",
                    List.of(ex.getMessage()),
                    LocalDateTime.now(),
                    request.getRequestURI()
            );

            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
        }

        /**
         * Handles UsuarioJaBloqueadoException specifically.
         */
        @ExceptionHandler(br.com.plataforma.conexaodigital.usuario.domain.exceptions.UsuarioJaBloqueadoException.class)
        public ResponseEntity<ErrorResponse> handleUsuarioJaBloqueadoException(
                br.com.plataforma.conexaodigital.usuario.domain.exceptions.UsuarioJaBloqueadoException ex) {
            ErrorResponse errorResponse = new ErrorResponse(
                    HttpStatus.BAD_REQUEST.value(),
                    "Erro de negócio",
                    List.of(ex.getMessage()),
                    LocalDateTime.now(),
                    request.getRequestURI()
            );

            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
        }

        /**
         * Handles UsuarioNaoBloqueadoException specifically.
         */
        @ExceptionHandler(br.com.plataforma.conexaodigital.usuario.domain.exceptions.UsuarioNaoBloqueadoException.class)
        public ResponseEntity<ErrorResponse> handleUsuarioNaoBloqueadoException(
                br.com.plataforma.conexaodigital.usuario.domain.exceptions.UsuarioNaoBloqueadoException ex) {
            ErrorResponse errorResponse = new ErrorResponse(
                    HttpStatus.BAD_REQUEST.value(),
                    "Erro de negócio",
                    List.of(ex.getMessage()),
                    LocalDateTime.now(),
                    request.getRequestURI()
            );

            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
        }

        /**
         * Handles NomeRoleJaExisteException specifically.
         */
        @ExceptionHandler(br.com.plataforma.conexaodigital.role.domain.exceptions.NomeRoleJaExisteException.class)
        public ResponseEntity<ErrorResponse> handleNomeRoleJaExisteException(
                br.com.plataforma.conexaodigital.role.domain.exceptions.NomeRoleJaExisteException ex) {
            ErrorResponse errorResponse = new ErrorResponse(
                    HttpStatus.CONFLICT.value(),
                    "Conflito de dados",
                    List.of(ex.getMessage()),
                    LocalDateTime.now(),
                    request.getRequestURI()
            );

            return ResponseEntity.status(HttpStatus.CONFLICT).body(errorResponse);
        }

        /**
         * Handles RoleNotFoundException specifically.
         */
        @ExceptionHandler(br.com.plataforma.conexaodigital.role.domain.exceptions.RoleNotFoundException.class)
        public ResponseEntity<ErrorResponse> handleRoleNotFoundException(
                br.com.plataforma.conexaodigital.role.domain.exceptions.RoleNotFoundException ex) {
            ErrorResponse errorResponse = new ErrorResponse(
                    HttpStatus.NOT_FOUND.value(),
                    "Recurso não encontrado",
                    List.of(ex.getMessage()),
                    LocalDateTime.now(),
                    request.getRequestURI()
            );

            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
        }

        /**
         * Handles BusinessException and its subclasses.
         */
        @ExceptionHandler(BusinessException.class)
        public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException ex) {
            ErrorResponse errorResponse = new ErrorResponse(
                    HttpStatus.BAD_REQUEST.value(),
                    "Erro de negócio",
                    List.of(ex.getMessage()),
                    LocalDateTime.now(),
                    request.getRequestURI()
            );

            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
        }

        /**
         * Handles AuthenticationException (autenticação).
         */
        @ExceptionHandler(AuthenticationException.class)
        public ResponseEntity<ErrorResponse> handleAuthenticationException(AuthenticationException ex) {
            ErrorResponse errorResponse = new ErrorResponse(
                    HttpStatus.UNAUTHORIZED.value(),
                    "Autenticação falhou: " + ex.getMessage(),
                    List.of(),
                    LocalDateTime.now(),
                    request.getRequestURI()
            );

            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
        }

        /**
         * Handles AccessDeniedException (autorização).
         */
        @ExceptionHandler(AccessDeniedException.class)
        public ResponseEntity<ErrorResponse> handleAccessDeniedException(AccessDeniedException ex) {
            ErrorResponse errorResponse = new ErrorResponse(
                    HttpStatus.FORBIDDEN.value(),
                    "Acesso negado: " + ex.getMessage(),
                    List.of(),
                    LocalDateTime.now(),
                    request.getRequestURI()
            );

            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(errorResponse);
        }

        /**
         * Handles HttpMessageNotReadableException (invalid JSON format).
         */
        @ExceptionHandler(HttpMessageNotReadableException.class)
        public ResponseEntity<ErrorResponse> handleHttpMessageNotReadable(HttpMessageNotReadableException ex) {
            ErrorResponse errorResponse = new ErrorResponse(
                    HttpStatus.BAD_REQUEST.value(),
                    "Formato de requisição inválido",
                    List.of("O corpo da requisição contém dados inválidos"),
                    LocalDateTime.now(),
                    request.getRequestURI()
            );

            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
        }

         /**
          * Handles all other unhandled exceptions.
          */
        @ExceptionHandler(Exception.class)
        public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
            // Log completo do erro para debugging
            log.error("Erro não tratado em {}: {}", request.getRequestURI(), ex.getMessage(), ex);

            ErrorResponse errorResponse = new ErrorResponse(
                    HttpStatus.INTERNAL_SERVER_ERROR.value(),
                    "Erro interno do servidor",
                    List.of("Ocorreu um erro inesperado. Entre em contato com o suporte."),
                    LocalDateTime.now(),
                    request.getRequestURI()
            );

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
        }

        /**
         * DTO for error responses.
         */
        public record ErrorResponse(
                int status,
                String message,
                List<String> errors,
                LocalDateTime timestamp,
                String path) {
        }
}

```
```java
package br.com.plataforma.conexaodigital.shared.security;

import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.util.Base64;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.springframework.stereotype.Component;

/**
 * Service for AES encryption/decryption operations.
 * Uses AES-128 with GCM mode for authenticated encryption.
 * Key is loaded from application properties or environment variables.
 */
@Component
public class EncryptionService {

    private static final String ALGORITHM = "AES";
    private static final String TRANSFORMATION = "AES/GCM/NoPadding";
    private static final int KEY_SIZE = 128; // 128 bits = 16 bytes
    private static final int GCM_TAG_LENGTH = 128;
    private static final int GCM_IV_LENGTH = 12; // Recommended IV length for GCM
    private static final String ENCRYPTION_KEY_PROPERTY = "app.encryption.key";
    private static final String DEFAULT_KEY = "conexaoauth-key-16"; // 16 bytes default key for dev

    private final SecretKey secretKey;

    /**
     * Constructor that initializes the secret key from environment variables or
     * default.
     */
    public EncryptionService() {
        String keyString = System.getProperty(ENCRYPTION_KEY_PROPERTY);
        if (keyString == null) {
            keyString = System.getenv("ENCRYPTION_KEY");
        }
        if (keyString == null) {
            keyString = DEFAULT_KEY;
        }
        // Ensure key is exactly 16 bytes (128 bits)
        byte[] keyBytes = keyString.getBytes(StandardCharsets.UTF_8);
        byte[] finalKeyBytes = new byte[16];
        System.arraycopy(keyBytes, 0, finalKeyBytes, 0, Math.min(keyBytes.length, 16));
        this.secretKey = new SecretKeySpec(finalKeyBytes, ALGORITHM);
    }

    /**
     * Encrypts a string using AES-128 GCM.
     *
     * @param plaintext the plaintext to encrypt
     * @return Base64 encoded ciphertext (IV + ciphertext)
     */
    public String encrypt(String plaintext) {
        try {
            // Generate random IV
            byte[] iv = new byte[GCM_IV_LENGTH];
            SecureRandom secureRandom = new SecureRandom();
            secureRandom.nextBytes(iv);

            // Initialize cipher for encryption
            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            GCMParameterSpec parameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, parameterSpec);

            // Encrypt plaintext
            byte[] ciphertext = cipher.doFinal(plaintext.getBytes(StandardCharsets.UTF_8));

            // Combine IV and ciphertext
            ByteBuffer byteBuffer = ByteBuffer.allocate(iv.length + ciphertext.length);
            byteBuffer.put(iv);
            byteBuffer.put(ciphertext);

            // Return Base64 encoded
            return Base64.getEncoder().encodeToString(byteBuffer.array());
        } catch (Exception e) {
            throw new RuntimeException("Error encrypting data", e);
        }
    }

    /**
     * Decrypts a Base64 encoded ciphertext using AES-128 GCM.
     *
     * @param encryptedData the Base64 encoded ciphertext (IV + ciphertext)
     * @return the decrypted plaintext
     */
    public String decrypt(String encryptedData) {
        try {
            // Decode Base64
            byte[] decoded = Base64.getDecoder().decode(encryptedData);

            // Extract IV and ciphertext
            ByteBuffer byteBuffer = ByteBuffer.wrap(decoded);
            byte[] iv = new byte[GCM_IV_LENGTH];
            byteBuffer.get(iv);
            byte[] ciphertext = new byte[byteBuffer.remaining()];
            byteBuffer.get(ciphertext);

            // Initialize cipher for decryption
            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            GCMParameterSpec parameterSpec = new GCMParameterSpec(GCM_TAG_LENGTH, iv);
            cipher.init(Cipher.DECRYPT_MODE, secretKey, parameterSpec);

            // Decrypt ciphertext
            byte[] plaintext = cipher.doFinal(ciphertext);

            return new String(plaintext, StandardCharsets.UTF_8);
        } catch (Exception e) {
            throw new RuntimeException("Error decrypting data", e);
        }
    }

    /**
     * Generates a new random AES-128 key.
     *
     * @return Base64 encoded key
     */
    public static String generateKey() {
        try {
            KeyGenerator keyGenerator = KeyGenerator.getInstance(ALGORITHM);
            keyGenerator.init(KEY_SIZE);
            SecretKey key = keyGenerator.generateKey();
            return Base64.getEncoder().encodeToString(key.getEncoded());
        } catch (Exception e) {
            throw new RuntimeException("Error generating key", e);
        }
    }
}

```
```java
package br.com.plataforma.conexaodigital.shared.security;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Optional;

/**
 * Helper class to obtain current user information from SecurityContext.
 */
public class SecurityContextHelper {
    
    /**
     * Gets the current username from SecurityContext.
     *
     * @return Optional containing the current username, or empty if not authenticated
     */
    public static Optional<String> getCurrentUsername() {
        return Optional.ofNullable(SecurityContextHolder.getContext())
            .map(context -> context.getAuthentication())
            .filter(Authentication::isAuthenticated)
            .map(Authentication::getPrincipal)
            .filter(principal -> principal instanceof UserDetails)
            .map(principal -> ((UserDetails) principal).getUsername());
    }
}
```
```java
package br.com.plataforma.conexaodigital.usuario.api.controller;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import br.com.plataforma.conexaodigital.usuario.api.requests.AtualizarUsuarioRequest;
import br.com.plataforma.conexaodigital.usuario.api.requests.CriarUsuarioRequest;
import br.com.plataforma.conexaodigital.usuario.api.requests.ResetSenhaAdminRequest;
import br.com.plataforma.conexaodigital.usuario.api.requests.SolicitarRecuperacaoSenhaRequest;
import br.com.plataforma.conexaodigital.usuario.api.requests.ValidarCodigoRecuperacaoRequest;
import br.com.plataforma.conexaodigital.usuario.api.responses.SolicitarRecuperacaoSenhaResponse;
import br.com.plataforma.conexaodigital.usuario.api.responses.UsuarioResponse;
import br.com.plataforma.conexaodigital.usuario.domain.model.enums.StatusUsuario;
import br.com.plataforma.conexaodigital.usuario.domain.service.UsuarioService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;

/**
 * REST controller for managing users.
 * Provides endpoints for user operations.
 */
@RestController
@RequestMapping("/api/v1/usuarios")
@Tag(name = "Gestão de Usuários", description = "Operações de gestão de usuários")
public class UsuarioController {

        private final UsuarioService usuarioService;

        /**
         * Constructor with dependency injection.
         *
         * @param usuarioService The user service
         */
        public UsuarioController(UsuarioService usuarioService) {
                this.usuarioService = usuarioService;
        }

        /**
         * Creates a new user.
         *
         * @param request The request containing user data
         * @return ResponseEntity with created user and HTTP status 201
         */
        @PostMapping
        @Operation(summary = "Criar usuário", description = "Cria um novo usuário com senha criptografada e associa a realm e roles")
        @ApiResponses({
                        @ApiResponse(responseCode = "201", description = "Usuário criado com sucesso", content = @Content(schema = @Schema(implementation = UsuarioResponse.class))),
                        @ApiResponse(responseCode = "400", description = "Dados inválidos"),
                        @ApiResponse(responseCode = "404", description = "Realm não encontrado"),
                        @ApiResponse(responseCode = "409", description = "Email já existe")
        })
        public ResponseEntity<UsuarioResponse> criar(@Valid @RequestBody CriarUsuarioRequest request) {
                UsuarioResponse usuarioResponse = usuarioService.criar(request);
                return ResponseEntity.status(HttpStatus.CREATED).body(usuarioResponse);
        }

        /**
         * Updates an existing user.
         *
         * @param id      The ID of the user to update
         * @param request The request containing updated user data
         * @return ResponseEntity with updated user and HTTP status 200
         */
        @PutMapping("/{id}")
        @Operation(summary = "Atualizar usuário", description = "Atualiza dados de um usuário existente (nome, email, roles, empresaId, tenentId)")
        @ApiResponses({
                        @ApiResponse(responseCode = "200", description = "Usuário atualizado com sucesso", content = @Content(schema = @Schema(implementation = UsuarioResponse.class))),
                        @ApiResponse(responseCode = "400", description = "Dados inválidos"),
                        @ApiResponse(responseCode = "404", description = "Usuário ou role não encontrado"),
                        @ApiResponse(responseCode = "409", description = "Email já existe")
        })
        public ResponseEntity<UsuarioResponse> atualizar(
                        @PathVariable UUID id,
                        @Valid @RequestBody AtualizarUsuarioRequest request) {
                UsuarioResponse usuarioResponse = usuarioService.atualizar(id, request);
                return ResponseEntity.ok(usuarioResponse);
        }

        /**
         * Blocks an existing user.
         *
         * @param id The ID of the user to block
         * @return ResponseEntity with blocked user and HTTP status 200
         */
        @PatchMapping("/{id}/bloquear")
        @Operation(summary = "Bloquear usuário", description = "Bloqueia um usuário impedindo seu acesso ao sistema")
        @ApiResponses({
                        @ApiResponse(responseCode = "200", description = "Usuário bloqueado com sucesso", content = @Content(schema = @Schema(implementation = UsuarioResponse.class))),
                        @ApiResponse(responseCode = "400", description = "Usuário já está bloqueado"),
                        @ApiResponse(responseCode = "404", description = "Usuário não encontrado")
        })
        public ResponseEntity<UsuarioResponse> bloquear(@PathVariable UUID id) {
                UsuarioResponse usuarioResponse = usuarioService.bloquear(id);
                return ResponseEntity.ok(usuarioResponse);
        }

        /**
         * Unblocks an existing user.
         *
         * @param id The ID of the user to unblock
         * @return ResponseEntity with unblocked user and HTTP status 200
         */
        @PatchMapping("/{id}/desbloquear")
        @Operation(summary = "Desbloquear usuário", description = "Desbloqueia um usuário permitindo seu acesso ao sistema novamente")
        @ApiResponses({
                        @ApiResponse(responseCode = "200", description = "Usuário desbloqueado com sucesso", content = @Content(schema = @Schema(implementation = UsuarioResponse.class))),
                        @ApiResponse(responseCode = "400", description = "Usuário não está bloqueado"),
                        @ApiResponse(responseCode = "404", description = "Usuário não encontrado")
        })
        public ResponseEntity<UsuarioResponse> desbloquear(@PathVariable UUID id) {
                UsuarioResponse usuarioResponse = usuarioService.desbloquear(id);
                return ResponseEntity.ok(usuarioResponse);
        }

        /**
         * Resets a user's password administratively.
         *
         * @param id      The ID of user whose password to reset
         * @param request The request containing the new password
         * @return ResponseEntity with HTTP status 200
         */
        @PostMapping("/{id}/reset-password")
        @Operation(summary = "Reset administrativo de senha", description = "Reseta a senha de um usuário fornecendo uma nova senha (requer privilégios de administrador)")
        @ApiResponses({
                        @ApiResponse(responseCode = "200", description = "Senha resetada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Nova senha inválida"),
                        @ApiResponse(responseCode = "404", description = "Usuário não encontrado")
        })
        public ResponseEntity<Void> resetSenhaAdmin(
                        @PathVariable UUID id,
                        @Valid @RequestBody ResetSenhaAdminRequest request) {
                usuarioService.resetSenhaAdmin(id, request);
                return ResponseEntity.ok().build();
        }

        /**
         * Requests a password recovery code to be sent via email.
         * Always returns success even if user doesn't exist (prevents user
         * enumeration).
         *
         * @param request The request containing user's email
         * @return ResponseEntity with success message and HTTP status 200
         */
        @PostMapping("/recuperar-senha")
        @Operation(summary = "Solicitar recuperação de senha", description = "Envia um código de 6 dígitos para o e-mail do usuário para recuperação de senha")
        @ApiResponses({
                        @ApiResponse(responseCode = "200", description = "Código enviado com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Email inválido")
        })
        public ResponseEntity<SolicitarRecuperacaoSenhaResponse> solicitarRecuperacaoSenha(
                        @Valid @RequestBody SolicitarRecuperacaoSenhaRequest request) {
                SolicitarRecuperacaoSenhaResponse response = usuarioService.solicitarRecuperacaoSenha(request);
                return ResponseEntity.ok(response);
        }

        /**
         * Validates a password recovery code and resets user's password.
         *
         * @param request The request containing email, code, and new password
         * @return ResponseEntity with HTTP status 200
         */
        @PostMapping("/validar-codigo-recuperacao")
        @Operation(summary = "Validar código de recuperação e redefinir senha", description = "Valida o código de recuperação recebido por e-mail e redefine a senha do usuário")
        @ApiResponses({
                        @ApiResponse(responseCode = "200", description = "Senha redefinida com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Código inválido, expirado ou já utilizado"),
                        @ApiResponse(responseCode = "404", description = "Usuário não encontrado")
        })
        public ResponseEntity<Void> validarCodigoRecuperacao(
                        @Valid @RequestBody ValidarCodigoRecuperacaoRequest request) {
                usuarioService.validarCodigoRecuperacao(request);
                return ResponseEntity.ok().build();
        }

/**
         * Finds a user by their unique ID.
         *
         * @param id The ID of user to find
         * @return ResponseEntity with user details and HTTP status 200
         */
        @GetMapping("/{id}")
        @Operation(summary = "Buscar usuário por ID", description = "Retorna os detalhes completos de um usuário específico pelo seu ID")
        @ApiResponses({
                        @ApiResponse(responseCode = "200", description = "Usuário encontrado com sucesso", content = @Content(schema = @Schema(implementation = UsuarioResponse.class))),
                        @ApiResponse(responseCode = "404", description = "Usuário não encontrado"),
                        @ApiResponse(responseCode = "400", description = "ID inválido")
        })
        public ResponseEntity<UsuarioResponse> buscarPorId(@PathVariable UUID id) {
                UsuarioResponse usuarioResponse = usuarioService.buscarPorId(id);
                return ResponseEntity.ok(usuarioResponse);
        }

        /**
         * Finds a user by their username (email address).
         * Uses case-insensitive search for email matching.
         *
         * @param username The username (email) to search for
         * @return ResponseEntity with user details and HTTP status 200
         */
        @GetMapping("/username/{username}")
        @Operation(summary = "Buscar usuário por username (e-mail)", description = "Retorna os detalhes completos de um usuário específico pelo seu username (e-mail). Busca é case-insensitive.")
        @ApiResponses({
                        @ApiResponse(responseCode = "200", description = "Usuário encontrado com sucesso", content = @Content(schema = @Schema(implementation = UsuarioResponse.class))),
                        @ApiResponse(responseCode = "404", description = "Usuário não encontrado"),
                        @ApiResponse(responseCode = "400", description = "Username inválido")
        })
        public ResponseEntity<UsuarioResponse> buscarPorUsername(@PathVariable String username) {
                UsuarioResponse usuarioResponse = usuarioService.buscarPorUsername(username);
                return ResponseEntity.ok(usuarioResponse);
        }

        /**
         * Lists users with pagination and filtering capabilities.
         * Supports filtering by name, email, realmId, empresaId, tenentId, status,
         * roleIds, and creation date range.
         * Default sorting is by name ascending with maximum page size of 100.
         *
         * @param nome              Partial name filter (case-insensitive, optional)
         * @param email             Partial email filter (case-insensitive, optional)
         * @param realmId           Exact realm ID filter (optional)
         * @param empresaId         Exact empresa ID filter (optional)
         * @param tenentId          Exact tenant ID filter (optional)
         * @param status            Status filter (optional)
         * @param roleIds           Users with any of specified roles (optional,
         *                          comma-separated)
         * @param dataCriacaoInicio Creation date start filter (optional, ISO format)
         * @param dataCriacaoFim    Creation date end filter (optional, ISO format)
         * @param pageable          Pagination and sorting information (default: page=0,
         *                          size=10, sort=nome,asc)
         * @return ResponseEntity with paginated list of users and HTTP status 200
         */
        @GetMapping
        @Operation(summary = "Listar usuários com paginação e filtros", description = "Lista usuários com suporte a paginação e múltiplos filtros. "
                        +
                        "Busca textual por nome/email (case-insensitive), filtros exatos por IDs, " +
                        "status, roles e intervalo de data de criação.")
        @ApiResponses({
                        @ApiResponse(responseCode = "200", description = "Lista de usuários retornada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Parâmetros de paginação inválidos")
        })
        public ResponseEntity<Page<UsuarioResponse>> listar(
                        @RequestParam(required = false) String nome,
                        @RequestParam(required = false) String email,
                        @RequestParam(required = false) UUID realmId,
                        @RequestParam(required = false) String empresaId,
                        @RequestParam(required = false) String tenentId,
                        @RequestParam(required = false) StatusUsuario status,
                        @RequestParam(required = false) List<UUID> roleIds,
                        @RequestParam(required = false) @org.springframework.format.annotation.DateTimeFormat(iso = org.springframework.format.annotation.DateTimeFormat.ISO.DATE_TIME) LocalDateTime dataCriacaoInicio,
                        @RequestParam(required = false) @org.springframework.format.annotation.DateTimeFormat(iso = org.springframework.format.annotation.DateTimeFormat.ISO.DATE_TIME) LocalDateTime dataCriacaoFim,
                        @PageableDefault(size = 10, sort = "nome") Pageable pageable) {

                // Validate page size limit (max 100 as per business rule)
                if (pageable.getPageSize() > 100) {
                        throw new IllegalArgumentException("Tamanho da página não pode exceder 100 registros");
                }

                Page<UsuarioResponse> usuariosPage = usuarioService.listar(
                                nome, email, realmId, empresaId, tenentId, status, roleIds,
                                dataCriacaoInicio, dataCriacaoFim, pageable);

                return ResponseEntity.ok(usuariosPage);
        }
}

```
```java
package br.com.plataforma.conexaodigital.usuario.api.requests;

import java.util.List;
import java.util.UUID;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.Size;

/**
 * Request DTO for updating an existing user.
 * Contains validation annotations for user update data.
 * Note: realmId and password are not editable via this endpoint.
 */
public record AtualizarUsuarioRequest(

                @NotBlank(message = "Nome é obrigatório") @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres") String nome,

                @NotBlank(message = "Email é obrigatório") @Email(message = "Email deve ter formato válido") String email,

                @NotEmpty(message = "Pelo menos uma role é obrigatória") List<UUID> roleIds,

                @Size(max = 50, message = "Empresa ID deve ter no máximo 50 caracteres") String empresaId,

                @Size(max = 50, message = "Tenant ID deve ter no máximo 50 caracteres") String tenentId,

                @Size(min = 11, max = 100, message = "CPF ou CNPJ deve ter entre 11 e 14 caracteres") String cpfOrCnpj) {
}
```
```java
package br.com.plataforma.conexaodigital.usuario.api.requests;

import java.util.List;
import java.util.UUID;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

/**
 * Request DTO for creating a new user.
 * Contains validation annotations for user data.
 * Password is required but never returned in response for security.
 */
public record CriarUsuarioRequest(

                @NotBlank(message = "Nome é obrigatório") @Size(min = 3, max = 100, message = "Nome deve ter entre 3 e 100 caracteres") String nome,

                @NotBlank(message = "Email é obrigatório") @Email(message = "Email deve ter formato válido") String email,

                @NotBlank(message = "Senha é obrigatória") @Size(min = 8, message = "Senha deve ter no mínimo 8 caracteres") String senha,

                @NotNull(message = "Realm ID é obrigatório") UUID realmId,

                @NotEmpty(message = "Pelo menos uma role é obrigatória") List<UUID> roleIds,

                @Size(max = 50, message = "Empresa ID deve ter no máximo 50 caracteres") String empresaId,

                @Size(max = 50, message = "Tenant ID deve ter no máximo 50 caracteres") String tenentId) {
}

```
```java
package br.com.plataforma.conexaodigital.usuario.api.requests;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

/**
 * Request DTO for administrative password reset.
 * Contains the new password to be set for a user.
 */
public record ResetSenhaAdminRequest(

        @NotBlank(message = "Nova senha é obrigatória") @Size(min = 8, message = "Senha deve ter no mínimo 8 caracteres") String novaSenha

) {
}
```
```java
package br.com.plataforma.conexaodigital.usuario.api.requests;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

/**
 * Request DTO for password recovery code request.
 * Contains validation annotations for email.
 */
public record SolicitarRecuperacaoSenhaRequest(

                @NotBlank(message = "Email é obrigatório") @Email(message = "Email inválido") String email) {
}

```
```java
package br.com.plataforma.conexaodigital.usuario.api.requests;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

/**
 * Request DTO for validating password recovery code and resetting password.
 * Contains validation annotations for email, code, and new password.
 */
public record ValidarCodigoRecuperacaoRequest(

        @NotBlank(message = "Email é obrigatório")
        @Email(message = "Email inválido")
        String email,

        @NotBlank(message = "Código é obrigatório")
        @Size(min = 6, max = 6, message = "Código deve ter 6 dígitos")
        @Pattern(regexp = "^[0-9]{6}$", message = "Código deve conter apenas números")
        String codigo,

        @NotBlank(message = "Nova senha é obrigatória")
        @Size(min = 8, message = "Senha deve ter no mínimo 8 caracteres")
        String novaSenha
) {}

```
```java
package br.com.plataforma.conexaodigital.usuario.api.responses;

/**
 * Response DTO for password recovery code request.
 * Contains success message.
 */
public record SolicitarRecuperacaoSenhaResponse(
        String mensagem
) {}

```
```java
package br.com.plataforma.conexaodigital.usuario.api.responses;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

import br.com.plataforma.conexaodigital.realm.domain.model.StatusRealm;
import br.com.plataforma.conexaodigital.usuario.domain.model.enums.StatusUsuario;

/**
 * Response DTO for user data.
 * Contains all user information except password for security.
 */
public record UsuarioResponse(
 
        UUID id,
        String nome,
        String cpfOrCnpj,  // ALTERADO: cpf → cpfOrCnpj para suportar ambos
        String email,
        UUID realmId,
        String realmNome,
        List<UUID> roleIds,
        List<String> roleNomes,
        String empresaId,
        String tenentId,
        StatusUsuario status,
        StatusRealm realmStatus,
        LocalDateTime dataCriacao,
        LocalDateTime dataUltimoLogin,
        LocalDateTime dataAtualizacao) {

    /**
     * Retorna o ID do tenant para manter compatibilidade.
     * 
     * @deprecated Use {@link #tenantId()} em vez disso.
     */
    @Deprecated
    public String tenantId() {
        return tenentId;
    }
}

```
```java
package br.com.plataforma.conexaodigital.usuario.domain.exceptions;

import br.com.plataforma.conexaodigital.shared.exceptions.BusinessException;

/**
 * Exception thrown when a password recovery code is invalid.
 * This can happen when:
 * - Code has expired
 * - Code has already been used
 * - Code doesn't exist
 * - Code doesn't match the user
 */
public class CodigoRecuperacaoInvalidoException extends BusinessException {

    private static final String DEFAULT_MESSAGE = "Código de recuperação inválido ou expirado";

    /**
     * Default constructor.
     */
    public CodigoRecuperacaoInvalidoException() {
        super(DEFAULT_MESSAGE);
    }

    /**
     * Constructor with custom message.
     *
     * @param message The custom error message
     */
    public CodigoRecuperacaoInvalidoException(String message) {
        super(message);
    }
}

```
```java
package br.com.plataforma.conexaodigital.usuario.domain.exceptions;

import br.com.plataforma.conexaodigital.shared.exceptions.BusinessException;

/**
 * Exception thrown when attempting to create a user with an email that already exists.
 */
public class EmailJaExisteException extends BusinessException {

    /**
     * Constructor with email parameter.
     *
     * @param email the email that already exists
     */
    public EmailJaExisteException(String email) {
        super("Email já existe: " + email);
    }
}
```
```java
package br.com.plataforma.conexaodigital.usuario.domain.exceptions;

import br.com.plataforma.conexaodigital.shared.exceptions.BusinessException;

/**
 * Exception thrown when no roles are selected for a user.
 */
public class RolesNaoSelecionadasException extends BusinessException {

    /**
     * Constructs a new RolesNaoSelecionadasException.
     */
    public RolesNaoSelecionadasException() {
        super("Pelo menos uma role deve ser selecionada para o usuário");
    }
}

```
```java
package br.com.plataforma.conexaodigital.usuario.domain.exceptions;

import java.util.UUID;

/**
 * Exception thrown when attempting to block a user that is already blocked.
 */
public class UsuarioJaBloqueadoException extends RuntimeException {

    /**
     * Constructor with user ID parameter.
     *
     * @param id the ID of the user that is already blocked
     */
    public UsuarioJaBloqueadoException(UUID id) {
        super("Usuário já está bloqueado: " + id);
    }
}
```
```java
package br.com.plataforma.conexaodigital.usuario.domain.exceptions;

/**
 * Exception thrown when attempting to unblock a user who is not blocked.
 */
public class UsuarioNaoBloqueadoException extends RuntimeException {

    /**
     * Constructs a new UsuarioNaoBloqueadoException with a message for the given user ID.
     *
     * @param id the UUID of the user who is not blocked
     */
    public UsuarioNaoBloqueadoException(java.util.UUID id) {
        super("Usuário não está bloqueado: " + id);
    }
}
```
```java
package br.com.plataforma.conexaodigital.usuario.domain.exceptions;

import java.util.UUID;

/**
 * Exception thrown when a user is not found.
 */
public class UsuarioNotFoundException extends RuntimeException {

    /**
     * Constructor with user ID parameter.
     *
     * @param id ID of user that was not found
     */
    public UsuarioNotFoundException(UUID id) {
        super("Usuário não encontrado: " + id);
    }

    /**
     * Constructor with email parameter.
     *
     * @param email Email of user that was not found
     */
    public UsuarioNotFoundException(String email) {
        super("Usuário não encontrado com o email: " + email);
    }
}

```
```java
package br.com.plataforma.conexaodigital.usuario.domain.model;

import jakarta.persistence.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Entity representing a password recovery code.
 * Stores encrypted codes for password reset functionality.
 */
@Entity
@Table(name = "codigos_recuperacao")
@EntityListeners(AuditingEntityListener.class)
public class CodigoRecuperacao {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(name = "codigo", nullable = false, length = 255)
    private String codigo;

    @Column(name = "usuario_id", nullable = false)
    private UUID usuarioId;

    @Column(name = "data_expiracao", nullable = false)
    private LocalDateTime dataExpiracao;

    @Column(name = "utilizado", nullable = false)
    private Boolean utilizado = false;

    @CreatedDate
    @Column(name = "data_criacao", nullable = false, updatable = false)
    private LocalDateTime dataCriacao;

    @Version
    private Long version;

    // Default constructor for JPA
    public CodigoRecuperacao() {}

    // Constructor with fields
    public CodigoRecuperacao(UUID usuarioId, String codigo, LocalDateTime dataExpiracao) {
        this.usuarioId = usuarioId;
        this.codigo = codigo;
        this.dataExpiracao = dataExpiracao;
        this.utilizado = false;
    }

    // Getters and setters
    public UUID getId() {
        return id;
    }

    public void setId(UUID id) {
        this.id = id;
    }

    public String getCodigo() {
        return codigo;
    }

    public void setCodigo(String codigo) {
        this.codigo = codigo;
    }

    public UUID getUsuarioId() {
        return usuarioId;
    }

    public void setUsuarioId(UUID usuarioId) {
        this.usuarioId = usuarioId;
    }

    public LocalDateTime getDataExpiracao() {
        return dataExpiracao;
    }

    public void setDataExpiracao(LocalDateTime dataExpiracao) {
        this.dataExpiracao = dataExpiracao;
    }

    public Boolean getUtilizado() {
        return utilizado;
    }

    public void setUtilizado(Boolean utilizado) {
        this.utilizado = utilizado;
    }

    public LocalDateTime getDataCriacao() {
        return dataCriacao;
    }

    public void setDataCriacao(LocalDateTime dataCriacao) {
        this.dataCriacao = dataCriacao;
    }

    public Long getVersion() {
        return version;
    }

    public void setVersion(Long version) {
        this.version = version;
    }
}

```
```java
package br.com.plataforma.conexaodigital.usuario.domain.model;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import br.com.plataforma.conexaodigital.role.domain.model.Role;
import br.com.plataforma.conexaodigital.usuario.domain.model.enums.StatusUsuario;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EntityListeners;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.Table;
import jakarta.persistence.Version;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Entity representing a User in the system.
 */
@Entity
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "usuarios")
@EntityListeners(AuditingEntityListener.class)
public class Usuario {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(nullable = false, unique = true, length = 255)
    private String email;

    @Column()
    private String cpfOrCnpj;

    @Column(nullable = false, length = 100)
    private String nome;

    @Column(nullable = false)
    private String senha;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    private StatusUsuario status;

    @CreatedDate
    @Column(name = "data_criacao", nullable = false, updatable = false)
    private LocalDateTime dataCriacao;

    @Column(name = "data_ultimo_login", nullable = true)
    private LocalDateTime dataUltimoLogin;

    @LastModifiedDate
    @Column(name = "data_atualizacao", nullable = false)
    private LocalDateTime dataAtualizacao;

    @Version
    private Long version;

    // Foreign keys
    @Column(name = "realm_id", nullable = false)
    private UUID realmId;

    @Column(name = "empresa_id", nullable = true, length = 50)
    private String empresaId;

    @Column(name = "tenant_id", nullable = true, length = 50)
    private String tenantId;

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(name = "usuario_roles", joinColumns = @JoinColumn(name = "usuario_id", referencedColumnName = "id"), inverseJoinColumns = @JoinColumn(name = "role_id", referencedColumnName = "id"))
    @Builder.Default
    private Set<Role> roles = new HashSet<>();

    /**
     * Adiciona uma role ao usuário.
     *
     * @param role A role a ser adicionada
     * @return true se a role foi adicionada, false se já existia
     */
    public boolean addRole(Role role) {
        if (this.roles == null) {
            this.roles = new HashSet<>();
        }
        return this.roles.add(role);
    }

    /**
     * Remove uma role do usuário.
     *
     * @param role A role a ser removida
     * @return true se a role foi removida, false se não existia
     */
    public boolean removeRole(Role role) {
        if (this.roles == null) {
            return false;
        }
        return this.roles.remove(role);
    }

    /**
     * Verifica se o usuário possui uma role específica.
     *
     * @param roleName O nome da role
     * @return true se o usuário possui a role
     */
    public boolean hasRole(String roleName) {
        if (this.roles == null) {
            return false;
        }
        return this.roles.stream()
                .anyMatch(role -> role.getNome().equalsIgnoreCase(roleName));
    }

    /**
     * Verifica se o usuário possui pelo menos uma das roles especificadas.
     *
     * @param roleNames Array de nomes de roles
     * @return true se o usuário possui pelo menos uma das roles
     */
    public boolean hasAnyRole(String... roleNames) {
        if (this.roles == null || roleNames == null || roleNames.length == 0) {
            return false;
        }
        return this.roles.stream()
                .anyMatch(role -> {
                    for (String name : roleNames) {
                        if (role.getNome().equalsIgnoreCase(name)) {
                            return true;
                        }
                    }
                    return false;
                });
    }

    /**
     * Obtém os nomes das roles do usuário.
     *
     * @return Set com os nomes das roles
     */
    public Set<String> getRoleNames() {
        if (this.roles == null) {
            return new HashSet<>();
        }
        Set<String> names = new HashSet<>();
        for (Role role : this.roles) {
            names.add(role.getNome());
        }
        return names;
    }
}

```
```java
package br.com.plataforma.conexaodigital.usuario.domain.model.enums;

/**
 * Enum representing user status in the system.
 */
public enum StatusUsuario {
    ATIVO,
    INATIVO,
    BLOQUEADO
}

```
```java
package br.com.plataforma.conexaodigital.usuario.domain.repository;

import br.com.plataforma.conexaodigital.usuario.domain.model.CodigoRecuperacao;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

/**
 * Repository interface for CodigoRecuperacao entity operations.
 * Extends JpaRepository to provide CRUD operations.
 */
@Repository
public interface CodigoRecuperacaoRepository extends JpaRepository<CodigoRecuperacao, UUID> {

    /**
     * Finds the most recent recovery code for a user.
     *
     * @param usuarioId the user ID to search
     * @return Optional containing the most recent recovery code if found
     */
    Optional<CodigoRecuperacao> findTopByUsuarioIdOrderByDataCriacaoDesc(UUID usuarioId);
}

```
```java
package br.com.plataforma.conexaodigital.usuario.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import br.com.plataforma.conexaodigital.usuario.domain.model.Usuario;

/**
 * Repository interface for User entity operations.
 * Extends JpaRepository to provide CRUD operations.
 * Custom queries for business-specific requirements.
 */
@Repository
public interface UsuarioRepository extends JpaRepository<Usuario, UUID>, JpaSpecificationExecutor<Usuario> {

    /**
     * Finds a user by email address.
     *
     * @param email the email address to search
     * @return Optional containing the user if found
     */
    Optional<Usuario> findByEmail(String email);

    /**
     * Checks if a user with the given email already exists.
     *
     * @param email the email address to check
     * @return true if a user with this email exists, false otherwise
     */
    boolean existsByEmail(String email);

    /**
     * Finds users by realm ID with pagination support.
     *
     * @param realmId  the realm ID to filter by
     * @param pageable pagination parameters
     * @return page of users
     */
    Page<Usuario> findByRealmId(UUID realmId, Pageable pageable);

    /**
     * Finds users by status with pagination support.
     *
     * @param status the user status to filter by
     * @param page   of users
     */
    Page<Usuario> findByStatus(br.com.plataforma.conexaodigital.usuario.domain.model.enums.StatusUsuario status,
            Pageable pageable);

    /**
     * Checks if a user with the given email already exists (case-insensitive).
     *
     * @param email the email address to check
     * @return true if a user with this email exists (case-insensitive), false
     *         otherwise
     */
    @Query("SELECT CASE WHEN COUNT(u) > 0 THEN true ELSE false END FROM Usuario u WHERE LOWER(u.email) = LOWER(:email)")
    boolean existsByEmailIgnoreCase(@Param("email") String email);

    /**
     * Checks if a user with the given email already exists (case-insensitive),
     * excluding the specified user ID.
     * Used during user update to exclude the current user from validation.
     *
     * @param email The email address to check
     * @param id    The user ID to exclude from check
     * @return true if a user with this email exists (case-insensitive) excluding
     *         the specified ID, false otherwise
     */
    @Query("SELECT CASE WHEN COUNT(u) > 0 THEN true ELSE false END FROM Usuario u WHERE LOWER(u.email) = LOWER(:email) AND u.id != :id")
    boolean existsByEmailIgnoreCaseAndIdNot(@Param("email") String email, @Param("id") UUID id);

    /**
     * Counts users by realm ID.
     *
     * @param realmId The realm ID
     * @return Number of users in the realm
     */
    long countByRealmId(UUID realmId);

    /**
      * Counts users by status.
      *
      * @param status The user status
      * @return Number of users with specified status
      */
    long countByStatus(br.com.plataforma.conexaodigital.usuario.domain.model.enums.StatusUsuario status);

    /**
     * Finds an active user by email.
     * Used for authentication when username can be email or CPF.
     *
     * @param email The email to search
     * @return Optional containing the user if found
     */
    @Query("""
        SELECT u FROM Usuario u
        WHERE LOWER(u.email) = LOWER(:email)
        AND u.status = 'ATIVO'
        """)
    Optional<Usuario> buscarPorEmailAtivo(@Param("email") String email);

    /**
     * Counts active users by realm ID.
     *
     * @param realmId The realm ID
     * @return Number of active users in realm
     */
    @Query("SELECT COUNT(u) FROM Usuario u WHERE u.realmId = :realmId AND u.status = 'ATIVO'")
    long countByRealmIdAndStatusAtivo(@Param("realmId") UUID realmId);

    /**
     * Counts blocked users by realm ID.
     *
     * @param realmId The realm ID
     * @return Number of blocked users in realm
     */
    @Query("SELECT COUNT(u) FROM Usuario u WHERE u.realmId = :realmId AND u.status = 'BLOQUEADO'")
    long countByRealmIdAndBloqueadoTrue(@Param("realmId") UUID realmId);
}

```
```java
package br.com.plataforma.conexaodigital.usuario.domain.service;

import br.com.plataforma.conexaodigital.usuario.api.requests.AtualizarUsuarioRequest;
import br.com.plataforma.conexaodigital.usuario.api.requests.CriarUsuarioRequest;
import br.com.plataforma.conexaodigital.usuario.api.requests.ResetSenhaAdminRequest;
import br.com.plataforma.conexaodigital.usuario.api.requests.SolicitarRecuperacaoSenhaRequest;
import br.com.plataforma.conexaodigital.usuario.api.requests.ValidarCodigoRecuperacaoRequest;
import br.com.plataforma.conexaodigital.usuario.api.responses.SolicitarRecuperacaoSenhaResponse;
import br.com.plataforma.conexaodigital.usuario.api.responses.UsuarioResponse;
import br.com.plataforma.conexaodigital.usuario.domain.model.enums.StatusUsuario;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.transaction.annotation.Transactional;

/**
 * Service interface for User business operations.
 * Defines the contract for user management operations.
 */
public interface UsuarioService {

    /**
     * Creates a new user with the provided data.
     *
     * @param request The request containing user data
     * @return The created user response
     * @throws br.com.plataforma.conexaodigital.usuario.domain.exceptions.EmailJaExisteException if email already exists
     * @throws br.com.plataforma.conexaodigital.usuario.domain.exceptions.RealmNotFoundException if realm not found
     * @throws br.com.plataforma.conexaodigital.usuario.domain.exceptions.RoleNotFoundException if role not found
     */
    UsuarioResponse criar(CriarUsuarioRequest request);

    /**
     * Updates an existing user with the provided data.
     *
     * @param id The ID of the user to update
     * @param request The request containing updated user data
     * @return The updated user response
     * @throws br.com.plataforma.conexaodigital.usuario.domain.exceptions.EmailJaExisteException if email already exists for another user
     * @throws br.com.plataforma.conexaodigital.usuario.domain.exceptions.UsuarioNotFoundException if user not found
     * @throws br.com.plataforma.conexaodigital.usuario.domain.exceptions.RoleNotFoundException if role not found
     */
    UsuarioResponse atualizar(UUID id, AtualizarUsuarioRequest request);

    /**
     * Blocks an existing user, preventing authentication.
     *
     * @param id The ID of the user to block
     * @return The blocked user response
     * @throws br.com.plataforma.conexaodigital.usuario.domain.exceptions.UsuarioNotFoundException if user not found
     * @throws br.com.plataforma.conexaodigital.usuario.domain.exceptions.UsuarioJaBloqueadoException if user is already blocked
     */
    UsuarioResponse bloquear(UUID id);

    /**
     * Unblocks an existing user, allowing authentication.
     *
     * @param id The ID of the user to unblock
     * @return The unblocked user response
     * @throws br.com.plataforma.conexaodigital.usuario.domain.exceptions.UsuarioNotFoundException if user not found
     * @throws br.com.plataforma.conexaodigital.usuario.domain.exceptions.UsuarioNaoBloqueadoException if user is not blocked
     */
    UsuarioResponse desbloquear(UUID id);

    /**
     * Resets a user's password administratively.
     *
     * @param id The ID of user whose password to reset
     * @param request The request containing the new password
     * @throws br.com.plataforma.conexaodigital.usuario.domain.exceptions.UsuarioNotFoundException if user not found
     */
    void resetSenhaAdmin(UUID id, ResetSenhaAdminRequest request);

    /**
     * Requests a password recovery code to be sent via email.
     * Always returns success even if user doesn't exist (prevents user enumeration).
     *
     * @param request The request containing the user's email
     * @return Response with confirmation message
     */
    SolicitarRecuperacaoSenhaResponse solicitarRecuperacaoSenha(SolicitarRecuperacaoSenhaRequest request);

    /**
     * Validates a password recovery code and resets user's password.
     *
     * @param request The request containing email, code, and new password
     * @throws br.com.plataforma.conexaodigital.usuario.domain.exceptions.UsuarioNotFoundException if user not found
     * @throws br.com.plataforma.conexaodigital.usuario.domain.exceptions.CodigoRecuperacaoInvalidoException if code is invalid, expired, or already used
     */
    void validarCodigoRecuperacao(ValidarCodigoRecuperacaoRequest request);

    /**
     * Lists users with pagination and optional filters.
     *
     * @param nome Filter by name (partial, case-insensitive)
     * @param email Filter by email (partial, case-insensitive)
     * @param realmId Filter by realm ID (exact)
     * @param empresaId Filter by empresa ID (exact)
     * @param tenentId Filter by tenant ID (exact)
     * @param status Filter by status
     * @param roleIds Filter by role IDs (users with any of these roles)
     * @param dataCriacaoInicio Filter by creation start date (inclusive)
     * @param dataCriacaoFim Filter by creation end date (inclusive)
     * @param pageable Pagination parameters
     * @return Page with filtered user results
     */
    Page<UsuarioResponse> listar(String nome, String email, UUID realmId, String empresaId, String tenentId, 
                                    StatusUsuario status, List<UUID> roleIds, LocalDateTime dataCriacaoInicio, 
                                    LocalDateTime dataCriacaoFim, Pageable pageable);

    /**
     * Finds a user by their unique ID.
     *
     * @param id The ID of the user to find
     * @return The user response with all details
     * @throws br.com.plataforma.conexaodigital.usuario.domain.exceptions.UsuarioNotFoundException if user not found
     */
    @Transactional(readOnly = true)
    UsuarioResponse buscarPorId(UUID id);

    /**
     * Finds a user by their username (email address).
     * Uses case-insensitive search for email matching.
     *
     * @param username The username (email) to search for
     * @return The user response with all details
     * @throws br.com.plataforma.conexaodigital.usuario.domain.exceptions.UsuarioNotFoundException if user not found
     */
    @Transactional(readOnly = true)
    UsuarioResponse buscarPorUsername(String username);
}

```
```java
package br.com.plataforma.conexaodigital.usuario.domain.service;

import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.plataforma.conexaodigital.auditoria.domain.model.enums.TipoEventoAuditoria;
import br.com.plataforma.conexaodigital.auditoria.domain.service.AuditoriaService;
import br.com.plataforma.conexaodigital.realm.domain.exceptions.RealmNotFoundException;
import br.com.plataforma.conexaodigital.realm.domain.repository.RealmRepository;
import br.com.plataforma.conexaodigital.role.domain.exceptions.RoleNotFoundException;
import br.com.plataforma.conexaodigital.role.domain.model.Role;
import br.com.plataforma.conexaodigital.role.domain.repository.RoleRepository;
import br.com.plataforma.conexaodigital.shared.email.EmailService;
import br.com.plataforma.conexaodigital.shared.security.EncryptionService;
import br.com.plataforma.conexaodigital.usuario.api.requests.AtualizarUsuarioRequest;
import br.com.plataforma.conexaodigital.usuario.api.requests.CriarUsuarioRequest;
import br.com.plataforma.conexaodigital.usuario.api.requests.ResetSenhaAdminRequest;
import br.com.plataforma.conexaodigital.usuario.api.requests.SolicitarRecuperacaoSenhaRequest;
import br.com.plataforma.conexaodigital.usuario.api.requests.ValidarCodigoRecuperacaoRequest;
import br.com.plataforma.conexaodigital.usuario.api.responses.SolicitarRecuperacaoSenhaResponse;
import br.com.plataforma.conexaodigital.usuario.api.responses.UsuarioResponse;
import br.com.plataforma.conexaodigital.usuario.domain.exceptions.CodigoRecuperacaoInvalidoException;
import br.com.plataforma.conexaodigital.usuario.domain.exceptions.EmailJaExisteException;
import br.com.plataforma.conexaodigital.usuario.domain.exceptions.RolesNaoSelecionadasException;
import br.com.plataforma.conexaodigital.usuario.domain.exceptions.UsuarioJaBloqueadoException;
import br.com.plataforma.conexaodigital.usuario.domain.exceptions.UsuarioNaoBloqueadoException;
import br.com.plataforma.conexaodigital.usuario.domain.exceptions.UsuarioNotFoundException;
import br.com.plataforma.conexaodigital.usuario.domain.model.CodigoRecuperacao;
import br.com.plataforma.conexaodigital.usuario.domain.model.Usuario;
import br.com.plataforma.conexaodigital.usuario.domain.model.enums.StatusUsuario;
import br.com.plataforma.conexaodigital.usuario.domain.repository.CodigoRecuperacaoRepository;
import br.com.plataforma.conexaodigital.usuario.domain.repository.UsuarioRepository;
import br.com.plataforma.conexaodigital.usuario.infrastructure.persistence.UsuarioSpecification;

/**
 * Implementation of UsuarioService.
 * Contains business logic for user operations.
 * Role association and validation are fully implemented (epic-13-story-08).
 */
@Service
@Transactional
public class UsuarioServiceImpl implements UsuarioService {

    private final UsuarioRepository usuarioRepository;
    private final RealmRepository realmRepository;
    private final RoleRepository roleRepository;
    private final PasswordEncoder passwordEncoder;
    private final CodigoRecuperacaoRepository codigoRecuperacaoRepository;
    private final EncryptionService encryptionService;
    private final EmailService emailService;
    private final AuditoriaService auditoriaService;

    /**
     * Constructor with dependency injection.
     *
     * @param usuarioRepository           The user repository
     * @param realmRepository             The realm repository
     * @param roleRepository              The role repository
     * @param passwordEncoder             The password encoder for hashing passwords
     * @param codigoRecuperacaoRepository The recovery code repository
     * @param encryptionService           The encryption service for codes
     * @param emailService                The email service for sending codes
     * @param auditoriaService            The audit service for logging events
     */
    public UsuarioServiceImpl(
            UsuarioRepository usuarioRepository,
            RealmRepository realmRepository,
            RoleRepository roleRepository,
            PasswordEncoder passwordEncoder,
            CodigoRecuperacaoRepository codigoRecuperacaoRepository,
            EncryptionService encryptionService,
            EmailService emailService,
            AuditoriaService auditoriaService) {
        this.usuarioRepository = usuarioRepository;
        this.realmRepository = realmRepository;
        this.roleRepository = roleRepository;
        this.passwordEncoder = passwordEncoder;
        this.codigoRecuperacaoRepository = codigoRecuperacaoRepository;
        this.encryptionService = encryptionService;
        this.emailService = emailService;
        this.auditoriaService = auditoriaService;
    }

    /**
     * Creates a new user with provided data.
     *
     * @param request The request containing user data
     * @return The created user response
     * @throws EmailJaExisteException        if email already exists
     * @throws RealmNotFoundException        if realm not found
     * @throws RoleNotFoundException         if role not found
     * @throws RolesNaoSelecionadasException if no roles are selected
     * @see epic-13-story-08-associacao-roles-multi-select.md
     */
    @Override
    @Transactional
    public UsuarioResponse criar(CriarUsuarioRequest request) {
        // Normalize email to lowercase
        String emailNormalizado = request.email().toLowerCase();

        // Check if email already exists (case-insensitive)
        if (usuarioRepository.existsByEmailIgnoreCase(emailNormalizado)) {
            throw new EmailJaExisteException(emailNormalizado);
        }

        // Verify realm exists
        if (!realmRepository.existsById(request.realmId())) {
            throw new RealmNotFoundException(request.realmId());
        }

        // Validate that at least one role is selected (epic-13-story-08)
        if (request.roleIds() == null || request.roleIds().isEmpty()) {
            throw new RolesNaoSelecionadasException();
        }

        // Verify all selected roles exist in database and fetch them
        Set<Role> roles = request.roleIds().stream()
                .map(roleId -> roleRepository.findById(roleId)
                        .orElseThrow(() -> new RoleNotFoundException(roleId)))
                .collect(Collectors.toSet());

        // Create user entity
        Usuario usuario = new Usuario();
        usuario.setNome(request.nome());
        usuario.setEmail(emailNormalizado);
        // Encode password with BCrypt
        String senhaCriptografada = passwordEncoder.encode(request.senha());
        usuario.setSenha(senhaCriptografada);
        usuario.setRealmId(request.realmId());
        usuario.setEmpresaId(request.empresaId());
        usuario.setTenantId(request.tenentId());
        usuario.setStatus(StatusUsuario.ATIVO);

        // Associate roles with user
        usuario.setRoles(roles);

        // Save user
        Usuario usuarioSalvo = usuarioRepository.save(usuario);

        // Registrar evento de auditoria
        auditoriaService.registrarEvento(
                TipoEventoAuditoria.CRIACAO_USUARIO,
                String.format("Usuário criado: %s (ID: %s, Email: %s)", usuarioSalvo.getNome(), usuarioSalvo.getId(),
                        emailNormalizado),
                usuarioSalvo.getId(),
                emailNormalizado,
                usuarioSalvo.getRealmId(),
                null);

        // Map to response with roles
        List<UUID> roleIds = roles.stream()
                .map(Role::getId)
                .collect(Collectors.toList());
        List<String> roleNomes = roles.stream()
                .map(Role::getNome)
                .collect(Collectors.toList());

        return mapearParaResponse(usuarioSalvo, roleIds, roleNomes);
    }

    /**
     * Updates an existing user with provided data.
     *
     * @param id      The ID of user to update
     * @param request The request containing updated user data
     * @return The updated user response
     * @throws EmailJaExisteException        if email already exists for another
     *                                       user
     * @throws UsuarioNotFoundException      if user not found
     * @throws RoleNotFoundException         if role not found
     * @throws RolesNaoSelecionadasException if no roles are selected
     * @see epic-13-story-08-associacao-roles-multi-select.md
     */
    @Override
    @Transactional
    public UsuarioResponse atualizar(UUID id, AtualizarUsuarioRequest request) {
        // Find existing user
        Usuario usuario = usuarioRepository.findById(id)
                .orElseThrow(() -> new UsuarioNotFoundException(id));

        // Normalize email to lowercase
        String emailNormalizado = request.email().toLowerCase();

        // Check if email already exists for another user (excluding current user,
        // case-insensitive)
        if (!usuario.getEmail().equals(emailNormalizado) &&
                usuarioRepository.existsByEmailIgnoreCaseAndIdNot(emailNormalizado, id)) {
            throw new EmailJaExisteException(emailNormalizado);
        }

        // Validate that at least one role is selected (epic-13-story-08)
        if (request.roleIds() == null || request.roleIds().isEmpty()) {
            throw new RolesNaoSelecionadasException();
        }

        // Verify all selected roles exist in database and fetch them
        Set<Role> roles = request.roleIds().stream()
                .map(roleId -> roleRepository.findById(roleId)
                        .orElseThrow(() -> new RoleNotFoundException(roleId)))
                .collect(Collectors.toSet());

        // Update user fields
        usuario.setNome(request.nome());
        usuario.setEmail(emailNormalizado);
        usuario.setEmpresaId(request.empresaId());
        usuario.setTenantId(request.tenentId());
        usuario.setCpfOrCnpj(request.cpfOrCnpj());

        // Update roles - clear existing roles and add new ones
        usuario.getRoles().clear();
        usuario.getRoles().addAll(roles);

        // Save updated user
        Usuario usuarioAtualizado = usuarioRepository.save(usuario);

        // Registrar evento de auditoria
        auditoriaService.registrarEvento(
                TipoEventoAuditoria.ATUALIZACAO_USUARIO,
                String.format("Usuário atualizado: %s (ID: %s, Email: %s)", usuarioAtualizado.getNome(),
                        usuarioAtualizado.getId(), emailNormalizado),
                usuarioAtualizado.getId(),
                emailNormalizado,
                usuarioAtualizado.getRealmId(),
                null);

        // Map to response with roles
        List<UUID> roleIds = roles.stream()
                .map(Role::getId)
                .collect(Collectors.toList());
        List<String> roleNomes = roles.stream()
                .map(Role::getNome)
                .collect(Collectors.toList());

        return mapearParaResponse(usuarioAtualizado, roleIds, roleNomes);
    }

    /**
     * Blocks an existing user, preventing authentication.
     *
     * @param id The ID of user to block
     * @return The blocked user response
     * @throws UsuarioNotFoundException    if user not found
     * @throws UsuarioJaBloqueadoException if user is already blocked
     */
    @Override
    @Transactional
    public UsuarioResponse bloquear(UUID id) {
        // Find existing user
        Usuario usuario = usuarioRepository.findById(id)
                .orElseThrow(() -> new UsuarioNotFoundException(id));

        // Check if user is already blocked
        if (usuario.getStatus() == StatusUsuario.BLOQUEADO) {
            throw new UsuarioJaBloqueadoException(id);
        }

        // Change status to blocked
        usuario.setStatus(StatusUsuario.BLOQUEADO);

        // Save blocked user
        Usuario usuarioBloqueado = usuarioRepository.save(usuario);

        // TODO: Revoke user tokens when Epic 4 (OAuth2) is implemented
        // This will integrate with token management to invalidate existing tokens

        // Map to response with roles
        List<UUID> roleIds = usuarioBloqueado.getRoles().stream()
                .map(Role::getId)
                .collect(Collectors.toList());
        List<String> roleNomes = usuarioBloqueado.getRoles().stream()
                .map(Role::getNome)
                .collect(Collectors.toList());

        return mapearParaResponse(usuarioBloqueado, roleIds, roleNomes);
    }

    /**
     * {@inheritDoc}
     *
     * @param id The ID of user to unblock
     * @return The unblocked user response
     * @throws UsuarioNotFoundException     if user not found
     * @throws UsuarioNaoBloqueadoException if user is not blocked
     */
    @Override
    @Transactional
    public UsuarioResponse desbloquear(UUID id) {
        // Find existing user
        Usuario usuario = usuarioRepository.findById(id)
                .orElseThrow(() -> new UsuarioNotFoundException(id));

        // Check if user is not blocked
        if (usuario.getStatus() != StatusUsuario.BLOQUEADO) {
            throw new UsuarioNaoBloqueadoException(id);
        }

        // Change status to active
        usuario.setStatus(StatusUsuario.ATIVO);

        // Save unblocked user
        Usuario usuarioDesbloqueado = usuarioRepository.save(usuario);

        // TODO: Handle token reactivation when Epic 4 (OAuth2) is implemented
        // This will integrate with token management to allow new authentication

        // Map to response with roles
        List<UUID> roleIds = usuarioDesbloqueado.getRoles().stream()
                .map(Role::getId)
                .collect(Collectors.toList());
        List<String> roleNomes = usuarioDesbloqueado.getRoles().stream()
                .map(Role::getNome)
                .collect(Collectors.toList());

        return mapearParaResponse(usuarioDesbloqueado, roleIds, roleNomes);
    }

    /**
     * {@inheritDoc}
     *
     * @param id      The ID of user whose password to reset
     * @param request The request containing new password
     * @throws UsuarioNotFoundException if user not found
     */
    @Override
    @Transactional
    public void resetSenhaAdmin(UUID id, ResetSenhaAdminRequest request) {
        // Find existing user
        Usuario usuario = usuarioRepository.findById(id)
                .orElseThrow(() -> new UsuarioNotFoundException(id));

        // Encode new password with BCrypt
        String senhaCriptografada = passwordEncoder.encode(request.novaSenha());

        // Update password
        usuario.setSenha(senhaCriptografada);

        // Save user with new password
        usuarioRepository.save(usuario);

        // TODO: Revoke user tokens when Epic 4 (OAuth2) is implemented
        // This will integrate with token management to invalidate existing tokens

        // Note: Audit logging is handled automatically by @LastModifiedDate
    }

    /**
     * {@inheritDoc}
     *
     * @param request The request containing user's email
     * @return Response with confirmation message
     */
    @Override
    @Transactional
    public SolicitarRecuperacaoSenhaResponse solicitarRecuperacaoSenha(SolicitarRecuperacaoSenhaRequest request) {
        // Normalize email to lowercase
        String emailNormalizado = request.email().toLowerCase();

        // Find user by email - this may not find user
        Optional<Usuario> usuarioOptional = usuarioRepository.findByEmail(emailNormalizado);

        if (usuarioOptional.isPresent()) {
            Usuario usuario = usuarioOptional.get();

            // Only proceed if user is active
            if (usuario.getStatus() == StatusUsuario.ATIVO) {
                // Generate 6-digit numeric code
                String codigoGerado = gerarCodigoRecuperacao();

                // Encrypt code
                String codigoCriptografado = encryptionService.encrypt(codigoGerado);

                // Calculate expiration time (30 minutes from now)
                LocalDateTime dataExpiracao = LocalDateTime.now().plusMinutes(30);

                // Invalidate previous codes by marking them as used
                codigoRecuperacaoRepository.findTopByUsuarioIdOrderByDataCriacaoDesc(usuario.getId())
                        .ifPresent(codigoExistente -> {
                            codigoExistente.setUtilizado(true);
                            codigoRecuperacaoRepository.save(codigoExistente);
                        });

                // Save new recovery code
                CodigoRecuperacao novoCodigo = new CodigoRecuperacao(
                        usuario.getId(),
                        codigoCriptografado,
                        dataExpiracao);
                codigoRecuperacaoRepository.save(novoCodigo);

                // Send email with code
                emailService.enviarCodigoRecuperacaoSenha(emailNormalizado, codigoGerado);

                // Registrar evento de auditoria
                auditoriaService.registrarEvento(
                        TipoEventoAuditoria.SOLICITACAO_RECUPERACAO_SENHA,
                        String.format("Solicitação de recuperação de senha enviada para: %s (ID: %s)", emailNormalizado,
                                usuario.getId()),
                        usuario.getId(),
                        emailNormalizado,
                        usuario.getRealmId(),
                        null);
            }
        }

        // Always return success even if user doesn't exist (prevents user enumeration)
        return new SolicitarRecuperacaoSenhaResponse(
                "Se o e-mail estiver cadastrado, você receberá um código de recuperação em breve.");
    }

    /**
     * {@inheritDoc}
     *
     * @param request The request containing email, code, and new password
     * @throws UsuarioNotFoundException           if user not found
     * @throws CodigoRecuperacaoInvalidoException if code is invalid, expired, or
     *                                            already used
     */
    @Override
    @Transactional
    public void validarCodigoRecuperacao(ValidarCodigoRecuperacaoRequest request) {
        // Normalize email to lowercase
        String emailNormalizado = request.email().toLowerCase();

        // Find user by email
        Usuario usuario = usuarioRepository.findByEmail(emailNormalizado)
                .orElseThrow(() -> new UsuarioNotFoundException(emailNormalizado));

        // Check if user is active
        if (usuario.getStatus() != StatusUsuario.ATIVO) {
            throw new CodigoRecuperacaoInvalidoException(
                    "Usuário não está ativo para redefinição de senha");
        }

        // Find most recent recovery code for this user
        Optional<CodigoRecuperacao> codigoOpt = codigoRecuperacaoRepository
                .findTopByUsuarioIdOrderByDataCriacaoDesc(usuario.getId());

        if (codigoOpt.isEmpty()) {
            throw new CodigoRecuperacaoInvalidoException();
        }

        CodigoRecuperacao codigo = codigoOpt.get();

        // Decrypt stored code and compare with provided code
        String codigoDescriptografado;
        try {
            codigoDescriptografado = encryptionService.decrypt(codigo.getCodigo());
        } catch (Exception e) {
            throw new CodigoRecuperacaoInvalidoException();
        }

        if (!codigoDescriptografado.equals(request.codigo())) {
            throw new CodigoRecuperacaoInvalidoException();
        }

        // Check if code has expired
        if (codigo.getDataExpiracao().isBefore(LocalDateTime.now())) {
            throw new CodigoRecuperacaoInvalidoException("Código de recuperação expirado");
        }

        // Check if code has already been used
        if (codigo.getUtilizado()) {
            throw new CodigoRecuperacaoInvalidoException("Código já foi utilizado");
        }

        // Encode new password with BCrypt
        String senhaCriptografada = passwordEncoder.encode(request.novaSenha());

        // Update user's password
        usuario.setSenha(senhaCriptografada);

        // Save updated user
        usuarioRepository.save(usuario);

        // Mark code as used
        codigo.setUtilizado(true);
        codigoRecuperacaoRepository.save(codigo);

        // TODO: Revoke user tokens when Epic 4 (OAuth2) is implemented
        // This will integrate with token management to invalidate existing tokens

        // TODO: Audit logging for REDEFINICAO_SENHA when Epic 7 is implemented
    }

    /**
     * {@inheritDoc}
     *
     * @param nome              Partial name filter (case-insensitive)
     * @param email             Partial email filter (case-insensitive)
     * @param realmId           Exact realm ID filter
     * @param empresaId         Exact empresa ID filter
     * @param tenentId          Exact tenant ID filter
     * @param status            Status filter
     * @param roleIds           Users with any of specified roles
     * @param dataCriacaoInicio Creation date start filter
     * @param dataCriacaoFim    Creation date end filter
     * @param pageable          Pagination and sorting information
     * @return Paginated list of users matching filters
     */
    @Override
    @Transactional(readOnly = true)
    public Page<UsuarioResponse> listar(String nome, String email, UUID realmId, String empresaId, String tenentId,
            StatusUsuario status, List<UUID> roleIdsFilter, LocalDateTime dataCriacaoInicio,
            LocalDateTime dataCriacaoFim, Pageable pageable) {

        // Build specification with all filters
        Specification<Usuario> spec = Specification.where(null);

        if (nome != null && !nome.trim().isEmpty()) {
            spec = spec.and(UsuarioSpecification.comNome(nome.trim()));
        }

        if (email != null && !email.trim().isEmpty()) {
            spec = spec.and(UsuarioSpecification.comEmail(email.trim()));
        }

        if (realmId != null) {
            spec = spec.and(UsuarioSpecification.comRealmId(realmId));
        }

        if (empresaId != null && !empresaId.trim().isEmpty()) {
            spec = spec.and(UsuarioSpecification.comEmpresaId(empresaId.trim()));
        }

        if (tenentId != null && !tenentId.trim().isEmpty()) {
            spec = spec.and(UsuarioSpecification.comTenentId(tenentId.trim()));
        }

        if (status != null) {
            spec = spec.and(UsuarioSpecification.comStatus(status));
        }

        if (roleIdsFilter != null && !roleIdsFilter.isEmpty()) {
            spec = spec.and(UsuarioSpecification.comRoleIds(roleIdsFilter));
        }

        if (dataCriacaoInicio != null || dataCriacaoFim != null) {
            spec = spec.and(UsuarioSpecification.comDataCriacaoEntre(dataCriacaoInicio, dataCriacaoFim));
        }

        // Execute query with pagination
        Page<Usuario> usuariosPage = usuarioRepository.findAll(spec, pageable);

        // Map to response DTOs
        return usuariosPage.map(usuario -> {
            // Get role IDs and names
            List<UUID> roleIds = usuario.getRoles().stream()
                    .map(Role::getId)
                    .collect(Collectors.toList());
            List<String> roleNomes = usuario.getRoles().stream()
                    .map(Role::getNome)
                    .collect(Collectors.toList());

            return mapearParaResponse(usuario, roleIds, roleNomes);
        });
    }

    /**
     * Generates a 6-digit numeric recovery code.
     *
     * @return 6-digit numeric code as string
     */
    private String gerarCodigoRecuperacao() {
        SecureRandom random = new SecureRandom();
        int codigo = 100000 + random.nextInt(900000); // Generates number between 100000 and 999999
        return String.valueOf(codigo);
    }

/**
     * Finds a user by their unique ID.
     *
     * @param id The ID of the user to find
     * @return The user response with all details
     * @throws UsuarioNotFoundException if user not found
     */
    @Override
    @Transactional(readOnly = true)
    public UsuarioResponse buscarPorId(UUID id) {
        // Find user by ID
        Usuario usuario = usuarioRepository.findById(id)
                .orElseThrow(() -> new UsuarioNotFoundException(id));

        // Map to response with roles
        List<UUID> roleIds = usuario.getRoles().stream()
                .map(Role::getId)
                .collect(Collectors.toList());
        List<String> roleNomes = usuario.getRoles().stream()
                .map(Role::getNome)
                .collect(Collectors.toList());

        return mapearParaResponse(usuario, roleIds, roleNomes);
    }

    /**
     * Finds a user by their username (email address).
     * Uses case-insensitive search for email matching.
     *
     * @param username The username (email) to search for
     * @return The user response with all details
     * @throws UsuarioNotFoundException if user not found
     */
    @Override
    @Transactional(readOnly = true)
    public UsuarioResponse buscarPorUsername(String username) {
        // Normalize username (email) to lowercase for case-insensitive search
        String usernameNormalizado = username != null ? username.toLowerCase().trim() : null;
        
        if (usernameNormalizado == null || usernameNormalizado.isEmpty()) {
            throw new IllegalArgumentException("Username não pode ser nulo ou vazio");
        }

        // Find user by email (case-insensitive)
        Usuario usuario = usuarioRepository.findByEmail(usernameNormalizado)
                .orElseThrow(() -> new UsuarioNotFoundException("Usuário não encontrado com username: " + username));

        // Map to response with roles
        List<UUID> roleIds = usuario.getRoles().stream()
                .map(Role::getId)
                .collect(Collectors.toList());
        List<String> roleNomes = usuario.getRoles().stream()
                .map(Role::getNome)
                .collect(Collectors.toList());

        return mapearParaResponse(usuario, roleIds, roleNomes);
    }

    /**
     * Maps a Usuario entity to UsuarioResponse DTO.
     *
     * @param usuario   The user entity
     * @param roleIds   List of role IDs
     * @param roleNomes List of role names
     * @return The user response DTO
     */
    private UsuarioResponse mapearParaResponse(Usuario usuario, List<UUID> roleIds, List<String> roleNomes) {
        // Get realm name (simplified - in real implementation would query realm)
        String realmNome = "Realm-" + usuario.getRealmId().toString().substring(0, 8);

        // Get realm status (simplified - in real implementation would query realm)
        var realmStatus = br.com.plataforma.conexaodigital.realm.domain.model.StatusRealm.ATIVO;

        return new UsuarioResponse(
                usuario.getId(),
                usuario.getNome(),
                usuario.getCpfOrCnpj(),
                usuario.getEmail(),
                usuario.getRealmId(),
                realmNome,
                roleIds,
                roleNomes,
                usuario.getEmpresaId(),
                usuario.getTenantId(),
                usuario.getStatus(),
                realmStatus,
                usuario.getDataCriacao(),
                usuario.getDataUltimoLogin(),
                usuario.getDataAtualizacao());
    }
}

```
```java
package br.com.plataforma.conexaodigital.usuario.infrastructure.persistence;

import br.com.plataforma.conexaodigital.usuario.domain.model.Usuario;
import br.com.plataforma.conexaodigital.usuario.domain.model.enums.StatusUsuario;
import org.springframework.data.jpa.domain.Specification;
import jakarta.persistence.criteria.JoinType;
import jakarta.persistence.criteria.Predicate;
import jakarta.persistence.criteria.Join;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

/**
 * JPA Specification for Usuario entity queries.
 * Provides reusable specifications for complex filtering operations.
 */
public class UsuarioSpecification {

    /**
     * Creates a specification to filter users by name (case-insensitive partial match).
     *
     * @param nome the name to filter (partial match, case-insensitive)
     * @return Specification for filtering by name
     */
    public static Specification<Usuario> comNome(String nome) {
        return (root, query, cb) -> 
            nome == null ? null : cb.like(cb.lower(root.get("nome")), "%" + nome.toLowerCase() + "%");
    }

    /**
     * Creates a specification to filter users by email (case-insensitive partial match).
     *
     * @param email the email to filter (partial match, case-insensitive)
     * @return Specification for filtering by email
     */
    public static Specification<Usuario> comEmail(String email) {
        return (root, query, cb) -> 
            email == null ? null : cb.like(cb.lower(root.get("email")), "%" + email.toLowerCase() + "%");
    }

    /**
     * Creates a specification to filter users by realm ID.
     *
     * @param realmId The realm ID to filter by
     * @return Specification for filtering by realm ID
     */
    public static Specification<Usuario> comRealmId(UUID realmId) {
        return (root, query, cb) ->
            realmId == null ? null : cb.equal(root.get("realmId"), realmId);
    }

    /**
     * Creates a specification to filter users by empresa ID.
     *
     * @param empresaId the empresa ID to filter
     * @return Specification for filtering by empresa ID
     */
    public static Specification<Usuario> comEmpresaId(String empresaId) {
        return (root, query, cb) -> 
            empresaId == null ? null : cb.equal(root.get("empresaId"), empresaId);
    }

    /**
     * Creates a specification to filter users by tenant ID.
     *
     * @param tenentId the tenant ID to filter
     * @return Specification for filtering by tenant ID
     */
    public static Specification<Usuario> comTenentId(String tenentId) {
        return (root, query, cb) -> 
            tenentId == null ? null : cb.equal(root.get("tenentId"), tenentId);
    }

    /**
     * Creates a specification to filter users by status.
     *
     * @param status the status to filter
     * @return Specification for filtering by status
     */
    public static Specification<Usuario> comStatus(StatusUsuario status) {
        return (root, query, cb) -> 
            status == null ? null : cb.equal(root.get("status"), status);
    }

    /**
     * Creates a specification to filter users by role IDs.
     * Users returned will have ANY of the specified roles (OR logic).
     * TODO: Implement when user-role relationship is established in Epic 3
     *
     * @param roleIds list of role IDs to filter (users with any of these roles)
     * @return Specification for filtering by role IDs (currently returns all users)
     */
    public static Specification<Usuario> comRoleIds(List<UUID> roleIds) {
        return (root, query, cb) -> {
            if (roleIds == null || roleIds.isEmpty()) return null;
            // TODO: Implement role filtering when Epic 3 is complete
            // For now, return all users (no filtering)
            return cb.conjunction();
        };
    }

    /**
     * Creates a specification to filter users by creation date range.
     *
     * @param dataInicio start date (inclusive, optional)
     * @param dataFim end date (inclusive, optional)
     * @return Specification for filtering by creation date range
     */
    public static Specification<Usuario> comDataCriacaoEntre(LocalDateTime dataInicio, LocalDateTime dataFim) {
        return (root, query, cb) -> {
            if (dataInicio == null && dataFim == null) return null;
            
            if (dataInicio != null && dataFim != null) {
                return cb.between(root.get("dataCriacao"), dataInicio, dataFim);
            } else if (dataInicio != null) {
                return cb.greaterThanOrEqualTo(root.get("dataCriacao"), dataInicio);
            } else {
                return cb.lessThanOrEqualTo(root.get("dataCriacao"), dataFim);
            }
        };
    }

    /**
     * Creates a specification to filter users by multiple criteria using AND logic.
     *
     * @param specifications list of specifications to combine with AND
     * @return combined Specification
     */
    public static Specification<Usuario> comFiltros(Specification<Usuario>... specifications) {
        return (root, query, cb) -> {
            Predicate[] predicates = java.util.Arrays.stream(specifications)
                    .map(spec -> spec.toPredicate(root, query, cb))
                    .filter(predicate -> predicate != null)
                    .toArray(Predicate[]::new);
            
            return predicates.length > 0 ? cb.and(predicates) : cb.conjunction();
        };
    }
}
```